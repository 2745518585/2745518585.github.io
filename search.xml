<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于 Orita</title>
    <url>/post/Orita-about/</url>
    <content><![CDATA[<p><a href="https://github.com/2745518585/Orita">Orita</a></p>
<p>由 <a href="https://github.com/2745518585/">赵悦岑</a> 开发的一款 OI 工具，包括评测、对拍、数据生成等，主要由 C++ 语言编写。</p>
<p>由 <a href="https://github.com/Sukwants">Sukwants</a>、<a href="https://pond.ink/">Pond Ink</a> 团队和 <a href="https://github.com/syysongyuyang">syysongyuyang</a> 提供技术支持。</p>
<p><a href="https://github.com/Sukwants"><img src="https://avatars.githubusercontent.com/u/95968907?s=64&v=4" alt="0"></a> <a href="https://pond.ink/"><img src="https://pond.ink/images/avatar.png" height=64x width=64x alt></a> <a href="https://github.com/syysongyuyang"><img src="https://avatars.githubusercontent.com/u/123732645" height=64x width=64x alt></a></p>
<p>相关项目：</p>
<ul>
<li><a href="https://github.com/2745518585/vscode-Orita">vscode-Orita</a> - VSCode extension for Orita</li>
<li><a href="https://github.com/Sukwants/Atiro">Atiro</a> - Useless OI Tools</li>
</ul>
]]></content>
      <tags>
        <tag>Orita</tag>
      </tags>
  </entry>
  <entry>
    <title>APIO 2024 游记</title>
    <url>/post/APIO2024-travels/</url>
    <content><![CDATA[<p><img src="/" alt="我他喵的在淦鸟吗"></p>
<h2 id="sim-Day-2"><a href="#sim-Day-2" class="headerlink" title="$\sim$ Day $-2$"></a>$\sim$ Day $-2$</h2><p>**** 怎么羊了，而且全机房就我一个有症状，不理解，不过还好一晚上就退烧了。</p>
<p>注意到试机使用的是 QOJ，CCF 终于抛弃那个一个 sub T 一个点要全部测完的逼 oj 了。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day $-1$"></a>Day $-1$</h2><p>九点双流飞萧山的飞机，起的比平时还早。这趟航班上居然不给饭，唯一给的面包还巨难吃。到了学军都一点了，吃残羹冷炙。吃饭的时候和 <a href="https://wtyakioi.github.io/">zsq</a> 和 yl 一起去的，成功被 yl 的自动寻路带到了小卖部。回来还迷路了，然后看见有个保安在驱逐在校园里随机游走的同学，这下变成集中营了 &#x2F;ll。</p>
<p>然后才注意到只有我的狗牌有大头照，坏了，怎么被安成 A 队了，要打国际铁牌了 &#x2F;ll。</p>
<p>和 251Sec 巨佬一个房间 &#x2F;bx&#x2F;bx&#x2F;bx&#x2F;bx。祂这房间本来只有一个床，硬添了一个临时的床进去，由于 251 先到，被迫选了大的那个。由于房间在转角位置，还多了一个神秘房间，靠外的两面墙都是巨大的窗户，感觉很适合趴着想题。</p>
<p>原地开摆。注意到开幕式居然是明天，好耶，继续摆。</p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day $0$"></a>Day $0$</h2><p>上午讲的是概率相关的，尝试去听了一哈，然后发现学术厅没有网。听了一哈不想听了，发现其他人都润了，遂润。然后摆了一上午。</p>
<p>下午讲积性函数，感觉大概率听不懂，然后一问大家都不去，遂摆。</p>
<p>晚上去开幕式，实在是一点网没有，中途把 <a href="https://wtyakioi.github.io/">zsq</a> 的节目单给叠成了纸飞机，然后有些 yl 就开始疯狂扔纸飞机，这边建议写上 “** CCF” 然后扔到主席台上去。注意到前面后面的人都在打 phi，于是也开始打，然后被 yl 用纸飞机疯狂骚扰。</p>
<p>颓到十二点过一点 251 就睡了，相比之前几次这次睡的算是相当早了。</p>
<p>省流：颓了一整天。</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day $1$"></a>Day $1$</h2><p>测试日。先试机，旁边的人都啪啪地敲，但实在没啥想敲的，直接睡一个小时。</p>
<p>开题，稍微卡了一分钟，T1 居然是一眼的傻逼题，随便胡个 Tarjan 十多分钟就过了。T2 可能是某种神秘建图？搞了好久没搞出来，考虑神秘 dp 优化，又思考了一会，尝试根号做法，发现根号分治后使用根号数据结构维护可以做到单根号，感觉写起来巨抽象，先看一眼 T3。T3 感觉随便乱搞，但是考虑到祂都扔到了 APIO 上，交互库应该巨强只放确定性做法过（怎么可能存在这种交互库&#x2F;oh），然后直接开 T2。一点写完第一版，WA 了，然后稍微拍了一下，WA 了最后一个 sub 的第二十多个点。尝试拍了好久没拍出来，通读代码也没找出来，开始尝试各种可能挂的地方。整到最后都没调出来，只去写了 T3 $5$ 分。只有 $145$，这下打铁力。</p>
<p>出来一问，好像 <a href="https://blog.zlx.pw/">zlx</a> 和 <a href="https://wtyakioi.github.io/">zsq</a> 是 $110$，季老师和 xby 过 T2，yl 过 T3，iee 阿克 &#x2F;bx。一看群 T3 全是艹过去的，问了哈 yl 结果祂也是随机艹过去的。坏了，这下输麻了，我还以为祂敢放出来交互库得有多聪明。然后这场就变成了一道签到一道傻逼数据结构一道傻逼乱搞，太高质量了。听说这次阿克的有近六十个。</p>
<p>讲课没去听，按去年惯例是不允许说做法然后变成国家队吹牛。结果这次好像讲了，T2 好像有决策单调性，T3 好像是 CRT，感觉都好正确。</p>
<p><img src="/post-images/APIO2024-travels-1.png" alt="1"></p>
<p>高举厕所牌。</p>
<p>反正彻底开摆了，一点才睡。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day $2$"></a>Day $2$</h2><p>上午一看就不是人听的，希望不要 “不发证书”。</p>
<p>下午不想去。</p>
<p>晚上闭幕式，Cu $115$，Ag $200$，Au $245$。hwt 上来锐评题目，什么部分分较多都说得出来，祂说一句大家鼓一次掌，直接让祂下不了台。然后 dzd 上来直接就是一句 “我希望 NOI 的出题也能像 APIO 一样”，艹，烂完了，NOI 6 道通信题。</p>
<p>省流：颓了一整天。</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day $3$"></a>Day $3$</h2><p>润。大巴居然来迟了二十分钟，早高峰都成理由了。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题.md</title>
    <url>/post/mess/</url>
    <content><![CDATA[<h4 id="QOJ6-玛里苟斯"><a href="#QOJ6-玛里苟斯" class="headerlink" title="QOJ6 玛里苟斯"></a><a href="https://qoj.ac/problem/6">QOJ6</a> 玛里苟斯</h4><p>注意到一个集合的答案等于其线性基的答案。</p>
<p>$k \ge 3$ 暴力，$k&#x3D;1,2$ 单独考虑。</p>
<h4 id="P6837-QOJ1138-Counting-Mushrooms"><a href="#P6837-QOJ1138-Counting-Mushrooms" class="headerlink" title="P6837 QOJ1138 Counting Mushrooms"></a><a href="https://www.luogu.com.cn/problem/P6837">P6837</a> <a href="https://qoj.ac/problem/1138">QOJ1138</a> Counting Mushrooms</h4><p>根号分治，先查出根号个 $0&#x2F;1$，再一次查询根号个。</p>
<p>精细实现，$2$ 次查 $5$ 个。</p>
<h4 id="QOJ1430-Ineq"><a href="#QOJ1430-Ineq" class="headerlink" title="QOJ1430 Ineq"></a><a href="https://qoj.ac/problem/1430">QOJ1430</a> Ineq</h4><p>Pick 定理数凸包内点数</p>
<h4 id="P8985-QOJ3270-魔塔-OL"><a href="#P8985-QOJ3270-魔塔-OL" class="headerlink" title="P8985 QOJ3270 魔塔 OL"></a><a href="https://www.luogu.com.cn/problem/P8985">P8985</a> <a href="https://qoj.ac/problem/3270">QOJ3270</a> 魔塔 OL</h4><p>贪心部分，前半段 $a_i \le b_i$，按 $a_i$ 升序，后半段按 $b_i$ 降序，反向操作可证。</p>
<p>转化为四维偏序，考虑对于高维偏序的一般做法：用 bitset 处理出落在这个前缀内的所有点的标号，那么一次查询相当于将每个维度对应的 bitset 求交。由于这里需要顺序递推，考虑分块，每块长 $\log$，块内 $2^B$ 处理，复杂度 $O(\frac{(n+q+V)n}{\log n})$。</p>
<h4 id="P8987-QOJ3272-简单数据结构"><a href="#P8987-QOJ3272-简单数据结构" class="headerlink" title="P8987 QOJ3272 简单数据结构"></a><a href="https://www.luogu.com.cn/problem/P8987">P8987</a> <a href="https://qoj.ac/problem/3272">QOJ3272</a> 简单数据结构</h4><p>注意到不降序列操作后仍然不降，且操作是全局的，考虑维护不降序列区间，整体二分可维护。</p>
<h4 id="QOJ4303-New-Level"><a href="#QOJ4303-New-Level" class="headerlink" title="QOJ4303 New Level"></a><a href="https://qoj.ac/problem/4303">QOJ4303</a> New Level</h4><p>题意：给定一个图和一个染色方案（$1 \sim k$），保证相邻两个点颜色不同，找出一个方案满足：</p>
<ol>
<li>相邻两个点颜色不同。</li>
<li>只保留两点颜色编号差模 $k$ 同余 $1$ 的边后图仍然连通。</li>
</ol>
<p>将边权设为两点颜色之差，将点权改为到 $1$ 的最短路。正确性易证。</p>
<h4 id="QOJ4891-树上的孤独"><a href="#QOJ4891-树上的孤独" class="headerlink" title="QOJ4891 树上的孤独"></a><a href="https://qoj.ac/problem/4891">QOJ4891</a> 树上的孤独</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d1-t3-42-%E6%A0%91%E4%B8%8A%E7%9A%84%E5%AD%A4%E7%8B%AC">题解</a></p>
<h4 id="QOJ4895-Lovely-Dogs"><a href="#QOJ4895-Lovely-Dogs" class="headerlink" title="QOJ4895 Lovely Dogs"></a><a href="https://qoj.ac/problem/4895">QOJ4895</a> Lovely Dogs</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d3-t1-9-lovely-dogs">题解</a></p>
<p>注意到 $f(i)$ 不为 $0$ 有 $f(i) &#x3D; f(d)f(\frac{i}{d})$，转化为统计子树内质因子个数不超过一定值的 $v$ 的和，容斥后可维护。</p>
<h4 id="P9055-QOJ4900-数列重排"><a href="#P9055-QOJ4900-数列重排" class="headerlink" title="P9055 QOJ4900 数列重排"></a><a href="https://www.luogu.com.cn/problem/P9055">P9055</a> <a href="https://qoj.ac/problem/4900">QOJ4900</a> 数列重排</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d4-t3-48-%E6%95%B0%E5%88%97%E9%87%8D%E6%8E%92">题解</a></p>
<p>对于一个 $k$，一个区间合法当且仅当 $0 \sim k-1$（称为关键数）都出现过，关键数依次排列显然最优：包含任意 $k$ 个关键数的区间均合法。非关键数仅能插到 $k$ 的整数倍位置和末尾。</p>
<h4 id="QOJ4906-球球"><a href="#QOJ4906-球球" class="headerlink" title="QOJ4906 球球"></a><a href="https://qoj.ac/problem/4906">QOJ4906</a> 球球</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d6-t3-19-%E7%90%83%E7%90%83">题解</a></p>
<p>分类讨论。用 $S_i$ 和 $T_i$ 分别表示人和分身在 $a_i$ 时另一个可以在的位置集合，几种操作都能简单维护。</p>
<h4 id="QOJ4909-《关于因为与去年互测zjk撞题而不得不改题这回事》"><a href="#QOJ4909-《关于因为与去年互测zjk撞题而不得不改题这回事》" class="headerlink" title="QOJ4909 《关于因为与去年互测zjk撞题而不得不改题这回事》"></a><a href="https://qoj.ac/problem/4909">QOJ4909</a> 《关于因为与去年互测zjk撞题而不得不改题这回事》</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d7-t3-29-%E5%85%B3%E4%BA%8E%E5%9B%A0%E4%B8%BA%E4%B8%8E%E5%8E%BB%E5%B9%B4%E4%BA%92%E6%B5%8Bzjk%E6%92%9E%E9%A2%98%E8%80%8C%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%94%B9%E9%A2%98%E8%BF%99%E5%9B%9E%E4%BA%8B">题解</a></p>
<p>贪心部分，如果当前位为 $1$ 的个数大于等于 $k$，则只保留当前位为 $1$ 的数，答案这一位为 $1$，否则这一位为 $0$。</p>
<p>假设当前序列有序，则只需要判断第 $k$ 大的数，而如果当前位为 $0$，忽略当前位的第 $k$ 大一定在整个序列前 $2k$ 个。所以 $\log v$ 层的前 $k$ 大一定在整个序列前 $k \log v$ 个，取出来暴力即可。</p>
<p>取出链上前 $q$ 大可以每次取最大值后分成两条链。</p>
<h4 id="QOJ4914-Slight-Hope"><a href="#QOJ4914-Slight-Hope" class="headerlink" title="QOJ4914 Slight Hope"></a><a href="https://qoj.ac/problem/4914">QOJ4914</a> Slight Hope</h4><p>$l$ 限制转为区间查，对 $r$ 分块。注意到一个区间构成的森林中作为根的节点深度相差至多为 $1$，可快速求出一个点所在根节点。</p>
<h4 id="QOJ4924-蜘蛛爬树"><a href="#QOJ4924-蜘蛛爬树" class="headerlink" title="QOJ4924 蜘蛛爬树"></a><a href="https://qoj.ac/problem/4924">QOJ4924</a> 蜘蛛爬树</h4><p><a href="https://4182543731.github.io/post/LullabyforTiuLii/#d12-t3-44-%E8%9C%98%E8%9B%9B%E7%88%AC%E6%A0%91">题解</a></p>
<p>分类讨论。发现查询可以在凸包上二分解决。树剖线段树维护凸包，建树时凸包从儿子归并可以少掉排序的 $\log$。</p>
<h4 id="QOJ5040-Dirichlet-k-th-root"><a href="#QOJ5040-Dirichlet-k-th-root" class="headerlink" title="QOJ5040 Dirichlet $k$-th root"></a><a href="https://qoj.ac/problem/5040">QOJ5040</a> Dirichlet $k$-th root</h4><p><a href="https://blog.csdn.net/qq_21334057/article/details/104382333">题解</a></p>
<p>当 $f(1)&#x3D;1$ 时，有 $f &#x3D; g^{\text{inv}(k)}$。</p>
<h4 id="QOJ5047-Permutation"><a href="#QOJ5047-Permutation" class="headerlink" title="QOJ5047 Permutation"></a><a href="https://qoj.ac/problem/5047">QOJ5047</a> Permutation</h4><p><a href="https://www.cnblogs.com/zhouzhendong/p/ECfinal2019.html">题解</a> J</p>
<p>每次按最小值分治。</p>
<h4 id="QOJ5171-理论出线"><a href="#QOJ5171-理论出线" class="headerlink" title="QOJ5171 理论出线"></a><a href="https://qoj.ac/problem/5171">QOJ5171</a> 理论出线</h4><h4 id="QOJ5305-Oscar-is-All-You-Need"><a href="#QOJ5305-Oscar-is-All-You-Need" class="headerlink" title="QOJ5305 Oscar is All You Need"></a><a href="https://qoj.ac/problem/5305">QOJ5305</a> Oscar is All You Need</h4><p>分类讨论。</p>
<p>注意到可以通过 $op(i,2),op(1,i)$ 将末尾数移至第 $i$ 个数后，考虑每次将插入到前面来排序。由于每段非空，显然不能将通过这种方法交换最后两个数，需特殊考虑。</p>
<h4 id="QOJ5308-RPG-Pro-League"><a href="#QOJ5308-RPG-Pro-League" class="headerlink" title="QOJ5308 RPG Pro League"></a><a href="https://qoj.ac/problem/5308">QOJ5308</a> RPG Pro League</h4><p>左边四个点分别代表一队中 $4$ 个位置，右边 $7$ 个点表示玩家类型，求出最多多少组对于左部点的完美匹配。考虑完美匹配的判断：Hall 定理（$\forall S \subseteq X,|N(S)| \ge |S|$），那么能拆分出的完美匹配组数就是 $\min(\frac{|N(S)|}{S}),S \subseteq X$。</p>
<p>考虑修改，显然加入&#x2F;删除 $x$ 后最多只会删除&#x2F;加入一个人，且这个人为所属类型集合中最大值&#x2F;集合外最小值，枚举即可。</p>
<h4 id="QOJ5309-Guess-Cycle-Length"><a href="#QOJ5309-Guess-Cycle-Length" class="headerlink" title="QOJ5309 Guess Cycle Length"></a><a href="https://qoj.ac/problem/5309">QOJ5309</a> Guess Cycle Length</h4><p>根号做法显然。考虑查询得到的编号一定在 $1$ 到 $n$ 之间，可以通过随机查询一些位置来得到一个较大的下限，然后使用根号做法即可。</p>
<h4 id="QOJ5312-Levenshtein-Distance"><a href="#QOJ5312-Levenshtein-Distance" class="headerlink" title="QOJ5312 Levenshtein Distance"></a><a href="https://qoj.ac/problem/5312">QOJ5312</a> Levenshtein Distance</h4><p>记 $f_{i,j}$ 表示 $S_{1,x}$ 与 $T_{1,x+j}$ 距离为 $i$，$x$ 最大值，ST 表维护 $\text{LCP}(S_{x,|S|},T_{y,|T|})$，对于 $T$ 每个起始位置 $k^2$ 转移一次即可。</p>
<h4 id="QOJ5418-Color-the-Tree"><a href="#QOJ5418-Color-the-Tree" class="headerlink" title="QOJ5418 Color the Tree"></a><a href="https://qoj.ac/problem/5418">QOJ5418</a> Color the Tree</h4><p>法 1：考虑每层分开考虑，对当前层的所有点建虚树后可 dp。</p>
<p>法 2：$f_{x,i}$ 表示 $x$ 子树中第 $i$ 层全部染色的代价，长链剖分可做。</p>
<h4 id="QOJ5421-Factories-Once-More"><a href="#QOJ5421-Factories-Once-More" class="headerlink" title="QOJ5421 Factories Once More"></a><a href="https://qoj.ac/problem/5421">QOJ5421</a> Factories Once More</h4><p>记 $f_{x,i}$ 表示 $x$ 子树中选了 $i$ 个点的最大值，转移 $f_{x,i} &#x3D; \max(f_{x,i-j}+f_{y,j}+w j (k-j))$，注意到 $f$ 是上凸函数（上凸函数的 $(\max,+)$ 卷积仍为上凸函数）。考虑维护单调的差分数组，$(\max,+)$ 卷积为合并两个差分数组，$f_{x,i} \rightarrow f_{x,i+1}$ 即在最高点插入一个 $0$，同时还需要支持给差分数组加上等差数列，平衡树启发式合并维护。</p>
<h4 id="QOJ5423-Perfect-Matching"><a href="#QOJ5423-Perfect-Matching" class="headerlink" title="QOJ5423 Perfect Matching"></a><a href="https://qoj.ac/problem/5423">QOJ5423</a> Perfect Matching</h4><p>转化为一个二分图第 $i$ 条边连接 $a_i-i$ 与 $a_i+i$，问能否将边分成 $\frac{n}{2}$ 对使得每队边有公共点。</p>
<p>对于一个连通块 dfs，通过调整当前点到父亲的边可以使得其余连接到这个点的边均匹配，到父亲的边一定会在父亲点匹配。</p>
<h4 id="QOJ5425-Proposition-Composition"><a href="#QOJ5425-Proposition-Composition" class="headerlink" title="QOJ5425 Proposition Composition"></a><a href="https://qoj.ac/problem/5425">QOJ5425</a> Proposition Composition</h4><p>分类讨论。</p>
<ol>
<li>删其中某一条边即不连通。维护未被覆盖的边数即可。</li>
<li>其中一条边覆盖另一条。当且仅当链上的那条边只被一条边覆盖，容易维护。</li>
<li>两条边都在链上。当且仅当所有额外边要么同时覆盖要么同时不覆盖。考虑维护一个集合满足集合内任意两条边满足条件，线段树维护区间内最小前驱&#x2F;最大后继，暴力分裂，使用启发式分裂（修改分裂后较小的一个集合）维护所属集合。</li>
</ol>
<h4 id="QOJ5519-Count-Hamiltonian-Cycles"><a href="#QOJ5519-Count-Hamiltonian-Cycles" class="headerlink" title="QOJ5519 Count Hamiltonian Cycles"></a><a href="https://qoj.ac/problem/5519">QOJ5519</a> Count Hamiltonian Cycles</h4><p>尽量使前缀中两种点匹配但不能全部匹配，贪心即可。</p>
<h4 id="QOJ5523-Graph-Problem-With-Small-n"><a href="#QOJ5523-Graph-Problem-With-Small-n" class="headerlink" title="QOJ5523 Graph Problem With Small $n$"></a><a href="https://qoj.ac/problem/5523">QOJ5523</a> Graph Problem With Small $n$</h4><p>记 $f_i$ 表示以 $1$ 开头经过 $i$ 中的点的路径可能的结束点，容易转移与求答案。</p>
<h4 id="QOJ5528-Least-Annoying-Constructive-Problem"><a href="#QOJ5528-Least-Annoying-Constructive-Problem" class="headerlink" title="QOJ5528  Least Annoying Constructive Problem"></a><a href="https://qoj.ac/problem/5528">QOJ5528</a>  Least Annoying Constructive Problem</h4><p>先考虑奇数情况：把所有边分成 $n$ 组，其中第 $i$ 组为 ${(i-1,i+1),(i-2,i+2),\dots,(i-n&#x2F;2,i+n&#x2F;2)}$（所有数对 $n$ 取模）。依次输出 $1$ 到 $n$ 组中的边即可，容易证明。</p>
<p>偶数情况先去掉 $n$ 按奇数的方法分组，然后每组末尾加上 $(i,n)$，容易证明。</p>
<h4 id="QOJ6308-Magic"><a href="#QOJ6308-Magic" class="headerlink" title="QOJ6308 Magic"></a><a href="https://qoj.ac/problem/6308">QOJ6308</a> Magic</h4><p>注意到 $l,r$ 互不相同，那么对于有交但不包含的两个区间 $[l_1,r_1)$ 与 $[l_2,r_2)$（$l_1 &lt; l_2$），要使 $a_{l_1} \neq a_{l_1+1}$，显然 $[l_1,r_1)$ 需要比 $[l_2,r_2)$ 后操作，$r_2$ 同理，即 $l_1$ 与 $r_2$ 至多只能有一个满足条件。</p>
<p>转化为二分图最大独立集，使用 bitset 可以通过。</p>
<h4 id="QOJ6501-Graph-Partitioning"><a href="#QOJ6501-Graph-Partitioning" class="headerlink" title="QOJ6501 Graph Partitioning"></a><a href="https://qoj.ac/problem/6501">QOJ6501</a> Graph Partitioning</h4><p>对于一条边 $(x,y)$，在第一棵树上时 $x$ 是 $y$ 的父亲，第二棵树上时 $y$ 是 $x$ 的父亲，相当于选择第一棵树的 $x$ 或第二棵树的 $y$，每个点仅能被一条边选择。有解当且仅当每个连通块边数等于点数，即基环树，方案为 $2$。</p>
<h4 id="QOJ6837-AC-Automaton"><a href="#QOJ6837-AC-Automaton" class="headerlink" title="QOJ6837 AC Automaton"></a><a href="https://qoj.ac/problem/6837">QOJ6837</a> AC Automaton</h4><p>记 $f$ 为 $u$ 子树中某种字符的个数，$g$ 为 $u$ 祖先中某种字符的个数，答案即为 $\sum\limits_{s_u&#x3D;’A’} f_{u,{‘C’,’?’}} + \sum\limits_{s_u&#x3D;’?’} \max(f_{u,{‘C’,’?’}}-g_{u,{‘A’,’?’}},0) &#x3D; \sum\limits_{s_u&#x3D;’A’} F_u + \sum\limits_{s_u&#x3D;’?’} \max(G_u,0)$。考虑维护 $F$ 与 $\max(G,0)$。</p>
<p>对询问分块，块内在虚树上处理，容易维护。</p>
<h4 id="QOJ6842-Popcount-Words"><a href="#QOJ6842-Popcount-Words" class="headerlink" title="QOJ6842 Popcount Words"></a><a href="https://qoj.ac/problem/6842">QOJ6842</a> Popcount Words</h4><p>容易想到建立 AC 自动机后暴力跳。考虑倍增，注意到 $2|\text{popcount}(k)$ 时 $[k2^n,(k+1)2^n)$ 与 $[0,2^n)$ 相同，否则恰好相反。记 $w_{n,0&#x2F;1}$ 表示 $[0,2^n) &#x2F; [0,2^n)$ 取反，那么任意一个区间可以拆分为 $\log$ 段 $w$。</p>
<h4 id="QOJ6846-Wiring-Engineering"><a href="#QOJ6846-Wiring-Engineering" class="headerlink" title="QOJ6846 Wiring Engineering"></a><a href="https://qoj.ac/problem/6846">QOJ6846</a> Wiring Engineering</h4><p>确定 $a$ 和 $c$ 后容易 $n^2$ 转移，注意到方程与 $a,c$ 无关，可以转化为 $(a,c)$ 到 $(b+1,d+1)$ 的最长路。注意到 $n$ 较小，$q$ 较大，考虑分治，将两维中左右端点差距较大的一个分治。枚举中点 $m$ 对应的点 $i$，表示 $m$ 左边的点连接 $i$ 左边的点，$m$ 右边的点连接 $i$ 右边的点，容易处理出跨过中点的询问的答案，复杂度 $O(n^3+nq)$。</p>
<h4 id="P9061-QOJ7436-Optimal-Ordered-Problem-Solver"><a href="#P9061-QOJ7436-Optimal-Ordered-Problem-Solver" class="headerlink" title="P9061 QOJ7436 Optimal Ordered Problem Solver"></a><a href="https://www.luogu.com.cn/problem/P9061">P9061</a> <a href="https://qoj.ac/problem/7436">QOJ7436</a> Optimal Ordered Problem Solver</h4><p>考虑维护轮廓线，使用平衡树维护轮廓线上的点。轮廓线外的点的贡献是坐标与时间的三维偏序，当询问点在轮廓线外时，右上方的区域一定与轮廓线无交，那么分别求出上方、右方、右上方的点数即可，复杂度 $O(n \log n)$。</p>
<h4 id="QOJ7736-Red-Black-Tree"><a href="#QOJ7736-Red-Black-Tree" class="headerlink" title="QOJ7736 Red Black Tree"></a><a href="https://qoj.ac/problem/7736">QOJ7736</a> Red Black Tree</h4><p>记 $f_{x,i}$ 表示 $x$ 到其子树内所有叶子黑点个数均为 $i$ 的最小代价，可以证明 $f_x$ 是凸函数，因此可以维护差分数组，$(\min,+)$ 卷积只需要合并两个差分数组，当前点的贡献为插入一个 $-1$ 或 $1$，可以用两个 vector 分别维护负数和正数部分。</p>
<h4 id="QOJ7743-Grand-Finale"><a href="#QOJ7743-Grand-Finale" class="headerlink" title="QOJ7743 Grand Finale"></a><a href="https://qoj.ac/problem/7743">QOJ7743</a> Grand Finale</h4><p>考虑枚举上限和达到上限的时刻，可以直接计算出当前手上每种牌有多少，前后分开考虑。记 $f_{i,j}$ 表示未达到上限时取完前 $i$ 张牌手上有 $j$ 张 $2$，此时手上最多有多少 $1$，$g_{i,j}$ 表示达到上限后要取完 $i \sim n$ 张牌手上有 $j$ 张 $2$，此时手上最少需要多少 $1$，容易转移。</p>
<h4 id="QOJ7754-Rolling-For-Days"><a href="#QOJ7754-Rolling-For-Days" class="headerlink" title="QOJ7754 Rolling For Days"></a><a href="https://qoj.ac/problem/7754">QOJ7754</a> Rolling For Days</h4><h4 id="QOJ7905-Ticket-to-Ride"><a href="#QOJ7905-Ticket-to-Ride" class="headerlink" title="QOJ7905 Ticket to Ride"></a><a href="https://qoj.ac/problem/7905">QOJ7905</a> Ticket to Ride</h4><p>设 $f_{i,j},g_{i,j}$ 分别表示前 $i$ 条途了 $j$ 条，最后一条涂了&#x2F;没涂，$h_{i,j}$ 表示 $[i,j]$ 涂完的贡献，有 $f_{i,j} &#x3D; \max(g_{k,j-i+k}+h_{k,i})$，注意到 $i-j&#x3D;k-(j-i+k)$，即 $f$ 总是从 $i-j$ 相同的 $g$ 转移而来，用线段树维护可以做到 $O(n^2 \log)$，用并查集维护可以通过。</p>
<h4 id="QOJ8005-Crossing-the-Border"><a href="#QOJ8005-Crossing-the-Border" class="headerlink" title="QOJ8005 Crossing the Border"></a><a href="https://qoj.ac/problem/8005">QOJ8005</a> Crossing the Border</h4><p>按代价排序，设 $f_i$ 为选出 $i$ 中所有物品的最小代价，容易 $3^n$ 转移。考虑将状态改为 $f_{LR}$，$L,R$ 分别表示前一半和后一半的物品是否选择，转移枚举 $L$ 的子集 $L’$，$R$ 的超集 $R’$，考虑由 $f_{L’R}$ 转移到 $f_{LR’}$。钦定 $L’$ 不包含 $L$ 中最靠前的数，那么转移代价即可确定。要保证 $(L \oplus L’)|(R \oplus R’)$ 中总大小不超过 $w$，可以考虑 $L’$ 按大小总和从小到大排序，$R’$ 从大到小排序，双指针扫一遍即可。复杂度 $O(3^{\frac{n}{2}}2^{\frac{n}{2}})$。</p>
<h4 id="QOJ8235-Top-Cluster"><a href="#QOJ8235-Top-Cluster" class="headerlink" title="QOJ8235 Top Cluster"></a><a href="https://qoj.ac/problem/8235">QOJ8235</a> Top Cluster</h4><p>二分答案，转化为判断点权不超过 $mid$ 的点到 $x$ 的最大距离是否不超过 $k$，对于每个前缀处理出直径的两个端点即可。</p>
<h4 id="QOJ8240-Card-Game"><a href="#QOJ8240-Card-Game" class="headerlink" title="QOJ8240 Card Game"></a><a href="https://qoj.ac/problem/8240">QOJ8240</a> Card Game</h4><p>记 $f_{i,j}$ 表示区间 $[i,j]$ 的答案，$nxt_i$ 为 $i$ 之后最小的 $j$ 满足 $a_i&#x3D;a_j$，那么有</p>
<p>$$<br>f_{i,j} &#x3D;<br>\left { \begin{matrix}<br>f_{nxt_i+1,r} &amp; nxt_i \le r \<br>f_{l+1,r}+1 &amp; nxt_i &gt; r<br>\end{matrix} \right.<br>$$</p>
<p>用可持久化线段树维护 $f_{i,j}$，那么上式即为 $f_{i+1}$ 中 $&lt;nxt_i$ 的部分与 $f_{nxt_i+1}$ 中 $\ge nxt_i$ 的部分拼接起来后对前面部分区间加，容易维护。</p>
<h4 id="QOJ8330-Count-off-3"><a href="#QOJ8330-Count-off-3" class="headerlink" title="QOJ8330 Count off 3"></a><a href="https://qoj.ac/problem/8330">QOJ8330</a> Count off 3</h4><p>显然只用考虑 $1 \sim 6$ 进制，$7$ 进制限制最低位不为 $0$，容易做到 $n7^6$。注意 $k$ 进制与 $7-k$ 进制的差别：奇数位取反，偶数位不变。考虑枚举偶数位在 $1,2,3$ 进制下的和，那么奇数位的和在每种进制下都有两种不能出现。上界限制通过枚举卡上界多少位解决。</p>
<h4 id="QOJ8542-Add-One-2"><a href="#QOJ8542-Add-One-2" class="headerlink" title="QOJ8542 Add One 2"></a><a href="https://qoj.ac/problem/8542">QOJ8542</a> Add One 2</h4><p>尝试考虑将 $b$ 从最终状态减到 $0$，代价显然为 $b_i$ 的和，考虑 $b$ 的限制条件。如果 $b_i &gt; b_{i+1}$，那么至少需要在进行 $b_i-b_{i+1}$ 次 $[1,i]$ 减一的操作，反之亦然。设 $b_0&#x3D;b_{n+1}&#x3D;\inf$，那么上述条件即 $b_0 \ge \sum_{i&#x3D;0}^n \max(b_i-b_{i+1},0)$，注意到 $b_i-b_{i+1}$ 加起来等于 $0$，转为化 $\sum_{i&#x3D;0}^n |b_{i+1}-b_i| \le 2\inf$。显然只有将 $a$ 中较低的一段加一才能将总和减少 $2$，用笛卡尔树维护即可。</p>
<h4 id="QOJ8547-Whose-Land"><a href="#QOJ8547-Whose-Land" class="headerlink" title="QOJ8547 Whose Land?"></a><a href="https://qoj.ac/problem/8547">QOJ8547</a> Whose Land?</h4><p>扫描线扫 $r$，每个点 $i$ 记录 $[1,r]$ 中最大的 $j$ 使得 $i$ 与 $j$ 距离不大于 $K$，统计多少个 $j$ 大于等于 $l$ 即可。bfs 后每一层的节点都是连续的，加入一个点时只需要做 $2K+1$ 次区间赋值即可。</p>
<h4 id="QOJ8553-Exchanging-Kubic"><a href="#QOJ8553-Exchanging-Kubic" class="headerlink" title="QOJ8553 Exchanging Kubic"></a><a href="https://qoj.ac/problem/8553">QOJ8553</a> Exchanging Kubic</h4><p>首先查出每个数的正负，将相邻符号相同的合并。考虑查询相邻三项 +-+，如果结果不小于两个正数较大的就合并这三项，否则说明负数绝对值大于两个正数中较小的。考虑查询最小的正数及其左右两项 +-+-+，对前三项和后三项做上述查询，如果均未合并则表明第三个数小于两个负数的绝对值，可以合并中间三项。</p>
<h4 id="QOJ8554-Bot-Friends"><a href="#QOJ8554-Bot-Friends" class="headerlink" title="QOJ8554 Bot Friends"></a><a href="https://qoj.ac/problem/8554">QOJ8554</a> Bot Friends</h4><p>容易发现对于一段形如 <code>&gt;&gt;&gt;&lt;&lt;&lt;</code> 的序列，满足 <code>&gt;</code> 的个数与 <code>&lt;</code> 的个数相差不超过 $1$，那么可以直接删去并产生 $len-1$ 的贡献。容易 $n^2$ dp。</p>
<h4 id="QOJ8343-玩游戏"><a href="#QOJ8343-玩游戏" class="headerlink" title="QOJ8343 玩游戏"></a><a href="https://qoj.ac/problem/8343">QOJ8343</a> 玩游戏</h4><p><a href="https://www.ceoi2016.ro/wp-content/uploads/2016/08/trick-solution.pdf">题解</a></p>
<p>考虑用两张牌映射到这 $n$ 个数的和 $s$，首先将每个数减去 $s$，我们希望找到两个和为 $0$ 的牌，这样两个数的和就是 $2s$。两两匹配后共有 $n+1$ 组，显然不可行，考虑将 $(0,1,2n),(2,n,2n-1),(4,n+1,2n-3)$ 组成一组，剩下两两匹配，共 $n-1$ 组，那么至少有两个出现在同一组中。但这样会产生 $6$ 种特殊情况，考虑使用两数的差来区分，调整顺序可以得到任意特殊情况与其他情况差均不相同的方案。</p>
<h4 id="CF1768F-Wonderful-Jump"><a href="#CF1768F-Wonderful-Jump" class="headerlink" title="CF1768F Wonderful Jump"></a><a href="https://www.luogu.com.cn/problem/CF1768F">CF1768F</a> Wonderful Jump</h4><p>如果有 $a_k \le a_i,a_j$，显然 $i \rightarrow k,k \rightarrow j$ 优于 $i \rightarrow j$。即每一步转移区间最小值均在两端。</p>
<p>考虑对每个 $i$ 以 $a_i$ 为最小值向前、向后转移。注意到代价是一次跳过的长度的平方，可以考虑用上界限制转移范围，容易发现长度大于 $\frac{n}{a_i}$ 时一定劣于一步一步跳。</p>
<p>易证复杂度 $O(n \sqrt{n})$。</p>
<h4 id="CF1868D-Flower-like-Pseudotree"><a href="#CF1868D-Flower-like-Pseudotree" class="headerlink" title="CF1868D Flower-like Pseudotree"></a><a href="https://codeforces.com/contest/1868/problem/D">CF1868D</a> Flower-like Pseudotree</h4><p>分类讨论。</p>
<ol>
<li>$d_i \ge 2$ 的点有 $n$ 个。</li>
<li>$d_i \ge 2$ 的点有 $0$ 个。</li>
</ol>
<p>以上情况容易构造，剩下的情况考虑把两个 $d_i \ge 3$ 的点组成环（否则显然无解），剩余 $d_i \ge 2$ 的点分别拖两条链。$d_i \ge 2$ 的个数为奇数时需尝试把一个点往尽量浅的位置放，不能则无解。</p>
<h4 id="CF1728F-Fishermen"><a href="#CF1728F-Fishermen" class="headerlink" title="CF1728F Fishermen"></a><a href="https://www.luogu.com.cn/problem/CF1728F">CF1728F</a> Fishermen</h4><p>相当于 $i$ 和 $a_i$ 倍数连边后跑最大匹配。直接做是 $O(n^4)$ 的，假如每次成功增广后再清空标记数组可以做到 $O(n^3)$。</p>
<h4 id="UOJ883-景点观光"><a href="#UOJ883-景点观光" class="headerlink" title="UOJ883 景点观光"></a><a href="https://uoj.ac/problem/883">UOJ883</a> 景点观光</h4><p>先删掉子树内无关键点的点，猜测最终路线为以某种顺序遍历整棵树，即答案为 $2(n-1)-k$，$k$ 为最多能进行几次跳两步。</p>
<p>考虑 dp，注意到如果从上一个子树出来与进入下一个子树都是跳一步，那么可以考虑合并这两个操作。记 $f_{x,0&#x2F;1,0&#x2F;1}$ 表示遍历完 $x$ 子树（包括进入子树与离开子树），第一个操作是否为跳一步，最后一个操作是否为跳一步。$f_{x,0,1}$ 与 $f_{x,1,0}$ 等价，状态可记为 $g_{x,0&#x2F;1&#x2F;2}$。</p>
<p>假设已经知道了每个子节点的决策，可贪心地将其拼在一起。观察发现，一般钦定任意一个子节点更换决策对答案的影响不超过 $1$，那么每个子节点选 $g_{i,j}$ 较大的那一个，如有多个最大值选 $j$ 最大的。唯一一种例外是所有子节点决策均为 $0$，自身决策为 $2$ 时，特判即可。</p>
<h4 id="CF429E-Points-and-Segments"><a href="#CF429E-Points-and-Segments" class="headerlink" title="CF429E Points and Segments"></a><a href="https://www.luogu.com.cn/problem/CF429E">CF429E</a> Points and Segments</h4><p>容易想到将染色变为对边定向，即删去覆盖次数为偶数的边后每个连通块跑欧拉回路。</p>
<h4 id="CF1973F-Maximum-GCD-Sum-Queries"><a href="#CF1973F-Maximum-GCD-Sum-Queries" class="headerlink" title="CF1973F Maximum GCD Sum Queries"></a><a href="https://codeforces.com/contest/1973/problem/F">CF1973F</a> Maximum GCD Sum Queries</h4><p>钦定不交换 $a_1,b_1$，那么两个序列 $\gcd$ 分别是 $a_1,b_1$ 的因数，注意到 $10^8$ 内一个数的因数个数最大不超过 $1000$，考虑以 $(\gcd_1,\gcd_2)$ 为状态。</p>
<p>记 $f_{p_1,p_2}$ 表示最终结果为 $(p_1,p_2)$ 时 $[2,n]$ 中可以满足的 $i$ 的个数（即 $a_i,b_i$ 分别是 $p_1,p_2$ 或 $p_2,p_1$ 的倍数），考虑通过类似高位前缀和的方式转移，只需要在 $f_{\gcd(a_1,a_i),\gcd(b_1,b_i)}$ 与 $f_{\gcd(a_1,b_i),\gcd(b_1,a_i)}$ 处分别 $+1$，在这两个的 $\gcd$ 处 $-1$ 避免重复即可。如果 $f_{i,j} &#x3D; n-1$ 则表示 $(i,j)$ 合法，而代价可以用相同的方式转移。</p>
<h4 id="QOJ5034"><a href="#QOJ5034" class="headerlink" title="QOJ5034 &gt;.&lt;"></a><a href="https://qoj.ac/problem/5034">QOJ5034</a> &gt;.&lt;</h4><p>考虑将 $k$ 条路径和 $n$ 个单点建 AC 自动机，标记每条路径的结尾点不能走，答案即为 $1$ 到 $n$ 的最短路。一个点可能在 AC 自动机上出现很多次，直接做是 $O(n^2)$ 的。由于出边是继承自 fail 的，只有在当前点存在该儿子时被修改，所以会存在大量的点的某一个出边指向同一个点，并且这些边对应原图中的同一条边，在跑 dij 时显然只用更新一次。考虑可持久化，每个点继承 fail 的线段树，然后将当前点存在的儿子在线段树上新建节点，跑最短路时每次访问过的点直接删除。注意 $1 \sim n$ 单点的每个儿子需单独建点，以区分不同的边。</p>
<h4 id="QOJ5015-树"><a href="#QOJ5015-树" class="headerlink" title="QOJ5015 树"></a><a href="https://qoj.ac/problem/5015">QOJ5015</a> 树</h4><p>容易想到确定一个根后分层，相邻两层确定连边。假设要确定 $A$ 到 $B$ 的连边，注意到 $B$ 中一点到 $P \subseteq A$ 的距离等于其父亲到 $P$ 的距离加 $|P|$，考虑随机平分 $A$ 得到 $P$ 后分治，可以证明 $P$ 是 $A$ 中任意一个等价类大小不超过 $\frac{|A|}{2}$，并且由于随机无法卡满。</p>
<h4 id="QOJ5016-Range-Minimum-Element"><a href="#QOJ5016-Range-Minimum-Element" class="headerlink" title="QOJ5016 Range Minimum Element"></a><a href="https://qoj.ac/problem/5016">QOJ5016</a> Range Minimum Element</h4><p>称 $a$ 最终得到的 $b$ 为 $F(a)$。考虑以下过程：对于一个数组 $b$，从小到大枚举 $x$，对于所有 $b_i &gt; x$ 有 $a_{l_i \sim r_i} &gt; x$，将 $a$ 中没有被限制且没有被填的位置填入 $x$，最终得到的 $a$ 记为 $G(b)$。显然有 $F(G(b))&#x3D;b$，即 $b$ 和 $G(b)$ 一一对应，考虑统计合法的 $G(b)$ 的个数。</p>
<p>记 $f_{i,j,k}$ 表示 $[i,j]$ 中填入 $[c-k+1,c]$ 合法的方案，转移枚举 $l$ 为第一个 $k$ 的位置，有 $f_{i,j,k} \leftarrow f_{i,l-1,k-1} f_{l+1,j,k}$，显然 $[i,l-1]$ 需合法。整个区间合法时再加上不填 $k$ 的方案。$f_{1,n,c}$ 即为答案。注意到 $f$ 为关于 $c$ 的 $n$ 次多项式，求出 $c \in [0,n]$ 的答案后拉插即可。</p>
<h4 id="CF1967D-Long-Way-to-be-Non-decreasing"><a href="#CF1967D-Long-Way-to-be-Non-decreasing" class="headerlink" title="CF1967D Long Way to be Non-decreasing"></a><a href="https://codeforces.com/contest/1967/problem/D">CF1967D</a> Long Way to be Non-decreasing</h4><p>二分答案，从前往后每个数选择基环树上 $mid$ 步能到达的点中最小的点，双指针扫描即可。</p>
<h4 id="CF1967E2-Again-Counting-Arrays-Hard-Version"><a href="#CF1967E2-Again-Counting-Arrays-Hard-Version" class="headerlink" title="CF1967E2 Again Counting Arrays (Hard Version)"></a><a href="https://codeforces.com/contest/1967/problem/E2">CF1967E2</a> Again Counting Arrays (Hard Version)</h4><p>考虑对于一个确定的 $a$ 如何构造 $b$，容易发现能 $+1$ 就 $+1$ 是不劣的，不难证明。转化为统计路径，每一步向右移动一格，向上或向下移动一格。可以直接反射容斥，注意可能终点不在 $[0,m]$ 之间，容斥时钦定经过一次上边界即可。</p>
<h4 id="QOJ5019-整数"><a href="#QOJ5019-整数" class="headerlink" title="QOJ5019 整数"></a><a href="https://qoj.ac/contest/1033/problem/5019">QOJ5019</a> 整数</h4><p>从高位到低位做，记 $f_i$ 表示第 $j$ 个数是否贴上限的答案，容易 $3^n$ 转移。考虑使用 FWT 优化，$f_i$ 中 $i$ 的第 $j$ 位为 $0&#x2F;1$ 表示不贴上限&#x2F;贴上限，$g_i$ 中 $i$ 的第 $j$ 位表示第 $j$ 个数的当前位，根据 $R_i$ 当前位的不同有两种转移：</p>
<ul>
<li>$R_i$ 当前位为 $0$：$f_0 (g_0+g_1) \rightarrow f_0, f_1 g_0 \rightarrow f_1$。</li>
<li>$R_i$ 当前位为 $1$：$f_0 (g_0+g_1) + f_1 g_0 \rightarrow f_0, f_1 g_1 \rightarrow f_1$。</li>
</ul>
<p>对于第一个转移，设 $h_0&#x3D;g_0+g_1,h_1&#x3D;g_0$，那么转移即为 $f_i &#x3D; f_ih_i$。</p>
<p>对于第二个转移，显然是按位与卷积，使用 FWT 解决。</p>
<p>将两种转移合在一起，FWT 时仅操作 $R_i$ 当前位为 $1$ 的位即可。</p>
<h4 id="CF1975F-Set"><a href="#CF1975F-Set" class="headerlink" title="CF1975F Set"></a><a href="https://codeforces.com/contest/1975/problem/F">CF1975F</a> Set</h4><p>枚举 $S$ 每一位，显然当枚举到第 $i$ 位时，剩下的 $T$ 只剩 $2^{n-x}$ 种，枚举 $T$ 并更新即可。</p>
<h4 id="CF1943D2-Counting-Is-Fun-Hard-Version"><a href="#CF1943D2-Counting-Is-Fun-Hard-Version" class="headerlink" title="CF1943D2 Counting Is Fun (Hard Version)"></a><a href="https://codeforces.com/contest/1943/problem/D2">CF1943D2</a> Counting Is Fun (Hard Version)</h4><p>不难发现，合法当且仅当 $a_i \le a_{i-1}+a_{i+1}$。容斥，钦定多少个 $i$ 不满足，dp 即可。</p>
<h4 id="CF1943E2-MEX-Game-2-Hard-Version"><a href="#CF1943E2-MEX-Game-2-Hard-Version" class="headerlink" title="CF1943E2 MEX Game 2 (Hard Version)"></a><a href="https://codeforces.com/contest/1943/problem/E2">CF1943E2</a> MEX Game 2 (Hard Version)</h4><p>二分答案，设 $f_i$ 为 $i$ 的个数，显然 Alice 的策略为每次取 $f$ 最小的一个。枚举 Bob 最后要删空的数 $x$，由于 Alice 总是取当前最少的数，所以比 $x$ 多的数显然不用管，而 Bob 需要保证 $x$ 始终是剩余数中最大的，那么其策略即为每次将一个后缀减少到“几乎相等”（即极差不超过 $1$）。我们可以找到所有数“几乎相等”的时刻，可以通过二分解决。此后的情况容易处理。</p>
<h4 id="CF1943F-Minimum-Hamming-Distance"><a href="#CF1943F-Minimum-Hamming-Distance" class="headerlink" title="CF1943F Minimum Hamming Distance"></a><a href="https://codeforces.com/contest/1943/problem/F">CF1943F</a> Minimum Hamming Distance</h4><p>钦定 $t$ 中 $0$ 为众数，否则翻转 $s,t$ 即可。对于 $s_i&#x3D;0$，显然有 $[1,n]$ 满足条件。设一个区间的权值为 $1$ 减 $0$ 的个数，对于 $s_i&#x3D;1$，满足条件当且仅当一个包含 $i$ 的区间权值大于等于 $0$，显然 $i$ 为这个区间的端点之一。记 $f_{i,j}$ 表示枚举到前 $i$ 个数，$[1,i]$ 后缀最大权值为 $j$，第一种容易转移，第二种枚举右端点，显然翻转 $0$ 需尽量靠后，容易转移。</p>
<h4 id="CF1948F-Rare-Coins"><a href="#CF1948F-Rare-Coins" class="headerlink" title="CF1948F Rare Coins"></a><a href="https://codeforces.com/contest/1948/problem/F">CF1948F</a> Rare Coins</h4><p>转化为 $x$ 个银币比 $y$ 个银币价值多 $k$ 的方案数，为 $\sum\limits_d \sum\limits_i \binom{x}{d+i} \binom{y}{i} &#x3D; \sum\limits_d \binom{x+y}{y+d}$，注意到 $x+y$ 为总共银币数量不会改变，预处理即可。</p>
<h4 id="CF1936D-Bitwise-Paradox"><a href="#CF1936D-Bitwise-Paradox" class="headerlink" title="CF1936D Bitwise Paradox"></a><a href="https://codeforces.com/contest/1936/problem/D">CF1936D</a> Bitwise Paradox</h4><p>注意到 $v$ 是固定的，考虑线段树上维护前后缀每个 $b$ 的或和对应的 $a$ 的最大值，显然前后缀不同的或分别只有 $\log$ 种，容易维护。</p>
<h4 id="CF838F-Expected-Earnings"><a href="#CF838F-Expected-Earnings" class="headerlink" title="CF838F Expected Earnings"></a><a href="https://codeforces.com/contest/838/problem/F">CF838F</a> Expected Earnings</h4><p>记 $f_{i,j},g_{i,j}$ 分别表示取了 $i$ 个球其中 $j$ 个红球后最大期望收益和下一个是红球的概率，有转移：$f_{i,j} &#x3D; \max((f_{i+1,j+1}+1)g_{i,j}+f_{i+1,j}(1-g_{i,j}),0)$。考虑求 $g_{i,j}$，记 $h_{i,j}$ 为取 $i$ 个球其中 $j$ 个红球的概率，容易发现有 $g_{i,j} &#x3D; \frac{h_{i+1,j+1}}{h_{i,j}} \times \frac{j+1}{i+1}$，$h_{i,j} &#x3D; \frac{j+1}{i+1} h_{i+1,j+1} + \frac{i+1-j}{i+1} h_{i+1,j}$。</p>
<h4 id="CF1060G-Balls-and-Pockets"><a href="#CF1060G-Balls-and-Pockets" class="headerlink" title="CF1060G Balls and Pockets"></a><a href="https://www.luogu.com.cn/problem/CF1060G">CF1060G</a> Balls and Pockets</h4><p>首先删除 $a_1$ 之前的数。对于一个极大的数 $x$，显然 $x+n$ 操作一次后会移动到 $x$，即 $x$ 与 $x+n$ 在同一个 $a_i$ 处被删除，容易得到 $[x,x+n-1]$ 被最终删除的位置互不相同，考虑维护这么一个长为 $n$ 的区间。假如当前区间覆盖到了 $w$ 个 $a$，那么把这些位置从区间中删去，剩下的位置向前移动，不难发现得到的区间恰好与当前区间相邻，长度减少 $w$。那么对于一个位于第 $i$ 个区间数 $j$ 的询问，其答案即为第 $i-k$ 个区间数 $j$ 位置对应的数。</p>
<h4 id="CF1930E-2-3…4…-Wonderful-Wonderful"><a href="#CF1930E-2-3…4…-Wonderful-Wonderful" class="headerlink" title="CF1930E 2..3…4…. Wonderful! Wonderful!"></a><a href="https://codeforces.com/contest/1930/problem/E">CF1930E</a> 2..3…4…. Wonderful! Wonderful!</h4><p>显然删去的数个数必须是 $2k$ 的倍数，可以对于每个 $k$ 直接枚举。显然任意一个保留的数左右两侧至少有 $k$ 个删除的数，那么合法的必要条件为前 $k$ 个和后 $k$ 个被删除，可以证明这是充分的，容易组合数计算。</p>
<h4 id="CF1930F-Maximize-the-Difference0"><a href="#CF1930F-Maximize-the-Difference0" class="headerlink" title="CF1930F Maximize the Difference0"></a><a href="https://codeforces.com/contest/1930/problem/F">CF1930F</a> Maximize the Difference0</h4><p>从高到低位做，显然每次尽量让较大的数当前位为 $1$，较小的数当前位为 $0$ 最优，即查询是否存在 $a_i$ 是 $x$ 的子集、超集，由于只查询是否存在，每次暴力 dfs，当前数已存在就退出即可。</p>
<h4 id="CF1930G-Prefix-Max-Set-Counting"><a href="#CF1930G-Prefix-Max-Set-Counting" class="headerlink" title="CF1930G Prefix Max Set Counting"></a><a href="https://codeforces.com/contest/1930/problem/G">CF1930G</a> Prefix Max Set Counting</h4><p>将一个点儿子按子树内最大编号排序，显然一个子树内的点不会受到其后子树内点的影响，以这个顺序 dfs，那么一个点只可能受到 dfs 序小于自己且编号小于自己的点的贡献。</p>
<p>令 $f_x$ 表示 $x$ 结尾且为前缀最大值的方案，$g_x$ 为 $x$ 子树内最大点，dfs 到点 $x$ 时，依次遍历其儿子 $i$ 并将 $f_i$ 贡献到树状数组上的位置 $g_i$，遍历完成后移除贡献。计算 $f_x$ 时注意其祖先都是必选的，显然转移点不能小于其祖先最大值。</p>
<h4 id="CF1930H-Interactive-Mex-Tree"><a href="#CF1930H-Interactive-Mex-Tree" class="headerlink" title="CF1930H Interactive Mex Tree"></a><a href="https://codeforces.com/contest/1930/problem/H">CF1930H</a> Interactive Mex Tree</h4><p>转化为查询路径外点的 $min$。按照 dfs 时进栈的顺序和出栈的顺序，可以将一条路径外的所有点划分成五个区间。</p>
<h4 id="QOJ4805-Grammy-Sorting"><a href="#QOJ4805-Grammy-Sorting" class="headerlink" title="QOJ4805 Grammy Sorting"></a><a href="https://qoj.ac/problem/4805">QOJ4805</a> Grammy Sorting</h4><p><a href="https://www.cnblogs.com/YunQianQwQ/p/18164910">题解</a> <a href="https://www.cnblogs.com/yyyyxh/p/ear_decoposition_bipolar_orientation.html">双极定向</a></p>
<p>考虑维护一个合法的子图然后依次加入点，构造双极定向，按照拓扑序倒着考虑每个点。现在有一个包含 $B$ 的子图 $G$，$G$ 内每个点到 $B$ 的路径权值递增，考虑加入一个点 $x$，找到 $x$ 权值最小的后继 $v$：</p>
<ul>
<li>当 $p_A &lt; p_v$ 时，操作 $A$ 到 $x$ 的路径。</li>
<li>当 $p_A &gt; p_v$ 时，将 $v$ 加入操作路径，并找到 $v$ 的最小后继作为新的 $v$。重复以上步骤直到 $p_A &lt; p_v$ 或者 $v &#x3D; B$，操作后新的子图显然合法。</li>
</ul>
<h4 id="QOJ5022-【模板】线段树"><a href="#QOJ5022-【模板】线段树" class="headerlink" title="QOJ5022 【模板】线段树"></a><a href="https://qoj.ac/problem/5022">QOJ5022</a> 【模板】线段树</h4><p>可以转化为 $n \times m$ 的网格，每个格子向上连边，第 $i-1$ 行 $[l_i,r_i-1]$ 的格子向右上方连边。考虑在 $m$ 这一维上分块，对于每一块，将块内出现的每个 $l,r,pos$ 设为关键点，考虑每一段内的转移，显然未出现斜向边的行是无用的，容易处理。</p>
<p>现在知道一个 $w \times h$ 左侧和下侧所有点的答案，要求上侧和右侧所有点的答案，分类讨论：</p>
<ul>
<li>$(s,0) \rightarrow (w,t): \binom{t}{w-s}$</li>
<li>$(s,0) \rightarrow (t,h): \binom{h}{t-s}$</li>
<li>$(0,s) \rightarrow (t,h): \binom{h-s}{t}$</li>
<li>$(0,s) \rightarrow (w,t): \binom{t-s}{w}$</li>
</ul>
<p>显然对于方案为奇数的转移才有效，而 $\binom{n}{m} \equiv 1 \bmod 2$ 当且仅当 $n \ \text{and} \ m&#x3D;m$，上面四种均可在 $\max(h,w) \log$ 的时间解决。总复杂度 $O(n\sqrt{n}\log n)$。</p>
<h4 id="QOJ5029-在路上"><a href="#QOJ5029-在路上" class="headerlink" title="QOJ5029 在路上"></a><a href="https://qoj.ac/problem/5029">QOJ5029</a> 在路上</h4><p>考虑链的情况，考虑 nth_element，需要快速判断两个数在链上的位置关系。容易想到询问这两个点与链的一个左端点，得到的点即较左的那一个。找端点只需要三个数不断舍弃中间那个即可。</p>
<p>考虑树的情况，注意到重心每个子树大小不超过 $\frac{n}{2}$，也就是随机一对点在重心同一子树内的概率不超过一半，那么随机一对点并假设重心在这条链上，期望 $2$ 次得到答案。</p>
<p>考虑随机链上一个点并取其大小超过 $\frac{n}{2}$ 的儿子，不存在此点即为重心。但是相较于链上的情况这种情况每个点带点权，在链上均匀随机复杂度退化到 $O(n \log n)$，考虑带权随机，注意到随机 $1 \sim n$ 的一个点后找到其在链上的祖先等价于带权随机链上一点。找到 $x$ 的链上祖先只需要遍历链上的点不断令 $fa&#x3D;ask(x,fa,i)$，其中 $fa$ 为当前答案，$i$ 为枚举的链上的点。考虑如何找到一个点 $x$ 大小大于 $\frac{n}{2}$ 的儿子或判断不存在，通过 $ask(x,u,v)$ 可以判断 $u$ 和 $v$ 是否在同一子树内，考虑用摩尔投票求出绝对众数即可。</p>
<h4 id="QOJ5013-Astral-Birth"><a href="#QOJ5013-Astral-Birth" class="headerlink" title="QOJ5013 Astral Birth"></a><a href="https://qoj.ac/problem/5013">QOJ5013</a> Astral Birth</h4><p>钦定划分出的一段可以为空，容易发现一个连续段总是不会被划分成两个部分，将整个序列缩为 $01$ 交替的序列。考虑共 $k$ 个连续段的序列最少需要分多少段可以变得有序，注意到当存在一个 $0$ 在 $1$ 前面时这两个段可以划为一段，总共 $k-1$ 段，否则至少 $k$ 段，注意到 $k \ge 3$ 时一定可以达到 $k-1$，剩下情况特殊考虑。</p>
<p>现在需要选一些连续段使得拼起来后连续段个数不超过 $m$，选出来的最大长度和贡献到 $\max(m-1,2)$ 的答案。容易发现删掉相邻两个连续段一定劣于删掉其中一个，即删掉的连续段不相邻。在不相邻的情况下删掉中间的会使连续段个数减少 $2$，删掉两侧的减少 $1$。由于要求不相邻，那么两侧分别最多删一个区间，每一种情况做一遍后面的过程即可。而中间的情况容易用反悔贪心解决，每次选最短的连续段 $i$，删除 $i,l_i,r_i$ 并将 $a_{l_i}+a_{r_i}-a_i$ 作为新的连续段加入。</p>
<h4 id="CF1909I-Short-Permutation-Problem"><a href="#CF1909I-Short-Permutation-Problem" class="headerlink" title="CF1909I Short Permutation Problem"></a><a href="https://www.luogu.com.cn/problem/CF1909I">CF1909I</a> Short Permutation Problem</h4><p>枚举 $m$，当 $m$ 为偶数时，将 $\geq \frac{m}{2}$ 的成为大数，其余为小数，将 $1 \sim n$ 排成形如 $\frac{m}{2},\frac{m}{2}-1,\frac{m}{2},\frac{m}{2}-2,\cdots,1,m,\cdots,n$ 的序列，依次插入，容易发现每次插入大数后这个数和其左右的数形成的数对都满足条件，小数反之。考虑 dp，记 $f_{i,j}$ 表示前 $i$ 个数有 $j$ 对满足条件，容易转移。$m$ 为奇数同理。</p>
<p>容易发现对于不同的 $m$ 均由一段大小数交替和一段大数构成，前面可以直接在 $f$ 上查询，考虑后面部分的贡献。设已经放了前面部分共 $p$ 个数，共 $q$ 对合法，后面部分共 $k$ 个数。每个数插入到一对合法数对中间或开头结尾会产生 $1$ 的贡献，否则产生 $2$ 的贡献，枚举 $i$ 表示产生 $2$ 的贡献的个数，有 $ans_{q+k+i} \leftarrow k! f_{p,q} \binom{p-q-1}{i} \binom{k+q+1}{k-i}$，拆开整理得到 $ans_{q+k+i}(p-1-(q+i))!((q+i)+1)! \leftarrow k! \frac{f_{p,q}(p-q-1)!(k+q+1)!}{i!(k-i)!}$，发现为 $P \leftarrow k! \frac{Q}{I}$，其中 $p,k$ 固定，$P$ 仅与 $q+i$ 有关，$Q$ 仅与 $q$ 有关，$I$ 仅与 $i$ 有关，为加法卷积的形式，NTT 即可。</p>
<h4 id="CF1924E-Paper-Cutting-Again"><a href="#CF1924E-Paper-Cutting-Again" class="headerlink" title="CF1924E Paper Cutting Again"></a><a href="https://www.luogu.com.cn/problem/CF1924E">CF1924E</a> Paper Cutting Again</h4><p>考虑把每条线在结束前被选中的概率加起来。枚举切的哪条线，假设是 $x&#x3D;i$，那么只需要这条线在 $x &#x3D; 1 \sim i-1$ 和 $y &#x3D; 1 \sim \lfloor \frac{k}{i} \rfloor$ 之前被选即可。</p>
<h4 id="CF1924F-Anti-Proxy-Attendance"><a href="#CF1924F-Anti-Proxy-Attendance" class="headerlink" title="CF1924F Anti-Proxy Attendance"></a><a href="https://www.luogu.com.cn/problem/CF1924F">CF1924F</a> Anti-Proxy Attendance</h4><p>容易想到在三部分中排除一部分，假设回复无人缺席为 $0$，有人缺席为 $1$，分类讨论，发现无法在三次询问内排除一部分，但四次询问会超出限制。注意到四次询问的情况一定不会排除中间的部分，那么将中间部分取小一点即可，dp 或者按比例分。</p>
<h4 id="CF1889D-Game-of-Stacks"><a href="#CF1889D-Game-of-Stacks" class="headerlink" title="CF1889D Game of Stacks"></a><a href="https://www.luogu.com.cn/problem/CF1889D">CF1889D</a> Game of Stacks</h4><p>每个点向栈顶连边，会形成一棵内向基环树，注意到不管任意时刻走进这个环，一定会绕着环走一圈并回到起始点，相当于把所有在环上的点弹栈，新形成的图仍然是基环树，所以只需要不断删掉环直到不存在环，每棵树的根节点即为答案。</p>
<h4 id="CF1817F-Entangled-Substrings"><a href="#CF1817F-Entangled-Substrings" class="headerlink" title="CF1817F Entangled Substrings"></a><a href="https://www.luogu.com.cn/problem/CF1817F">CF1817F</a> Entangled Substrings</h4><p>显然 $ac$ 和 $b$ 出现位置的差分数组是相同的，一个字符串 $S$ 的子串的出现位置集合只有 $O(n)$ 种，使用 SA 或 SAM 求出每种出现位置的集合，用哈希将差分数组相同分在一组。对于每一组，出现位置集合相同的字符串显然由若干个 $x_i$ 开头长度为 $[l_i,r_i]$ 的字符串组成。考虑两种字符串 $i,j(x_i &lt; x_j)$ 的贡献：由于两个字符串要恰好拼接在一起，所以必须满足 $x_j - x_i \in [l_i,r_i]$，方案为 $(r_j-l_j+1)(x_j-x_i-l_i+1)$，排序后二分即可。</p>
<h4 id="UOJ577-打击复读"><a href="#UOJ577-打击复读" class="headerlink" title="UOJ577 打击复读"></a><a href="https://uoj.ac/problem/577">UOJ577</a> 打击复读</h4><p>建 SAM，令 $[l_x,r_x]$ 表示 SAM 上 $x$ 节点的最小、最大长度，那么节点 $x$ 的贡献为：</p>
<p>$$<br>|endpos_x| \left(\sum\limits_{i \in endpos_x} wr_i \right) \left(\sum\limits_{i \in endpos_x} \sum\limits_{j&#x3D;l_x}^{r_x} wl_{i-j+1} \right)<br>$$</p>
<p>后面部分用后缀和拆开，那么现在要求 $\sum\limits_{i \in endpos_x} wl’_{i-p+1}$ 其中 $p&#x3D;l_x-1,r_x$，$p&#x3D;r_x$ 时上式等于字符串 $[i-r_x+1,i]$ 左权值和，$p&#x3D;l_x-1$ 时长度为 $l_x-1$ 的字符串的 $endpos$ 与 $endpos_x$ 不同，用字符串 $[i-l_x+1,i]$ 的左端点前一个点的权值之和即可。倍增找到一个字符串对应的节点。由于只会修改 $wl$，考虑将整个字符串翻转变为修改 $wr$，注意到修改一个 $wr$ 仅会影响对应节点到根的一条链，容易统计答案的变化量。</p>
<h4 id="CF1919G-Tree-LGM"><a href="#CF1919G-Tree-LGM" class="headerlink" title="CF1919G Tree LGM"></a><a href="https://codeforces.com/contest/1919/problem/G">CF1919G</a> Tree LGM</h4><p>考虑根不同有什么影响，相当于在转移时移除了根所在的子树。可以发现当 $s_{x,x}&#x3D;0$ 表示对于 $x$ 的所有儿子 $i$ 有 $s_{x,i}&#x3D;1$，此时显然有 $s_{1 \sim n,x}&#x3D;0$。否则表示存在一个 $i$ 使得 $s_{x,i}&#x3D;0$，如果这样的 $i$ 超过两个，那么移除任意子树都没有影响，即 $s_{1 \sim n,x}&#x3D;1$。</p>
<p>否则按照 $s_{i,x}&#x3D;0&#x2F;1$ 分成两个集合 $S,T$，显然 $T$ 是 $x$ 的一棵子树，考虑找出这个子树内与 $x$ 相连的点 $y$，首先由 $s_{y,x}&#x3D;0$ 可以推出 $s_{i,y}&#x3D;1,i \in T$，即 $y$ 出发总是可以到达必败点 $x$，可以证明此条件是充要的。</p>
<p>找到 $y$ 后还需验证合法性才可分治求解，对于一对 $i \in S,j \in T(i \neq x,j \neq y)$，有 $s_{i,j}&#x3D;s_{y,j},s_{j,i}&#x3D;s_{j,v}$。</p>
<p>当找不到满足上述条件的 $x$ 时，即对于任意一个 $x$ 删除任意子树均不会影响答案，即任意 $i$ 满足 $s_{i,x} &#x3D; s_{x,x}$，按 $s_{x,x} &#x3D; 0&#x2F;1$ 分成两种点，显然每个 $1$ 类点至少连接两个 $0$ 类点，最优方案为一条左右为 $0$，$0,1$ 交错的链，$0$ 多了直接连到 $1$ 上，$1$ 多了无解。</p>
<h4 id="CF1919H-Tree-Diameter"><a href="#CF1919H-Tree-Diameter" class="headerlink" title="CF1919H Tree Diameter"></a><a href="https://www.luogu.com.cn/problem/CF1919H">CF1919H</a> Tree Diameter</h4><p>钦定 $1$ 为根，先用操作 $2$ 分层，对于每一层尝试求出与上一层的连边。假设 $1$ 是叶子，那么将 $t-1$ 层第 $i$ 条边权值设为 $i$，当前层的边 $x$ 和根设为 $10^9$，其余边设为 $10^5$，那么直径一定经过跟和 $x$，将直径对 $10^5$ 取模即可知道经过 $t-1$ 层的边的权值。</p>
<p>当 $1$ 不是叶子时，考虑对于第 $t$ 层考虑将 $t-1$ 层第 $i$ 条边权值设为 $i$，当前层两条边 $x,y$ 设为 $10^9$，那么直径一定经过 $x,y$，可以知道经过 $t-1$ 层两条边的权值和。将 $t$ 层每条边 $i$ 和第 $1$ 条边（设为 $o$）做上述过程得到 $f_i$（如果 $o$ 和 $i$ 父亲相同则为 $0$），显然两个数 $f$ 相同表示其父亲相同。我们钦定前 $t-1$ 层任意一个节点均有至少一个儿子，否则即找到一个叶子，用先前做法即可。分类讨论：</p>
<ul>
<li>不同的 $f$ 个数 $\geq 3$。此时只需要任意找两条边 $x,y$ 使得 $o,x,y$ 三条边父亲均不相同，查询 $x,y$，即可知道 $o$ 的父亲。</li>
<li>不同的 $f$ 个数 $&#x3D;1$。<ul>
<li>$t-1$ 层点数为 $1$。直接连即可</li>
<li>$t-1$ 层点数为 $2$。此时图一定是一条链，任意连边均同构，并且一定产生了一个叶子。</li>
<li>$t-1$ 层点数大于等于 $3$。将 $o$ 和 $t-1$ 层任意三条边依次设为 $10^9$ 查询三次，得到的众数一定是 $o$ 的父亲，并且一定产生一个叶子。</li>
</ul>
</li>
<li>不同的 $f$ 个数为 $2$。<ul>
<li>$t-1$ 层点数为 $2$。此时图一定是一条链，任意连均同构。</li>
<li>$t-1$ 层点数大于等于 $3$。将 $o$、$t$ 层另一点 $x$ 与 $t-1$ 层一点 $p$ 设为 $10^9$，如果结果超过 $3 \times 10^9$，那么经过的边 $z$ 与 $p$ 一定分别是 $o,x$ 的父亲，$t-1$ 层任意非 $z,p$ 的点均为叶子，否则 $p$ 为叶子。确定根后再用一次操作确定 $o,p$ 父亲即可。</li>
</ul>
</li>
</ul>
<h4 id="CF1842H-Tenzing-and-Random-Real-Numbers"><a href="#CF1842H-Tenzing-and-Random-Real-Numbers" class="headerlink" title="CF1842H Tenzing and Random Real Numbers"></a><a href="https://www.luogu.com.cn/problem/CF1842H">CF1842H</a> Tenzing and Random Real Numbers</h4><p>考虑将 $1$ 消掉，每个 $x$ 在 $[-0.5,0.5]$ 中均匀随机，条件变为 $x_i + x_j \leq 0$ 和 $x_i + x_j \geq 0$。显然 $x_i+x_j$ 的正反由绝对值较大的一个数的正负决定，考虑按绝对值从小到大将 $x$ 加入集合，第一种条件可以转换为当 $x_i \geq 0$ 一定有 $|x_j| \geq |x_i|$，也就是 $j$ 在 $i$ 后加入集合，第二种同理，容易 $2^n n$ dp。</p>
<h4 id="CF1984E-Shuffle"><a href="#CF1984E-Shuffle" class="headerlink" title="CF1984E Shuffle"></a><a href="https://codeforces.com/contest/1984/problem/E">CF1984E</a> Shuffle</h4><p>先忽略根为叶子的情况，考虑相邻两个点，显然其中一个是另一个的祖先，即两个相邻的点最多有一个叶子。考虑找到最大独立集，容易构造叶子集合为最大独立集的方案，即答案为最大独立集。当根为叶子时，答案为根删去后最大独立集 $+1$，换根 dp 即可。</p>
<h4 id="CF1984F-Reconstruction"><a href="#CF1984F-Reconstruction" class="headerlink" title="CF1984F Reconstruction"></a><a href="https://codeforces.com/contest/1984/problem/F">CF1984F</a> Reconstruction</h4><p>钦定 $s_0&#x3D;\text{P},s_{n+1}&#x3D;\text{S},b_0&#x3D;b_{n+1}&#x3D;0$，设 $k&#x3D;\sum a_i$，大胆猜测，合法当且仅当满足：</p>
<ul>
<li>对于 $s_i&#x3D;\text{P}$，有 $\text{abs}(b_i) \le i \times m$，对于 $s_i&#x3D;\text{S}$，有 $\text{abs}(b_i) \le (n-i+1) \times m$。</li>
<li>对于 $s_i&#x3D;s_{i+1}$，有 $\text{abs}(b_i-b_{i+1}) \le m$。</li>
<li>对于 $s_i&#x3D;\text{P},s_{i+1}&#x3D;\text{S}$，有 $b_i+b_{i+1} &#x3D; k$。</li>
<li>对于 $s_i&#x3D;\text{S},s_{i+1}&#x3D;\text{P}$，有 $\text{abs}(b_i+b_{i+1}-k) \le 2m$。</li>
</ul>
<p>容易证明以上条件是充分的。注意到一定存在 $i$ 使得 $s_i&#x3D;\text{P},s_{i+1}&#x3D;\text{S}$，那么枚举 $k &#x3D; b_i+b_{i+1}$ 即可。</p>
<h4 id="CF1984G-Magic-Trick-II"><a href="#CF1984G-Magic-Trick-II" class="headerlink" title="CF1984G Magic Trick II"></a><a href="https://codeforces.com/contest/1984/problem/G">CF1984G</a> Magic Trick II</h4><p>猜测 $k$ 为 $n$ 减一个常数，容易发现当 $k&#x3D;n$ 时，$a$ 必然有序，$k&#x3D;n-1$ 时，$a$ 为 $1,2, \cdots ,n$ 的循环位移。</p>
<p>考虑 $k&#x3D;n-2$ 的情况，考虑将 $a$ 拼成一个环，并记录分界点。那么任意操作等价于以下两种之一：</p>
<ol>
<li>将分界点左移&#x2F;右移 $2$ 格。</li>
<li>交换分界点左右两侧的数并将分界点左移&#x2F;右移 $1$ 格。</li>
</ol>
<p>容易想到枚举 $i &#x3D; n \sim 1$，通过 $1$ 操作移动到 $i$ 右侧再通过 $2$ 操作将 $i$ 归位，当 $n$ 为奇数时成立，$n$ 为偶数时可能出现无法通过 $1$ 操作移动到 $i$ 右侧。注意到 $n$ 为偶数时每次操作 $n-2$ 个数不会改变逆序对奇偶性，因此分情况考虑：</p>
<ol>
<li>当逆序对个数为偶数时，按奇数情况做。当出现分界线位置与 $i$ 位置奇偶性不同时，先移动到 $i$ 左侧，将 $i$ 移动到 $1$，然后交换 $a_2,a_3$ 来改变分界线奇偶，可以证明逆序对个数为偶数时是可行的。</li>
<li>当逆序对个数为奇数时，考虑 $k&#x3D;n-3$，将 $n$ 移到末尾后解决 $n-1$ 的子问题即可。</li>
</ol>
<h4 id="CF1874E-Jellyfish-and-Hack"><a href="#CF1874E-Jellyfish-and-Hack" class="headerlink" title="CF1874E Jellyfish and Hack"></a><a href="https://codeforces.com/contest/1874/problem/E">CF1874E</a> Jellyfish and Hack</h4><p>设 $f_{i,j}$ 表示长度为 $i$ 的排列需要操作 $j$ 的方案，枚举第一个数的值，容易做到 $n^6$ dp。不难发现答案为 $O(n^2)$ 次的多项式，拉插即可。</p>
<h4 id="CF1874F-Jellyfish-and-OEIS"><a href="#CF1874F-Jellyfish-and-OEIS" class="headerlink" title="CF1874F Jellyfish and OEIS"></a><a href="https://codeforces.com/contest/1874/problem/F">CF1874F</a> Jellyfish and OEIS</h4><p>将 ${p_l,\dots,p_r} &#x3D; {l,\dots,r}$ 的区间称为好的，容易发现对于两个相交但不包含的好区间 $[l_1,r_1],[l_2,r_2] (l_1&lt;l_2)$，区间 $[l_1,l_2-1],[l_2,r_1],[r_1+1,r_2]$ 都是好的。考虑容斥，由上面的结论，只考虑容斥的区间相交或包含即可不重不漏。记 $f_{i,j}$ 表示只考虑 $[i,j]$ 中的区间的方案和，用 $g_{i,j,k}$ 表示只考虑 $[i,j]$ 中的区间，未被任何区间包含的数有 $k$个，除去未被包含数的方案和来辅助转移，$g$ 转移到 $f$ 时乘上 $k!$ 即可。</p>
<h4 id="CF1608F-MEX-counting"><a href="#CF1608F-MEX-counting" class="headerlink" title="CF1608F MEX counting"></a><a href="https://codeforces.com/contest/1608/problem/F">CF1608F</a> MEX counting</h4><p>设 $f_{i,j,k}$ 表示考虑前 $i$ 个数，$\text{mex} &#x3D; k$，$&gt;k$ 的数有 $j$ 种，这 $j$ 种数具体的值不方便记录，可以先不确定等到移动 $\text{mex}$ 时再确定，。当下一个数 $p \neq k$ 时，$\text{mex}$ 不变，有以下几种转移：</p>
<ul>
<li>$p &lt; k$，$k \times f_{i,j,k} \rightarrow f_{i+1,j,k}$。</li>
<li>$p &gt; k$ 且 $p$ 属于出现过的 $j$ 种数中的一种，$j \times f_{i,j,k} \rightarrow f_{i+1,j,k}$。</li>
<li>$p &gt; k$ 且 $p$ 未出现过，$f_{i,j,k} \rightarrow f_{i+1,j+1,k}$。</li>
</ul>
<p>当 $p &#x3D; k$ 时，考虑枚举 $t$ 表示 $[p+1,t-1]$ 中的数全部出现过且 $t$ 未出现，那么有 $A_{j}^{t-p-1} \times f_{i,j,k} \rightarrow f_{i+1,j-(t-k-1),t}$，展开得到 $\frac{j!}{(j-(t-k-1))!} \times f_{i,j,k} \rightarrow f_{i+1,j-(t-k-1),t}$。</p>
<p>容易发现对于每个 $i$，$k$ 这一维合法的状态仅有 $O(k)$ 种，复杂度 $O(n^2k)$</p>
<h4 id="CF1844G-Tree-Weights"><a href="#CF1844G-Tree-Weights" class="headerlink" title="CF1844G Tree Weights"></a><a href="https://codeforces.com/contest/1844/problem/G">CF1844G</a> Tree Weights</h4><p>令 $1$ 为根，$dep_i$ 表示 $i$ 的深度，显然有 $d_i &#x3D; dep_i + dep_{i+1} - 2dep_{lca(i,i+1)}$，考虑去掉最后一项，容易发现将整个式子模 $2$ 后，变成 $d_i \equiv dep_i + dep_{i+1} \pmod 2$，可以递推得到 $dep_i \bmod 2$ 的值。考虑将模数变为 $4$，容易发现只需要知道 $dep_{lca(i,i+1)} \bmod 2$ 的值即可递推，而这个值在上一轮已经求出，倍增直到模数大于 $nV$ 即可。</p>
<h4 id="CF1976F-Remove-Bridges"><a href="#CF1976F-Remove-Bridges" class="headerlink" title="CF1976F Remove Bridges"></a><a href="https://codeforces.com/contest/1976/problem/F">CF1976F</a> Remove Bridges</h4><p>由于 $1$ 的度数为 $1$，显然第一次添加的边一端必须是 $1$，另一端显然是叶子。考虑贪心地把树划成一些祖先 $-$ 后代链使得按长度降序排序后字典序最大，即对于每个点加入其所有儿子所在链中最长的链。假设当前已经不是割边的边为一些链的并集，此时选择两条最长的未被选择的链并将其对应叶子连接在一起显然是合法的且最优的，而连接之后已经不是割边的边仍然为一些链的并集。也就是最开始连接 $1$ 和其所在链对应儿子后每次会选择长度最大的两条链，且因为 $1$ 所在链是所有链最长的，所以这种方案一定最优。</p>
<h4 id="CF1923F-Shrink-Reverse"><a href="#CF1923F-Shrink-Reverse" class="headerlink" title="CF1923F Shrink-Reverse"></a><a href="https://codeforces.com/contest/1923/problem/F">CF1923F</a> Shrink-Reverse</h4><p>显然最多只会翻转一次。假如不进行翻转操作，尽量将前面的 $1$ 扔到后面即可。进行一次翻转操作，记操作后第一个 $1$ 的位置为 $l$，最后一个 $1$ 的位置为 $r$，得到的数即为 $[l,r]$ 翻转后的结果，显然首先需要最小化区间长度，再最小化 $[l,r]$ 翻转后的字典序。一个区间合法当且仅当 $r-l+1$ 大于等于 $1$ 的个数且不在 $[l,r]$ 的 $1$ 的个数不超过 $k-1$，双指针扫描可以得到最小长度。显然区间外的 $1$ 会填入翻转后区间的一个后缀，不难发现任意两个区间在后缀填入相同数量的 $1$ 后大小关系不变，此时只需要找到合法的 $O(n)$ 个区间中字典序最小的一个，二分哈希或后缀排序即可。</p>
<h4 id="QOJ8518-Roars-III"><a href="#QOJ8518-Roars-III" class="headerlink" title="QOJ8518 Roars III"></a><a href="https://qoj.ac/problem/8518">QOJ8518</a> Roars III</h4><p>固定根之后，容易发现最优策略即为维护关键点集合，当前点不为关键点时将最远的关键点移动到当前点。考虑如何将根从 $x$ 移动到 $y$，注意到“移动关键点”这个操作是可逆的，考虑用线段树维护以 $x$ 为根时 dfs 序为 $i$ 的点（不包含 $x$）的深度（不为关键点深度为 $-\inf$）。换根到 $y$ 只需要将移动到 $y$ 的点撤回，将新的最优点移到 $x$，然后区间加减即可。</p>
<h4 id="CF700E-Cool-Slogans"><a href="#CF700E-Cool-Slogans" class="headerlink" title="CF700E Cool Slogans"></a><a href="https://codeforces.com/contest/700/problem/E">CF700E</a> Cool Slogans</h4><p>考虑建 SAM，注意到钦定 $s_i$ 是 $s_{i+1}$ 的后缀显然不劣，容易想到在 parent 树上从上到下 dp。由于同一个点的字符串 $endpos$ 集合是相同的，所以对于每个点只需要考虑其最长的串。如何判断一个点 $x$ 代表的串是否在其后代 $y$ 中出现至少两次，即判断 $endpos_y \cap [pos_x-len_x+len_y,pos_x-1]$ 是否为空。可以对于每个点找到最近能转移的祖先转移，也可以记录二元组 $(x,w)$ 表示以 $x$ 结尾答案为 $w$，显然在 $w$ 尽量大的情况下使得 $x$ 深度尽量小即可。</p>
<h4 id="CF1896F-Bracket-Xoring"><a href="#CF1896F-Bracket-Xoring" class="headerlink" title="CF1896F Bracket Xoring"></a><a href="https://codeforces.com/contest/1896/problem/F">CF1896F</a> Bracket Xoring</h4><p>容易发现相邻两个位置填 <code>()</code> 时这两个位置的数的异或一定不变，填 <code>((</code> 或 <code>))</code> 时一定改变，那么用这种方法可以使 $a_{2i+1} &#x3D; a_{2i+2}$，构造出来不合法显然无解。在 $a_{2i+1} &#x3D; a_{2i+2}$ 的情况下，通过填入 <code>()</code> 或 <code>)(</code> 可以使对应的两个数均变为和 $a_1$ 相等，为了合法开头和结尾两个分别填入 <code>((</code> 和 <code>))</code>。此时有 $a_1 \neq a_2,a_{2n-1} \neq a_{2n}$，可以通过 <code>((()()...()))</code> 来调整。注意到每次操作均会改变 $a_1$ 和 $a_{2n}$，所以初始必然有 $a_1 &#x3D; a_{2n}$，否则无解。剩下的情况一定所有数均相同，如果全为 $1$ 通过 <code>()()...()()</code> 调整即可。</p>
<h4 id="QOJ8522-Waterfall-Matrix"><a href="#QOJ8522-Waterfall-Matrix" class="headerlink" title="QOJ8522 Waterfall Matrix"></a><a href="https://qoj.ac/problem/8522">QOJ8522</a> Waterfall Matrix</h4><p>容易想到对分界线 dp，枚举 $i$，dp 找到在分界线左侧 $&lt;i$ 的数加分界线右侧 $\geq i$ 的数最小的方案，答案即为每个 $i$ 贡献的和。不难发现 $i-1$ 的最优分界线一定在 $i$ 右下，考虑分治，对于 $mid$ 求出答案后分别递归两侧。</p>
<p>考虑对于 $k$ 个点如何快速求答案，我们需要维护一个不降序列 $f$，操作为前缀或后缀 $+1$，然后将每个数设为其后缀最小值。考虑使用 multiset 维护差分，集合中元素 $i$ 有 $j$ 个表示 $f_i-f_{i-1}&#x3D;j$，后缀 $[i,n]$ $+1$ 直接插入 $i$，前缀 $[1,i]$ $+1$ 插入 $0$ 然后找到集合中最大的 $\leq i$ 的数然后删去即可。</p>
]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>SCOI 2024 游记</title>
    <url>/post/scoi-2024-travels/</url>
    <content><![CDATA[<p>省流：<a href="https://wtyakioi.github.io/">zsq</a> Day2 切穿 $218$ 分成功登顶。</p>
<h2 id="Day-6-sim-4"><a href="#Day-6-sim-4" class="headerlink" title="Day $-6 \sim -4$"></a>Day $-6 \sim -4$</h2><p>被抓去听电子科大的省选集训，虽然不想去听，但是家长很积极，早就把钱交了。其实听电子科大师傅讲一哈重点也不是不行，主要是我想多打一哈板子，我现在还不能保证我场上能打出半平面交。</p>
<p>结果前两天 sjx 讲 dp 和计数，第三天 ljy 讲 ds，还从 ljy 那知道了后面是 lyh、kot 和一套他们三个组的题。然后大家才发现被电子科大诈骗了，因为是 ygg 声称的有电子科大师傅。然后第二天大多数人都润了。</p>
<h2 id="Day-3-sim-0"><a href="#Day-3-sim-0" class="headerlink" title="Day $-3 \sim 0$"></a>Day $-3 \sim 0$</h2><p>回到机房打板子，当然同时高强度水知乎，不过有一天 ygg 直接来机房坐了一上午有点哈人。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day $1$"></a>Day $1$</h2><p>本来还以为和去年那个批机子一样（键盘上有关机键），结果更批，直接上了难以想象的 10300，装的 win10 可能因为带不动 win11。然后还没开考就有人电脑黑了，监考声称是考生自己踢掉的，吓得我整场腿都是缩起的。</p>
<p>开考后听到 <a href="https://sukwants.pond.ink/">suk</a> 报告说打开 win 下的 vscode 就卡死了，然后监考来了句 《电脑上有 $\neq$ 你能用》，干沉默。</p>
<p>开题，T1 串串题，T2 计算几何，T3 不会。（要素齐全）</p>
<p>先开 T1，T1 大概就分 5 种情况讨论，其中一种需要暴力跳 fail 树，但跳的次数不超过串长和。不过感觉不是很好写，最后写了 4k 调了半个小时才搞完，写完 1h30min。</p>
<p>开 T3 打暴力，感觉 $m^n$ 枚举能冲 $n&#x3D;10,m&#x3D;7$ 的 $60$ 分，想了半天如何 $O(n)$ 求答案，最后还是搞了个 $O(n^2)$，然后记忆化了一些东西。实际跑极限数据近二十秒，只能说 i3 和 Ryzen 7000 还是有很大的差距。写完 2h30min</p>
<p>T2 感觉只会 $2^n n$，共圆和共线的情况感觉可以 $n^3$，不行也能暴力跑 $n^4 \log n$，先把 $20$ 分暴力写出来，此时已经只剩半个小时了。然后想到可能可以直接拆矩形拆成很多块，但是当时不知道抽啥风觉得块数是指数级的。开始搞圆的性质，写了一车我觉得很对的东西但是过不了样例，遂开摆。</p>
<p>最后一分钟叉掉虚拟机的时候整个卡死了，直到考试结束都没好，只能盯到电脑看。幸好最后还是转出来了，服了。</p>
<p>估分 $100 + 20 + [30,60]$。</p>
<p>由于是 SC 自己测，三点过就出分了，T3 有 $55$，不过排名比我期望的高，大家好像都是一百五六，只有 <a href="https://blog.zlx.pw/">zlx</a> $245$ 预定队长。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day $2$"></a>Day $2$</h2><p>开题，T1 计数，T2 不知道算啥，T3 构造。</p>
<p>写 T1，场上只想到了 $n \sum |S|$，不过感觉 i3 上跑的不慢所以感觉能冲就没管了。写完 1h30min。</p>
<p>T2 容易发现 $ans \leq 2$，判断 $0$ 是容易的，只需要判断 $1$，问题转换为不断加边维护 $S$ 到 $T$ 的割边，感觉只需要提一条连通的路径出来然后不断删即可。写了 2h 多才写出来，总共 6k，然后开始疯狂调，最后二十分钟还没调出来，于是先去打了 T3 的 $\min(m,n) &#x3D; 1$，回来继续调，最后还是没调出来，暴力也没写，希望这玩意能有点分。</p>
<p>估分 $[65,100] + 0 + 10$，输麻了。</p>
<p>被家长拉去和师傅吃饭，吃到一半就出分了，$65 + 10 + 10$，只能说没掉出队。<a href="https://wtyakioi.github.io/">zsq</a> $218$ 成功 D2 标准分，yl 翻掉 <a href="https://blog.zlx.pw/">zlx</a> 成为队长。</p>
<h2 id="Day-3-sim"><a href="#Day-3-sim" class="headerlink" title="Day $3 \sim$"></a>Day $3 \sim$</h2><p>摆。</p>
<p>后面在机房调了一哈 D2T2，一下就发现了一个弱智错误，又调了十几分钟发现了一个细节没处理好，然后就直接过了。这时候应该祭出 <a href="https://www.cnblogs.com/Feyn/">Feyn</a> 的那张图：</p>
<p><img src="/" alt="我他喵的在淦鸟吗"></p>
<p><del>找不到了</del></p>
<p>评价这次 SCOI，只能说是抽象。题倒是不出意料，但是这考点设备啥的属实抽象麻了（后面还看到说有无线网卡，才想起来确实有个师傅过来把我的机箱翻出来干了啥又塞回去，<a href="https://www.luogu.com.cn/discuss/782820">link</a>）。考完之后的申诉必须半个小时内提交，还不下发数据，建议学习 CCF 申诉缴费。包括之前把我们骗去集训，正常人都不会去第二次，电子科大还能恰几年钱我不好说。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2023 游记</title>
    <url>/post/noip-2023-travels/</url>
    <content><![CDATA[<h2 id="sim-text-Day-0"><a href="#sim-text-Day-0" class="headerlink" title="$\sim \text{Day} 0$"></a>$\sim \text{Day} 0$</h2><p>颓。</p>
<p>cdqz 接待了一车新加坡的交换生，开口就是 “旅游团”，给干沉默了（但是新加坡的同学普通话都比 ygg 标准）。</p>
<p>最后一天下午快放学的时候 ygg 到机房说今年 NOIP 比较简单（也没说和谁比比较简单），一等线 150 左右。然后开始一个一个叫去谈话，还没等到放学就和 <a href="https://sukwants.pond.ink/">suk</a> <a href="https://wtyakioi.github.io/">zsq</a> 等一起润了，卡到打铃出校门还被保安怒斥。</p>
<p>晚上不知道干点啥，板子也不想打，索性开颓。</p>
<h2 id="Day-1-上午"><a href="#Day-1-上午" class="headerlink" title="Day 1 上午"></a>Day 1 上午</h2><p>早上 6:20 就起床了，昨晚睡的比较晚，只睡了 6 个小时出头。然后吃完早饭赶到高新，一看时间才 7:15，全是高新的学生在进校。想起去 luogu 打卡，结果还忌睡觉，我谢谢你 kkk。等到 7:30 看到有很多穿 cdqz 校服的同学在门外晃，但都不认识。又过了一会 <a href="https://sukwants.pond.ink/">suk</a> 来了，开始吹牛。7:40 来的人就多了，但是还没看到 ygg，最后等到快进校门了 ygg 才到。</p>
<p>进考场感觉机子挺正常，一摸键盘，坏了，这键盘巨硬，基本只能靠砸。放解压密码的时候有两个人的压缩包损坏，因为 USB 没驱动（应该是？）只能暂时开交换机发压缩包，然后那交换机就在那跟拖拉机一样的响，开考了都没弄好，最后好像是安到了备用机子解决。</p>
<p>开题，T1 一眼原神题，只需要记录前两小即可。开写之后又发现比较不降和不增的两个字符串只需要比较第一个串的最小字符和第二个串的最大字符即可，甚至能 $O(n)$。20min 时写完</p>
<p>T2 一眼只需要维护两个数之间的相同或相反关系，如果自己同时与自己相同和相反则为 U，并查集维护。45min 写完。</p>
<p>T3 数据范围比较奇怪，感觉是放线性卡 $\log$，显然 $f$ 和 $g$ 中最大值较大的大于最大值较小的，钦定 $f_i &gt; g_i$，考虑线性判断。没啥思路，画图出来发现有时候要尽量早地放 $f$，有时候要尽量晚，画着画着发现最大值要出现地最多，也就是最大值前面尽量靠前，后面尽量靠后。于是考虑拆成两半，分别从前往后和从后往前求出最早多久可以出现相同的最大值（即多个最大值前后都到其中相同的一个），分别记为 $w_1$ 和 $w_2$，显然 $w_1 \leq w_2$ 即有解。考虑从前往后怎么做，现在 $f$ 中的值是需要尽量往前靠的，令 $x$ 为当前 $f$ 的值，$i$ 为 $g$ 当前值，可以发现如果当前位置 $x$ 可以一直加到 $x’$，且 $f_{x’} \geq f_x$，那么 $x$ 跳到 $x’$ 显然不劣。于是可以每次判断 $x$ 能否跳到 $x’$，判断只需要 $h_i$ 记录 $f_i \sim f_{i’}$ 的最小值，单调栈即可维护。感觉很正确，开写，2h 20min 时写完。</p>
<p>T4 第一眼觉得是神秘大 ds，觉得可以先放一下，重新检查了一下前 3 题，但是没拍，觉得没啥好拍的。再看一眼 T4，考虑用 $f_i$ 记录第 $i$ 天没打卡的最大值，然后线段树即可维护，感觉像是切了，T4 不会这么简单把。3h 写完，没过大样例，然后开始疯狂拍、调，找出了好几个弱智错误，暴力还挂了一次，3h 50min 终于过大样例了，感觉像玩了原神一样。</p>
<p>尝试拍一下，但是 T2 T3 暴力都不咋会写，先去把 T1 拍了，结果还真拍出来了，$n&#x3D;1$ 挂了，有点哈人。现在严重怀疑 T2 T3 要挂，只能阅读代码来检查，没发现什么锅。罚坐 15min。ygg 还说这次一等线 150，这怕是要上 200。</p>
<p>出来一问好像都切 T3 或 T4，同时切的还没几个。结果我爸要送 ygg 去机场，害怕，直接润去挤 <a href="https://sukwants.pond.ink/">suk</a> 的车。</p>
<h2 id="Day-1-下午后"><a href="#Day-1-下午后" class="headerlink" title="Day 1 下午后"></a>Day 1 下午后</h2><p>颓。mc 启动！</p>
<p>ygg 三点就在问民间分数，看了一圈没一个出数据的，也不知道他在急啥。</p>
<p>七点过吃完饭看到 yundou 出数据了，一发冲，没挂，还好。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>颓。</p>
<p>7:30 爬起来尝试打互测，看了题之后脑子简直不想动，遂摆。</p>
<p>luogu 和 xtl 都出了，没挂。</p>
<p>居然是 luogu NOIP 榜 rk1，粉丝数 +++++，这不狠狠地打波<a href="https://www.luogu.com.cn/user/291248">广告</a>。</p>
<p>晚上帮 <a href="https://syy.pond.ink/">syy</a> 打 CF 上分，结果 Div.2 一个小时只过 4 道，C 和 D 都狠狠地把自己撅了，大概就是 “写成这批样怎么过的样例啊”，不过还是小上了一点分。</p>
<p>11-24 晚上居然就可以查了，传统艺能 <a href="https://cspsjtest.noi.cn/page/compStudent/resultStudent.php?compID=85">link</a>，没挂。</p>
<p>过了半个小时居然修了，CCF 居然修锅了，可喜可贺。</p>
<p><img src="/post-images/noip-2023-travels-1.png?300x" alt="1"></p>
<p>然后群里一看申诉还是可以查，绷不住了。</p>
<p>25 日早上听说昨晚申诉也被 ban 了，但是现在又好了，不知道在干啥。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2023 游记</title>
    <url>/post/csp-s-2023-travels/</url>
    <content><![CDATA[<h2 id="sim-text-Day-0"><a href="#sim-text-Day-0" class="headerlink" title="$\sim \text{Day} 0$"></a>$\sim \text{Day} 0$</h2><p>出准考证号才发现，大家都是一百多两百多，就我是 552，自闭。不过 zpl 更自闭：祂在 myns 考试，CCF 日常发电。</p>
<h2 id="text-Day-1"><a href="#text-Day-1" class="headerlink" title="$\text{Day} 1$"></a>$\text{Day} 1$</h2><p>颓了一上午加一中午。</p>
<p>一点四十左右到高新门口，还比较早，大多数人都还没来，不过老远就看到 ygg 在学校里面和别的师傅谈笑风生。看到 <a href="https://wtyakioi.github.io/">zsq</a> <a href="https://syy.pond.ink/">syy</a> 等人居然带了咖啡，一看就是要启动，就我只带了一瓶香槟（矿泉水）。</p>
<p>进考场之后才发现一个严重的问题：我这个机房居然是 win10 老机子？？？一看 CPU 10700，还好，不是 4 代 i5 之类的。罚坐 20min。</p>
<p>启动！T1 哈麻皮，T2 感觉很能做，T3 出题人****，T4 暂时没思路。</p>
<p>T1 在 15min 时写完。</p>
<p>T2 猜一个 $f_i&#x3D;f_{i-g_i}+1$，$f_i$ 是以 $i$ 结尾的答案，$g_i$ 是 $i$ 结尾最短偶回文串长度，证了一会发现是对的。求 $g$ 数组用了二十分钟胡了好几种 $O(n)$ 做法，但都发现是假的。然后尝试 $O(n \left| \sum \right|)$，用 $h_{i,j}$ 表示以 $i$ 结尾再跟一个字符 $j$ 的最短偶回文串长度，显然就可以转移了。写完大概 50min。</p>
<p>启动 T3，数据范围很小，直接上 <code>std::map</code> 和 <code>std::string</code>。一个小时差不多写完，没过第二个样例，才发现读错题了，问题不大，改改就过了，这时才看到最后的形式化题面，我谢谢你 CCF。写完 2h 多一点。</p>
<p>T4 开题就发现如果确定了结束时间，那么每棵树所需的生长时间是可知的。二分结束时间，每棵树的最晚种植时间为 $f_u$，由于需要先种父亲再种儿子，所以 $f_u&#x3D;\min(f_u,f_v+1)$，双 $\log$ 开个优先队列每次取最早的即可，单 $\log$ 想了一会没想出来，先去想怎么求 $f$。每棵树所需的生长时间需要解二次方程得到，但是搓了半个小时怎么都搞不对，直接开摆写二分加 <code>__int128_t</code>，一遍过大样例，最后一个大样例需要跑 $0.7\text{s}$。前面一半是双 $\log$，后面的单 $\log$ 也懒得想了，CCF 的评测机 8700K 要比本机多一个 K，可以钦定不会被卡，而且双 $\log$ 和暴力一个分也过于抽象了。</p>
<p>写完还剩半个小时，搓了个快读，拍了一下 T2。本来想搓个字符画但是搓出来的 $2$ 怎么看怎么不对，只能直接写上去：<del>（顺便广告：）</del></p>

<details class="hcb-content box hcbexample">
  <summary><i class="fa fa-vial fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from 2745518585</span></span><br><span class="line"><span class="comment">// Ad: Orita: Useful OI Tools: https://github.com/2745518585/Orita</span></span><br></pre></td></tr></table></figure>
</details>


<p>这次题相当简单，感觉大家都能 AK。出来先遇到 <a href="https://www.cnblogs.com/Feyn/">Feyn</a>，问 T4 单 $\log$，好像祂也不会，问了一圈感觉没有写单 $\log$ 的，感觉稳了。结果出来被告知要去一起吃饭，ygg 也在，要瓜起。</p>
<p>听到 T2 原题 CF1223F，T4 好像是哪个学校的模拟赛的题，CCF 就出了个 T1 T3？不好评价。</p>
<p>由于 ygg 在谈笑风生，到 10 点都没人发 src，找高一的师傅要了一份，luogu 上 T1 T2 都过了，yundou 上全过了。</p>
<p>颓。</p>
<h2 id="text-Day-2-sim"><a href="#text-Day-2-sim" class="headerlink" title="$\text{Day} 2 \sim$"></a>$\text{Day} 2 \sim$</h2><blockquote>
<p><a href="https://www.noi.cn/xw/2023-10-23/796608.shtml">关于部分平台私自发布CSP-J&#x2F;S 2023认证结果的公告</a></p>
</blockquote>
<p>樂，CCF 恼羞成怒。</p>
<p>过了两天又有小周老师新文。</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzcxMTY4OQ==&mid=2247485279&idx=1&sn=8e946a1dbf097603d7fe999f98d52a88&chksm=96ca72f9a1bdfbef6db370b669792513234dadd960198d8bff451bb8b0cd35bb001cb5ef6e69&mpshare=1&scene=23&srcid=1024wxs9ddTvySY1xAZQz7gO&sharer_shareinfo=2a2f8c1b00d1aaa6ddaa9b3d5b5efffb&sharer_shareinfo_first=2a2f8c1b00d1aaa6ddaa9b3d5b5efffb#rd">23年提高组题解</a></p>
</blockquote>
<blockquote>
<p>5- 退役战，APIO获得银牌，排名100，成绩远超曾经上海赛区NOIP排名第一的同学。</p>
</blockquote>
<blockquote>
<p>【小周老师注：一定要赞美CCF啊同学们！】</p>
</blockquote>
<blockquote>
<p>但我并不认为CCF以后会继续朝着OOP或者软件工程靠近，毕竟，NOIP存在的意义，是为了选出4名国手参加IOI，算法优秀就行了，其他的回头再说。</p>
</blockquote>
<p>樂</p>
<p>至于这个 “谦哥”，这简历详细的，属于是无效打码了。甚至高二没进省队还在打 APIO，不好评价。</p>
<p><img src="/post-images/csp-s-2023-travels-1.png?300x" alt="1"></p>
<p>😭😭😭晚上被 ygg 抓到 UB 了，T2 摸了数组下标 $-1$，在 dev 上要 RE😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭。有的同学喜欢写 UB，评价是不如原神。</p>
<p>以后测试必加 <code>-fsanitize=undefined</code>。</p>
<p>30 号晚上查分，传统艺能 <code>https://cspsjtest.noi.cn/page/compStudent/resultStudent.php?compID=83</code>。没挂。</p>
<p>不知道有没有群 u 冲申诉加 100 分的。</p>
<p>20 号才出榜，甚至在 NOIP 之后，多少沾点。</p>
<p>19 号下午居然就出榜了！CCF 提前了整整半天发榜，可喜可贺！</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>APIO 2023 游记</title>
    <url>/post/APIO2023-travels/</url>
    <content><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>报道日。</p>
<p>下午三四点到了酒店，纪念品有一个电脑包、一些文件夹和 T 恤。然后排了半个小时的队办入住，和 iee 住一起，再排了十分钟的队打饭，服了。提供的菜种类很多，但只有少数对口味的，但是里面提供了薯条和鸡米花，又排了好久的队去打。</p>
<p>晚上的开幕式没啥看的，倒是有 dzd 的表情包（来源：<a href="https://star-32.github.io/">lyh</a>）：</p>
<p><img src="/post-images/APIO2023-travels-1.png" alt="1"></p>
<p>回房间打 generals 和 digdig，打到 11 点睡觉。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>由于我和 iee 都看错时间了，早上 7:30 才起，8 点就开始讲课，于是就迟到了，不过去的晚，餐厅也没排队。</p>
<p>今天上午两节字符串，去的时候在讲裸的 AC 自动机，还以为这堂课比较简单，结果后面几道例题直接搞不会了，直接开摆。课间休息时挪到 <a href="https://star-32.github.io/">lyh</a> 那一脑车人旁边了，预计下节课啥都听不懂，又不敢打游戏，只能坐那水知乎。结果基本全都在讲基本子串结构，听马。</p>
<p>一下课就直接润，但还是排了好久队。吃完饭回房间颓，一看下午的课是 “写一个解释器”，嘶，不如不听。iee 直接不去，但我还是准备下去听一会再说。2 点钟下来坐到最后一排，发现只有一半不到的人，刚准备润，有个人直接说要点名，没来的不发密码条。虽然我觉得不可能不发密码条，但大多数人都下来了。然后又不知道发啥电把我那排全部轰走了（全是 cdqz 的），让新来的人坐。过了一个小时传过来一个点名册，写个名就完，离大谱。</p>
<p>晚上领到了座位号，回房间颓，颓到 11 点睡觉。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>测试日。</p>
<p>听说 APIO 的评测机很慢，平均半个小时返回，后面直接变 OI 赛制，他这次声称用了一百台评测机，也不知道会怎么样。</p>
<p>早上 9 点入场试机，评测用的 cms，系统是一个比较奇怪的 Linux，实在不知道码点啥就犯傻码了个快读。</p>
<p>10 点开考，T1 是一个图求，有三种边：把时间 $+w$、除以 $2$、清零，除以 $2$ 最多 $k$ 次。显然可以 $mk \log$ 分层图最短路，一看居然有 $97$ 分，直接开写，剩下 $3$ 分不要了。半个小时码完交上去，看 T2，是求区间中位数的最大个数，想了半天不会。二十分钟后 T1 才测出来，WA 了，Sub0 都 WA 了，只有 $opt&#x3D;0$ 没 WA。我认为 Sub0 就是样例，但是我显然过了样例，于是脑抽去交了个线上测试。然后写对拍，拍出来了，调一调发现有个地方写挂了，再交。然后开始码 T2 暴力，交了 T2 之后 T1 也出来了，还是 WA，再调，发现可能出现走一次除多遍的情况，再交。T2 的 Sub3 是值单峰，显然可做，直接开码。11:40 的时候 T1 终于返回结果 97 分了，专心搞 T2。</p>
<p>Sub3 写完交，Sub4 是值域 $[1,3]$，显然可以枚举值转化为二维数点，Sub5 是每个值出现次数小于等于 $2$，只需要枚举值判断是否可以为 $2$，两个值中间的必选，看选两边的能不能使这个值为中位数，线段树维护。结果 Sub3 没过，搓对拍，调，再交，然后把 Sub4 和 Sub5 写了交。看 T3，阴间通信套个搓 CPU，Sub1 是 $n&#x3D;1$，显然只需要乘法器，有 $12$ 分。这道题搓的方法还很阴间，不能套门，还必须输入数据编号小于输出数据编号。还没开始搓，T2 Sub5 没过，又调，交。此时已经只剩半个小时了，搓乘法器，还剩时十分钟搓完了，交上去，此时 T2 还没测完。抓紧读后面的 Sub，感觉还有 $24$ 分比较简单，但感觉码不完。最后 T3 还是没写完。估分 $97 + [47,60] + [0,12] &#x3D; [144,169]$。</p>
<p>回去一问，好像会 T2 的人很多，还有一大堆 $266$ 的，寄，但应该还是有 $\text{Cu}$。搞了半天不知道在哪看分，在 LA 群上才找到，最终 $169$。</p>
<p>晚上国家队见面，主持人问了很多问题。后面让学生提问，第一个人上去就问：“请问如何评价此次 APIO 2023 比赛”，鼓掌 &#x2F;gz&#x2F;gz&#x2F;gz&#x2F;gz&#x2F;gz，回答：“他创造了一种新的赛制”。</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>今天上午讲多项式，下午杂题，勉强听了一些。</p>
<p>晚上闭幕式，先是选手唱歌，第二首是 《never gonna give you up》，&#x2F;gz&#x2F;gz&#x2F;gz&#x2F;gz。然后颁线上的奖，没想到线如此低，$\text{Cu}$ $48$，$\text{Ag}$ $111$，$\text{Au}$ $147$。然后又有群人上来跳 《听我说谢谢你》，&#x2F;gz&#x2F;gz&#x2F;gz&#x2F;gz。然后正式颁奖，$\text{Cu}$ $132$，$\text{Ag}$ $187$，$\text{Au}$ $233$，还是上位 $\text{Cu}$。他们突然在闹 $\text{Au}$ $229$，一看 $\text{Ag}$ 最高 $228$，好像有道理。</p>
<p>开摆。</p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>下午的飞机，可以颓一上午，开摆。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder Regular Contest 160 A-F 题解</title>
    <url>/post/ARC160-solution/</url>
    <content><![CDATA[<h2 id="A-Reverse-and-Count"><a href="#A-Reverse-and-Count" class="headerlink" title="A - Reverse and Count"></a>A - Reverse and Count</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长为 $n$ 的数列，选择一个区间并翻转，求得到字典序第 $k$ 小的序列。</p>
<p>$n \leq 7000,k \leq \frac{n(n+1)}{2}$</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于一个子问题 $(m,l)$ 考虑第 $1$ 位填什么：$i$ 从 $1$ 到 $m$ 枚举，如果 $i \not &#x3D; a_1$，必须把数 $i$ 翻转到第 $1$ 位，只有一种可能。否则数 $i$ 已经在第 $1$ 位，可以在 $[2,m]$ 中旋转，共 $\frac{m(m-1)}{2}$ 种，也可以不改变数组，进行大小为 $1$ 的旋转，在 $[2,m]$ 中进行大小为 $1$ 的翻转已经被统计了，所以总情况数就是 $\frac{m(m-1)}{2}+(n-m+1)$。如果 $k$ 大于当前情况数，那么就从 $k$ 中减去情况数并考虑 $i+1$ 的情况，否则遇到子问题就递归，只有一种情况就返回答案。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k,vector&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]==i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=m*(m<span class="number">-1</span>)/<span class="number">2</span>+(n-m+<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">                b.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;++j) b[j]=a[j+<span class="number">1</span>]-(a[j+<span class="number">1</span>]&gt;i);</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; c=<span class="built_in">solve</span>(m<span class="number">-1</span>,k,b),d;</span><br><span class="line">                d.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;++j) d[j+<span class="number">1</span>]=c[j]+(c[j]&gt;=i);</span><br><span class="line">                d[<span class="number">1</span>]=i;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> k-=m*(m<span class="number">-1</span>)/<span class="number">2</span>+(n-m+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[j]==i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x=j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x/<span class="number">2</span>;++j) <span class="built_in">swap</span>(a[j],a[x-j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> --k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    a.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b=<span class="built_in">solve</span>(n,k,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="B-Triple-Pair"><a href="#B-Triple-Pair" class="headerlink" title="B - Triple Pair"></a>B - Triple Pair</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>求有多少对正整数 $(x,y,z)$ 满足 $xy,yz,zx \leq n$，对 $998244353$ 取模。</p>
<p>$n \leq 10^9$</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>考虑整除分块，先枚举 $x$，显然对于 $\frac{n}{x}$ 相等的所有 $x$，$y,z$ 的个数相等，设 $f_i$ 为 $y,z \leq i,yz \leq n$ 的个数，知道了 $f$ 就可以快速求答案。</p>
<p>枚举 $i$，对 $i$ 整除分块，$f_i$ 等于上一块也就是 $f_{\frac{n}{\frac{n}{i-1}}}$ 加上 $y,z$ 其中一个等于 $i$ 的情况，注意减去 $y,z$ 都等于 $i$ 的情况和特判 $i&#x3D;1$。复杂度 $O(\sqrt{n})$。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">const</span> ll P=<span class="number">998244353</span>;</span><br><span class="line">ll n,f1[N],f2[N];</span><br><span class="line"><span class="function">ll &amp;<span class="title">sum</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x*x&lt;=n) <span class="keyword">return</span> f1[n/(n/x)];</span><br><span class="line">    <span class="keyword">return</span> f2[n/x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">        ll p=<span class="built_in">sqrt</span>(n)+<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=p;++i) f1[i]=f2[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ll j=n/(n/i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>) <span class="built_in">sum</span>(j)=<span class="built_in">sum</span>(n/(n/(i<span class="number">-1</span>)));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">sum</span>(j)=<span class="number">0</span>;</span><br><span class="line">            ll z=<span class="built_in">min</span>(n/i,j);</span><br><span class="line">            <span class="built_in">sum</span>(j)=(<span class="built_in">sum</span>(j)+(j-i+<span class="number">1</span>)*z*<span class="number">2</span>%P-<span class="built_in">max</span>(z-i+<span class="number">1</span>,<span class="number">0ll</span>)+P)%P;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ll s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ll j=n/(n/i);</span><br><span class="line">            s=(s+(j-i+<span class="number">1</span>)*<span class="built_in">sum</span>(n/i)%P)%P;</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="C-Power-Up"><a href="#C-Power-Up" class="headerlink" title="C - Power Up"></a>C - Power Up</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个长为 $n$ 的可重集 $a$，可以重复进行以下操作：</p>
<ul>
<li>选择两个相同的数 $x$ 从可重集中删除这两个数并加入 $x+1$。</li>
</ul>
<p>求可能得到的不同的可重集个数，模 $998244353$。</p>
<p>$n \leq 2 \times 10^5, a_i \leq 2 \times 10^5$</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>设 f_{i,j} 表示 $[1,i]$ 的数有 $j$ 个的方案数，g_{i,j} 表示 $[1,i]$ 的数大于等于 $j$ 个的方案数，$b_i$ 表示初始可重集中有 $b_i$ 个 $i$。显然有转移：$f_{i,j+b_i} &#x3D; g_{i-1,j*2}$。时间复杂度 $n^2$</p>
<p>考虑优化，显然一个数 $i$ 对 $i$ 的个数贡献为 $1$，$i+1$ 最多为 $\frac{1}{2}$，$i+2$ 最多为 $\frac{1}{4}$，也就是一个数对所有值的个数贡献和为 $O(1)$ 的，我们只需要对于每个值找到最多有多少个数即可。用优先队列维护堆，模拟一遍即可。</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">const</span> ll P=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,q,b[N],d[N];</span><br><span class="line">ll *f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        q=<span class="built_in">max</span>(q,x);</span><br><span class="line">        Q.<span class="built_in">push</span>(x);</span><br><span class="line">        ++b[x],++d[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k1=Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(Q.<span class="built_in">empty</span>()||k1!=Q.<span class="built_in">top</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k2=Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        Q.<span class="built_in">push</span>(k1+<span class="number">1</span>);</span><br><span class="line">        ++d[k1+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="keyword">new</span> ll[<span class="number">10</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q*<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="keyword">new</span> ll[d[i]+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b[i]<span class="number">-1</span>;++j) f[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=b[i];j&lt;=d[i];++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j-b[i])*<span class="number">2</span>&lt;=d[i<span class="number">-1</span>]) f[i][j]=f[i<span class="number">-1</span>][(j-b[i])*<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=d[i]<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j) f[i][j]=(f[i][j]+f[i][j+<span class="number">1</span>])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[q*<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="D-Mahjong"><a href="#D-Mahjong" class="headerlink" title="D - Mahjong"></a>D - Mahjong</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>求有多少个长为 $N$，和为 $M$ 的序列 $A$，使得可以通过以下两种操作（次数无限制）将序列变为 $0$：</p>
<ol>
<li>在 $A$ 中选一个元素，将其减去 $K$（$K$ 给定）。</li>
<li>在 $A$ 中选取长度为 $K$ 的子串，子串中每个元素减去 $1$。</li>
</ol>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>$K$ 不整除 $M$ 显然无解，所以限制即为总操作次数为 $\frac{M}{K}$。</p>
<p>我们发现在同一个子串上做 $K$ 次操作二，等于每个位置上做一次操作一，于是我们大胆猜测如果限制以某一个位置开始的操作二不超过 $K-1$ 次，那么操作位置和原始序列一一对应。证明显然，假设从前往后确定操作的个数，当前位置 $x$ 的值减去 $[x-k+1,x-1]$ 中操作二的个数后 $\mod K$ 的余数就是操作二的个数，因为前面的操作的贡献已经计算，后面的操作不会对这个位置产生影响。</p>
<p>题目转换为：构造长度为 $2N-K+1$ 的序列，其中前 $N-K+1$ 个数小于等于 $K-1$。考虑容斥，钦定一些数大于 $K-1$，剩下的随便放，详见代码。</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll P=<span class="number">998244353</span>;</span><br><span class="line">ll n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exgcd</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=(a%P+P)%P;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,P,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x%P+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    ll s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=a-b+<span class="number">1</span>;i&lt;=a;++i) s=s*(i%P)%P;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=b;++i) s=s*<span class="built_in">inv</span>(i%P)%P;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">if</span>(m%k!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m/=k;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;=n-k+<span class="number">1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) s=(s+<span class="built_in">C</span>(n-k+<span class="number">1</span>,i)*<span class="built_in">C</span>(m-i*k+n*<span class="number">2</span>-k,n*<span class="number">2</span>-k)%P)%P;</span><br><span class="line">        <span class="keyword">else</span> s=(s-<span class="built_in">C</span>(n-k+<span class="number">1</span>,i)*<span class="built_in">C</span>(m-i*k+n*<span class="number">2</span>-k,n*<span class="number">2</span>-k)%P)%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(s%P+P)%P);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="E-Make-Biconnected"><a href="#E-Make-Biconnected" class="headerlink" title="E - Make Biconnected"></a>E - Make Biconnected</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给你一棵由无向边组成的<strong>二叉树</strong>，树上每个点有权值 $w_i$。你可以把两个点之间连无向边，如果将 $u$ 与 $v$ 连边，代价是 $w_u+w_v$。请给出一种连边方式，使得连边后，图中去掉任何一个点仍然联通，即图是一个点双连通图。在此基础上，你要使代价最小。</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>显然可以发现每个叶子节点至少连一条边，我们尝试将叶子和叶子配对，于是分奇偶讨论：</p>
<ul>
<li><p>偶数个叶子：叶子间可以两两匹配。</p>
<p>如果两个叶子连了边，那么去掉的点在这两个叶子之间的路径上的情况都连通，因此在钦定了一个度数不为 $1$ 的节点为根后，我们希望匹配的叶子的 $LCA$ 深度尽量小。</p>
<p>直接考虑 $LCA$ 都为根的情况，也就是说任意一对叶子要在不同的子树中，即最大的子树的叶子个数不超过 $\frac{k}{2}$（$k$ 为叶子个数）。显然任何一种情况都可以找到这么一个根。</p>
</li>
<li><p>奇数个叶子：假设无法匹配的叶子为 $x$，其他叶子按偶数情况匹配，我们会发现最后没有覆盖到的位置只有 $x$ 向上到最近一个三度点，因此我们只需要在这之外找到一个最小的点与之匹配即可。</p>
<p>我们考虑钦定与这个叶子匹配的点 $y$（非叶子），容易发现如果 $x$ 和 $y$ 路径上包含三度点（不包含 $y$），这个 $x$ 就是合法的。</p>
<p>显然除了只有一个三度点的情况下，任何一个点 $y$ 都能找到叶子与之匹配，因此 $y$ 就是全局最小点。只有一个三度点的情况下找最小的非三度点即可。</p>
</li>
</ul>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,b[N],l[N],f[N],fa[N];</span><br><span class="line"><span class="type">bool</span> g[N],h[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N],c[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[x]==<span class="number">1</span>) f[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> f[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa[x]||g[i]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[i]=x;</span><br><span class="line">        <span class="built_in">dfs0</span>(i);</span><br><span class="line">        f[x]+=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,vector&lt;<span class="type">int</span>&gt; &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[x]==<span class="number">1</span>) c.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa[x]||g[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(i,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(l[x]&gt;=<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[x]&gt;=<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">    g[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs3</span>(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c[x].<span class="built_in">size</span>()&lt;c[y].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i].<span class="built_in">clear</span>(),c[i].<span class="built_in">clear</span>(),l[i]=f[i]=fa[i]=h[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            a[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">            ++l[x],++l[y];</span><br><span class="line">        &#125;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i]==<span class="number">1</span>) ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l[i]&gt;=<span class="number">3</span>) ++u;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> o=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(l[i]&lt;<span class="number">3</span>&amp;&amp;(b[i]&lt;b[o]||o==<span class="number">0</span>)) o=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(b[i]&lt;b[o]||o==<span class="number">0</span>) o=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h[o]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[o]) <span class="built_in">dfs2</span>(i,o);</span><br><span class="line">            <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l[i]==<span class="number">1</span>&amp;&amp;h[i]==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs3</span>(z,<span class="number">0</span>);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(o,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]) <span class="keyword">continue</span>;</span><br><span class="line">            l[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!g[j]) ++l[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(l[i]==<span class="number">1</span>) ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!g[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs0</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> q=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=fa[i]&amp;&amp;!g[j]) w=<span class="built_in">max</span>(w,f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            w=<span class="built_in">max</span>(w,m-f[i]);</span><br><span class="line">            <span class="keyword">if</span>(w&lt;=m/<span class="number">2</span>) q=i;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[q]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs0</span>(q);</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; Q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:a[q])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(i,c[i]);</span><br><span class="line">            Q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l[q]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[q].<span class="built_in">push_back</span>(q);</span><br><span class="line">            Q.<span class="built_in">push</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k1=Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> k2=Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(c[k1].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(c[k1].<span class="built_in">back</span>(),c[k2].<span class="built_in">back</span>()));</span><br><span class="line">            c[k1].<span class="built_in">pop_back</span>(),c[k2].<span class="built_in">pop_back</span>();</span><br><span class="line">            Q.<span class="built_in">push</span>(k1),Q.<span class="built_in">push</span>(k2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i.first,i.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="F-Count-Sorted-Arrays"><a href="#F-Count-Sorted-Arrays" class="headerlink" title="F - Count Sorted Arrays"></a>F - Count Sorted Arrays</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n$，初始有 $n!$ 个 $n$ 的排列 $S_1,S_2,\dots,S_{n!}$。给出 $m$ 次询问，每次两个数 $a$ 和 $b$（$1 \leq a &lt; b \leq n$），对于任意一个序列 $S_i$，如果 $S_{i,a} &gt; S_{i,b}$，那么交换 $S_{i,a}$ 和 $S_{i,b}$，操作结束后输出此时已经排好序的序列个数。强制在线。</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>数据范围 $n \leq 15$，考虑 $2^n$。对于 $x \in [0,n]$，设 $\leq x$ 为 $0$，$&gt; x$ 的为 $1$，我们可以把一个排列 $T$ 转换为 $n+1$ 个 01 串，记为 $t_{T,0 \sim m}$，显然如果这 $n+1$ 个 01 串均有序，那么也排列也有序。显然有 $\text{popcount}(t_{T,i}) &#x3D; i$（$\text{popcount}(i)$ 表示 $i$ 中 $1$ 的个数），且 $t_{T,i}$ 与 $t_{T,i+1}$ 只有一位从 $0$ 变成了 $1$，本质上变化的这一位就表示这一位上的数是 $i+1$，这意味着一个包含 $n+1$ 个 01 串的合法的 01 串序列 $p$ 可以唯一对应一个排列，其中合法指 $\forall i \in [0,n-1]$，$p_{i}$ 与 $p_{i+1}$ 只有一位不同，且 $p_0 &#x3D; {0,0,\dots,0}$，$p_n &#x3D; {1,1,\dots,1}$。</p>
<p>假设我们已经处理出所有 01 串 $i$ 经过前 $k$ 个操作得到的序列 $f_i$，显然可以得到 01 串 $i$ 是否经过操作后有序，也就是排列转换出来的 01 串能否包含 $i$。我们可以考虑对 01 串序列 $p$ 计数，<br>设 $dp_i$ 表示确定了 $p$ 前 $\text{popcount}(i)$ 个 01 串，最后一个 01 串为 $i$ 的合法方案数，可以枚举 $p_{i-1}$ 和 $p_i$ 不同的是哪一位来转移，即：$dp_i&#x3D;\sum\limits_{j \in i}^n dp_{i \oplus 2^j}$。注意去掉不合法的情况，也就是如果 $i$ 操作后不有序，$dp_i &#x3D; 0$。</p>
<p>现在我们得到了 $O(nm2^n)$ 的算法，还不能通过。由于这个操作是把顺序不对的两个数交换，猜测这会让整体 “变得越来越有序”，使得经过很少的操作所有排列全部有序。我们把操作后交换了至少一对数的操作叫做有效的找错，单独考虑一个排列 $T$，显然只有操作排列中的逆序对才是有效的操作。而交换逆序对中的两个元素是一定会让逆序对个数减少的，所以可以有效操作的数对会越来越少。对于所有排列同理，可以有效操作的数对也单调递减。所以 $m$ 个操作中最多存在 $\frac{n(n-1)}{2}$ 个有效操作，如果我们只关心有效的操作，复杂度就变为 $O(n^32^n)$，可以通过。</p>
<p>用 $g_{i,j}$ 表示操作数对 $(i,j)$ 是否有效。由于操作 $(x,y)$ 只会使得形如 $(x,i)$ 或 $(y,i)$ 的 $g$ 值变化，每次操作只会有 $O(n)$ 个，暴力单次复杂度为 $n2^n$，显然只有有效的操作才会产生更新，所以总复杂度 $O(n^32^n)$，可以通过此题。</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>,M=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,m,f[N];</span><br><span class="line">ll b[N];</span><br><span class="line"><span class="type">bool</span> g[M][M],h[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> x1,<span class="type">int</span> x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x&amp;(<span class="number">1</span>&lt;&lt;(<span class="built_in">min</span>(x1,x2)<span class="number">-1</span>)))!=<span class="number">0</span>)&amp;&amp;((x&amp;(<span class="number">1</span>&lt;&lt;(<span class="built_in">max</span>(x1,x2)<span class="number">-1</span>)))==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++i) b[i]=<span class="number">0</span>;</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[f[i]]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">            b[i|(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]+=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) h[((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)&lt;&lt;(n-i)]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++i) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j) g[i][j]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll w=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z1,z2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;z1,&amp;z2);</span><br><span class="line">        <span class="type">int</span> x=(z1+w)%n+<span class="number">1</span>,y=(z2+w*<span class="number">2</span>)%n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">if</span>(g[x][y]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j) g[x][j]=g[j][x]=g[y][j]=g[j][y]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(f[j],x,y)) f[j]^=(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))^(<span class="number">1</span>&lt;&lt;(y<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(f[j],x,k)) g[x][k]=g[k][x]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(f[j],y,k)) g[y][k]=g[k][y]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w=<span class="built_in">solve</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <tags>
        <tag>AT</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/post/game-theory/</url>
    <content><![CDATA[<h2 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h2><p>公平组合游戏的定义如下：</p>
<ul>
<li><p>游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；</p>
</li>
<li><p>任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；</p>
</li>
<li><p>游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。</p>
</li>
</ul>
<h3 id="博弈图和状态"><a href="#博弈图和状态" class="headerlink" title="博弈图和状态"></a>博弈图和状态</h3><p>如果将每个状态视为一个节点，再从每个状态向它的后继状态连边，我们就可以得到一个博弈状态图。一个棋子位于初始状态，两人轮流移动棋子，每次移动一步，不能移动者败。</p>
<p>定义必胜状态为先手必胜的状态，必败状态为先手必败的状态。</p>
<p>如果一个状态没有后继状态，那么棋子到达这里就无法移动，此时当前的先手必败，也就是必败状态。</p>
<p>如果一个状态的后继状态中有一个必败状态，那么先手移动到这个必败状态就可以保证后手必败，当前状态就是必胜状态。</p>
<p>如果一个状态的后继状态全部是必胜状态，无论先手怎么移动后手都必胜，当前状态就是必败状态。</p>
<p>根据定义可得，一个公平组合游戏的博弈图是一个 DAG，就可以一次拓扑排序求出每个状态必胜还是必败。</p>
<h3 id="SG-函数"><a href="#SG-函数" class="headerlink" title="SG 函数"></a>SG 函数</h3><p>在一个 DAG 中，一个棋子位于初始状态，两人轮流移动棋子，每次移动一步，不能移动者败。这样的游戏叫做有向图游戏。事实上，因为公平组合游戏的博弈图是一个 DAG，所以公平组合游戏可以转化为有向图游戏。</p>
<p>定义 $\text{mex}$ 函数的值为不属于 $S$ 的最小非负整数，即：<br>$$<br>\text{mex}(S) &#x3D; \min{x} (x \notin S,x \in N)<br>$$<br>定义 $\text{SG}$ 函数为其后继状态的 $\text{SG}$ 的异或和，即对于一个状态 $x$，设其后继状态为 $y_1,y_2,\dots,y_k$：<br>$$<br>\text{SG}(x) &#x3D; \text{mex}{\text{SG}(y_1),\text{SG}(y_2),\dots,\text{SG}(y_k)}<br>$$<br>一个有向图游戏的 $\text{SG}$ 值为其初始状态的 $\text{SG}$ 值。</p>
<p>对于一个包含 $n$ 个有向图游戏的组合游戏，这个游戏的 $\text{SG}$ 值为这 $n$ 个有向图游戏的 $\text{SG}$ 的异或和。设第 $i$ 个有向图游戏的初始状态为 $s_i$，这个游戏的 $\text{SG}$ 值就是 $\text{SG}(s_1) \oplus \text{SG}(s_2) \oplus \dots \oplus \text{SG}(s_n)$。</p>
<p>一个游戏是先手必胜的，当且仅当这个游戏的 $\text{SG}$ 值不为 $0$。这个定理被称为 SG 定理。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>我们假设当前状态的后继状态都满足 SG 定理，需要证明当前状态也满足 SG 定理。</p>
<p>显然没有后继状态的状态 $\text{SG}$ 为 $0$，且为必败状态。</p>
<p>如果当前状态 $\text{SG}$ 值为 $0$，不管怎么移动 $\text{SG}$ 值都要改变，它所有的后继状态 $\text{SG}$ 均不为 。</p>
<p>如果当前状态 $\text{SG}$ 值 $k$ 不为 $0$，设 $k$ 二进制下最高位为 $d$，显然一定有一个单一状态的 $\text{SG}$ 值 $\text{SG}_i$ 第 $d$ 位为 $1$，异或后显然 $\text{SG}_i$ 变小，一定存在一个后继状态的 $\text{SG}_j &#x3D; \text{SG}_i \oplus k$。所以先手一定可以移动到一个 $\text{SG}$ 值为 $0$ 的状态。</p>
<p>许多的公平组合游戏的结论都可以用这种方式证明，只需要证明一下 $3$ 点：</p>
<ol>
<li>没有后继状态的状态为必败状态。</li>
<li>任何一个必胜状态，其后继状态全部是必败状态。</li>
<li>任何一个必败状态，都可以转移到一个必胜状态。</li>
</ol>
<h3 id="Nim-游戏"><a href="#Nim-游戏" class="headerlink" title="Nim 游戏"></a>Nim 游戏</h3><p>$n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取，取走最后一个物品的人获胜。</p>
<p>显然一堆 $x$ 个物品取一次后可以变成 $[0,x-1]$ 个物品，建出博弈图后是 DAG，也就是每一堆都是一个有向图游戏，整个 Nim 游戏就包含 $n$ 个有向图游戏的一个组合游戏。显然一个有 $x$ 个物品的状态 $\text{SG}$ 值为 $x$，整个游戏的 $\text{SG}$ 值为 $a_1 \oplus a_2 \oplus \dots \oplus a_n$。当且仅当物品数量异或和不为 $0$ 时先手必胜。</p>
<h4 id="反-Nim-游戏"><a href="#反-Nim-游戏" class="headerlink" title="反 Nim 游戏"></a>反 Nim 游戏</h4><p>$n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取，取走最后一个物品的人失败。</p>
<p>虽然看起来不符合公平组合游戏的条件，但是只需要每个结束状态后再接一个状态即可。</p>
<p>结论：</p>
<ol>
<li><p>所有堆的物品数都为 $1$ 且物品数的异或和为 $0$。</p>
</li>
<li><p>存在堆的物品数大于 $1$ 且物品数的异或和不为 $0$。</p>
</li>
</ol>
<h4 id="k-Nim-游戏"><a href="#k-Nim-游戏" class="headerlink" title="k-Nim 游戏"></a>k-Nim 游戏</h4><p>$n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意 $k$ 堆的任意个物品，但每一堆至少取 $1$ 个，取走最后一个物品的人获胜。</p>
<p>结论：当在二进制下，对于每一位，$a_i$ 在这一位为 $1$ 的个数都 $\bmod (k+1) &#x3D; 0$ 时先手必败，否则先手必胜。</p>
<h4 id="阶梯-Nim-游戏"><a href="#阶梯-Nim-游戏" class="headerlink" title="阶梯 Nim 游戏"></a>阶梯 Nim 游戏</h4><p>$n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流把任意一堆的任意个物品移动到左边一堆，但不能不移动，无法移动的人失败。</p>
<p>结论：对奇数层的石子个数进行 Nim 博弈，算出异或和的值，若非 $0$，先手必胜，否则先手必败。</p>
<h4 id="Muti-Nim-游戏"><a href="#Muti-Nim-游戏" class="headerlink" title="Muti-Nim 游戏"></a>Muti-Nim 游戏</h4><p>$n$ 堆物品，每堆有 $a_i$ 个，两个玩家轮流取走任意一堆的任意个物品，但不能不取，或者把一堆物品分成两堆数量不为 $0$ 的物品，无法操作的人失败。</p>
<p>实际上每次分裂都是把一个子游戏分成了两个子游戏，$\text{SG}$ 值也就是两个子游戏的异或和。</p>
<p>结论：</p>

$$
\text{SG}(x)=
\left\{
\begin{aligned}
x-1 \ \ \ \ x \equiv 0 \pmod 4\\
x \ \ \ \ x \equiv 1,2 \pmod 4\\
x+1 \ \ \ \ x \equiv 3 \pmod 4
\end{aligned}
\right.
$$
]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI 联合省选 2023 游记</title>
    <url>/post/NOI-united-province-election-2023-travels/</url>
    <content><![CDATA[<p>寄麻了，退役。</p>
<p>坐标 SC，NOIP 125。</p>
<h2 id="Day-4-sim-0"><a href="#Day-4-sim-0" class="headerlink" title="Day -4 $\sim$ 0"></a>Day -4 $\sim$ 0</h2><p>省选要来了，很慌。</p>
<p>开始打各种板子。</p>
<p>星期四上午“全真模拟”直接变成省选信心打击赛，我 T1 连简单的倍增都不会，成功垫底。</p>
<p>中午 ygg 直接放了，但是我家长没来，在学校呆到星期五下午我才去酒店。</p>
<p>到了酒店啥都不想干，直接开颓。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>慌。</p>
<p>虽然我声称了我考试时不吃东西，但爸妈非给我塞了个面包。</p>
<p>来的比较早，在 ygg 面前站了 5 分钟不知道干啥。</p>
<p>考场居然不能带吃的，要吃得出去吃，不好评价。</p>
<p>进考场一看键盘，又是阴间布局，Enter 占了反斜杠的位置，反斜杠在 backspace 左边，backspace 只有一半大。正在调各种设置，监考员又在怒斥怎么到处都是鼠标声，《别让我抓到你在敲板哈》。</p>
<p>开考直接看 T1，一眼，排个序贪心一下就完了，20 分钟切了。看 T2，没啥思路。随手画了个图，发现要保证选的点切断边后不连通，一个点双上的点只有不选、选一个和全选合法。建广义圆方树，设一个方点被选了当且仅当周围所有圆点选了，那么选出来的点在树上形成一个连通块。考虑钦定一个圆点被选择了，进行树形 dp，在之后的计算中钦定这个点不能被选。先枚举连通块大小，然后用背包算出有多少种方案，总共 $n^4$，$35$ 分。实在不会优化，先敲 T3 暴力去了。考虑每次暴力求，从下往上选，把当前元素填到子树内最小的位置即可，按 dfn 序拍到线段树上维护。$nq \log$ 有 $48$ 分，打完跑路。然后回去优化 T2，搞了一个小时，最后套个点分治变成 $n \log n$ 乘子树大小和，$35 \sim 65$ 分。最后半个小时想继续搞 T3 没搞出来，NOI Linux 下检查编译，检查空间，检查 <code>freopen</code>，虽然考过这么多次了，但是马上收卷的时候依然很怕出傻逼错误。</p>
<p>考完遇到 <a href="https://www.cnblogs.com/Feyn/">zc</a> 和 <a href="https://star-32.github.io/">lyh</a>，<a href="https://star-32.github.io/">lyh</a> T2 只有 $2^m$ 的十分。<a href="https://www.cnblogs.com/Feyn/">zc</a> 差点切 T2，但他声称没调出来，T3 也没打暴力，但按照经验，他该切了 T2。听了思路，好像很有道理，但是又不完全懂。出来给 ygg 报的 $170$。</p>
<p>在 luogu 上看到 T2 解法，原来有个傻逼结论，子树大小小于 $l$ 的一定要选，大于等于 $r$ 的一定不选，正确性显然。这么傻逼的结论居然没想到，像被撅了一样。</p>
<p>T3 好像是线段树分治套树剖或全局平衡二叉树之类的，反正我不会。</p>
<p>出代码后拍了一下 T2，居然和 SC-001 和 SC-002 都不一样，慌麻了，但看了他们的代码应该是没有写 $n \leq 200$。<a href="https://www.cnblogs.com/Feyn/">zc</a> 和暴力拍出错了，看来真挂了，太可惜了，他实力很强的。</p>
<p>云斗学院 T1 T3 T2 数据先后出了，$100 + 65 +48$，没有挂分，主要看 T2 有多少链的数据，如果挂的不多还有可能翻盘。<a href="https://www.cnblogs.com/Feyn/">zc</a> $105$，<a href="https://star-32.github.io/">lyh</a> $158$。</p>
<p>看了一些游记，T3 暴力居然都搞的很复杂，有点怕，再次验证了一下 T3 暴力正确性。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>早上大图灵出数据了，$100 + 55 + 48$，省排 8，还行。<a href="https://www.cnblogs.com/Feyn/">zc</a> $140$，<a href="https://star-32.github.io/">lyh</a> $183$，假的 dp 都水了这么多分。</p>
<p>开考看 T1，好像对抗搜索，但是应该过不了，T2 应该是奇怪的图论，T3 应该是奇怪的计数 dp。先搞 T1，结果忘了对抗搜索怎么写了，记忆化没有加时间，还判了重，样例都要 WA，调了半天，才发现完全是假的。当时已经过去了 1.5h，很慌，怎么也想不起真的对抗搜索怎么写了，最后改成平局不记忆化的爆搜才没有 WA，但是几十步的样例都跑不过，搞完已经 3h 多了。T2 暴力 $20$，还有几十分特殊性质 ABCD，我只会 $n \leq 200$ 的 ABC，总共 $12$ 分，没写。T3 写了个 $10$ 分暴力。然后又来检查一系列东西，但是我预计今天连 $100$ 都没有，直接开摆。</p>
<p>出考场翻以前代码才记起对抗搜索怎么写，而且 ygg 还专门讲过对抗搜索，寄麻。<a href="https://star-32.github.io/">lyh</a> T2 还写了 $32$ 分的特殊性质 ABC，写的是网络流，我才想起可以用网络流写。</p>
<p>下午坐车回绵阳。路上一直很慌，害怕对抗搜索能过 T1，白丢四十多分。云斗学院 T1 出了数据一测，我 T1 $50$，正常的对抗搜索 $65$，问题不大。<a href="https://www.cnblogs.com/Feyn/">zc</a>  T1 好像挂了，只有 $35$。测了一下其他人的，好多都过了 T1，但也有不少五六十的，心里算是有了底。T2 马上也出了，我和 <a href="https://www.cnblogs.com/Feyn/">zc</a> 都是 $20$，<a href="https://star-32.github.io/">lyh</a> T2 的 $n \leq 200000$ 的特殊性质全 T 了，只有 $32$ 分。寄老师 T1T2 都切了，拜谢。</p>
<p>晚上出了 T3，我还是没挂分，但是 <a href="https://star-32.github.io/">lyh</a> 挂了。T1 数据更新又给我搞回 $65$ 了，离大谱。</p>
<p>Day2 寄麻了，应该人均会 T1，还有不少人会 T2，我 $100$ 分都上不了，应该是寄了。</p>
<p>估分 $100 + [35,65] + 48 + [55,65] + 20 + 10 &#x3D; [268,308]$。</p>
<h2 id="Day-3-sim-5"><a href="#Day-3-sim-5" class="headerlink" title="Day 3 $\sim$ 5"></a>Day 3 $\sim$ 5</h2><p>ygg 给我们放假，颓。</p>
<p>云斗学院 $100 + 65 + 48 + 65 + 20 + 10 &#x3D; 308$，数据强度应该不行，CCF 的数据可能会很强。</p>
<p>大图灵 D1T2 之前还是 $55$ 后面变成 $65$ 了，数据强度越改越弱是吧。总分 $100 + 65 + 48 + 55 + 20 + 10 &#x3D; 298$。</p>
<p>希望能进吧。</p>
<h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h2><p>出分了</p>
<p>D2T1 挂成 $30$ 了，被极限强数据卡没了。</p>
<p>$100 + 65 + 48 + 30 + 20 + 10 &#x3D; 273$</p>
<p>Day2 4 个小时爆切 $60$ 分。</p>
<p>好，退役。</p>
<p>把 D2T1 改了一哈，才发现红棋相遇是不能走，我以为是相遇了然后输，这样算出来步数就要多一步，寄。</p>
<p>ygg 给了校榜，刚好卡到 12 名，哈人，险进。但是看起来连 SC 榜都上不了，寄。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 775 A ~ D 题解</title>
    <url>/post/CF1338-solution/</url>
    <content><![CDATA[<h2 id="A-Powered-Addition"><a href="#A-Powered-Addition" class="headerlink" title="A. Powered Addition"></a>A. Powered Addition</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 $a$，选定一个 $x$，给 $a_i$ 加上 $[0,2^x-1]$ 范围内的数，要使最后 $a$ 单调不降，求最小的 $x$。</p>
<p>$n \leq 10^5$</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>考虑找到 $a_i-a_j(i&lt;j)$ 的最大值，显然 $[i+1,n]$ 中的数都不比 $a_j$ 小，$[1,j-1]$ 的数也都不比 $a_i$ 大，需要加的数不超过 $a_j-a_i$，其他数也不会影响这对数，所以要加的最大的数就是 $a_i-a_j(i&lt;j)$ 的最大值。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="type">int</span> w=<span class="number">-1e9</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            s=<span class="built_in">max</span>(s,w-a[i]);</span><br><span class="line">            w=<span class="built_in">max</span>(w,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s) ++t,s/=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="B-Edge-Weight-Assignment"><a href="#B-Edge-Weight-Assignment" class="headerlink" title="B. Edge Weight Assignment"></a>B. Edge Weight Assignment</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>有一棵树，需要给每条边赋正整数权值，使得任意两个叶子的路径上边权异或和为 $0$。</p>
<p>$3 \leq n \leq 10^5$</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>对于任意一个点，到所有叶子的路径权值相等。</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>先看最小值，我们尝试把所有边权值都赋成 $x$，可以发现不合法当且仅当有两个叶子之间有奇数条边。我们可以再加入两个权值 $y,z$ 满足 $y \oplus z &#x3D; x$，这样三条边权值异或就可以等于 $0$ 了。因为 $n \geq 3$，所以不存在两个叶子之间只有一条边，任意奇数路径至少有三条边，即有奇数路径最小值为 $3$，否则为 $1$。</p>
<p>再看最大值。任意找一个非叶子点，我们要保证这个点到所有叶子路径权值相等，设为 $x$，如果路径上只有一条边，这条边权值就只能是 $x$；否则我们有无穷多种选择来得到 $x$，这些边和其他边的权值就能保证不同。即一个点到多个叶子路径上都只有一条边，这些边权值一定相同。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,t[N],l[N],f[N];</span><br><span class="line"><span class="type">bool</span> u,v;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">road</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">&#125;a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l[x]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w%<span class="number">2</span>==<span class="number">0</span>) u=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> v=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(a[i].m,x,w^<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(x,y);</span><br><span class="line">        <span class="built_in">road</span>(y,x);</span><br><span class="line">        ++l[x],++l[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(u&amp;&amp;v) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l[i]!=<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t[i];j!=<span class="number">0</span>;j=a[j].q) ++f[a[j].m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;<span class="number">1</span>) s+=f[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n-s<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="C-Perfect-Triples"><a href="#C-Perfect-Triples" class="headerlink" title="C. Perfect Triples"></a>C. Perfect Triples</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>有一个序列 $s$，初始为空，你需要找到字典序最小的三元组 $(a,b,c)$ 满足 $a,b,c&gt;0,a \oplus b \oplus c &#x3D; 0$ 且 $a,b,c$ 没有在 $s$ 中出现过，将 $a,b,c$ 依次加入 $s$。$t$ 次询问，求 $s$ 中第 $n$ 个元素。</p>
<p>$1 \leq n \leq 10^{16},t \leq 10^5$</p>
<h3 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h3><p>可以打表找规律。</p>

<details class="hcb-content box hcbnote">
  <summary><i class="fa fa-pen fa-fw"></i>note<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 8 12</span><br><span class="line">5 10 15</span><br><span class="line">6 11 13</span><br><span class="line">7 9 14</span><br><span class="line">16 32 48</span><br><span class="line">17 34 51</span><br><span class="line">18 35 49</span><br><span class="line">19 33 50</span><br><span class="line">20 40 60</span><br><span class="line">21 42 63</span><br><span class="line">22 43 61</span><br><span class="line">23 41 62</span><br><span class="line">24 44 52</span><br><span class="line">25 46 55</span><br><span class="line">26 47 53</span><br><span class="line">27 45 54</span><br><span class="line">28 36 56</span><br><span class="line">29 38 59</span><br><span class="line">30 39 57</span><br><span class="line">31 37 58</span><br></pre></td></tr></table></figure>
</details>


<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>我场上打表找的规律。</p>
<p>首先可以发现，大体可以分成 $1,[2,5],[6,21],\dots$，也就是第一组 $1$ 个，第二组 $4$ 个，第三组 $16$ 个。</p>
<p>第 $i$ 组中，$a$ 范围是 $[4^{i-1},2 \times 4^{i-1}-1]$，$b$ 范围是 $[2 \times 4^{i-1},3 \times 4^{i-1}-1]$，$c$ 范围是 $[3 \times 4^{i-1},4^i-1]$。$a$ 显然是递增的。观察 $b$，第二组中 $b$ 的第二个数 $9$ 被移到了最后，第三组中每四个数都是第二个数移到最后，同时第二个四个数也移到了整体的最后。然后不难发现 $c$ 就是把第四个数移到了第二个。</p>
<p>看了题解，可以发现这些数写成四进制后每一位都是 $(0,0,0),(1,2,3),(2,3,1),(3,1,2)$，因为 $1,2,3$ 两两异或等于另一个。</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">solve1</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;x) n-=x,x*=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> x+n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum2</span><span class="params">(ll n,ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    t/=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=t) <span class="keyword">return</span> <span class="built_in">sum2</span>(n,t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=t*<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">sum2</span>(n-t,t)+t*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=t*<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">sum2</span>(n-t*<span class="number">2</span>,t)+t*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sum2</span>(n-t*<span class="number">3</span>,t)+t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve2</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;x) n-=x,x*=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>+<span class="built_in">sum2</span>(n,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum3</span><span class="params">(ll n,ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    t/=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=t) <span class="keyword">return</span> <span class="built_in">sum3</span>(n,t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=t*<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">sum3</span>(n-t,t)+t*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=t*<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">sum3</span>(n-t*<span class="number">2</span>,t)+t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sum3</span>(n-t*<span class="number">3</span>,t)+t*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve3</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;x) n-=x,x*=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">3</span>+<span class="built_in">sum3</span>(n,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve1</span>((x+<span class="number">2</span>)/<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve2</span>((x+<span class="number">2</span>)/<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve3</span>((x+<span class="number">2</span>)/<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="D-Nested-Rubber-Bands"><a href="#D-Nested-Rubber-Bands" class="headerlink" title="D. Nested Rubber Bands"></a>D. Nested Rubber Bands</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一棵树，把每个点变成平面上一个不自交的环，两个环相交当且仅当两个点之间存在边。如果一个环被完全包含在另一个环中，这个环就嵌套在另一个环中，求最多可以嵌套多少层。</p>
<h3 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h3><p>有边连接的两个环一定不能嵌套，同一个父亲的环可以嵌套在一起。</p>
<p><img src="/post-images/CF1338-solution-1.png?500x" alt="1"></p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>如上图，我们可以发现，只有当前在最里面的环能够继续嵌套，一个红色环伸出来的环只有一个黑色环，其他只能作为蓝色环，无法延伸。红色环和黑色环就形成了一条链，而黑色环之间不能相邻，也不能和蓝色环相邻。也就是说，我们要在树上选一条链，在这条链和与这条链相邻的点中找最大独立集。</p>
<p>设 $f_{x,0}$ 为 $x$ 不在独立集中子树的方案，$f_{x,1}$ 为 $x$ 在独立集中子树的答案，这里 $x$ 为选出的链的一个端点。转移时注意只能选一个子树转移，所以是子树取 $\max$，然后以这个点为链的转折点更新答案，更新时注意处理其他儿子即可。详见代码。</p>

<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,p=<span class="number">1</span>,t[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">road</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">&#125;a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==fa) <span class="keyword">continue</span>;</span><br><span class="line">        ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(a[i].m,x);</span><br><span class="line">        s=<span class="built_in">max</span>(s,f[x][<span class="number">0</span>]+<span class="built_in">max</span>(f[a[i].m][<span class="number">0</span>],f[a[i].m][<span class="number">1</span>])+(w<span class="number">-2</span>)+(fa!=<span class="number">0</span>));</span><br><span class="line">        s=<span class="built_in">max</span>(s,f[x][<span class="number">1</span>]+f[a[i].m][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        f[x][<span class="number">0</span>]=<span class="built_in">max</span>(f[x][<span class="number">0</span>],<span class="built_in">max</span>(f[a[i].m][<span class="number">0</span>],f[a[i].m][<span class="number">1</span>]));</span><br><span class="line">        f[x][<span class="number">1</span>]=<span class="built_in">max</span>(f[x][<span class="number">1</span>],f[a[i].m][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>]+=w<span class="number">-1</span>;</span><br><span class="line">    f[x][<span class="number">1</span>]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(x,y);</span><br><span class="line">        <span class="built_in">road</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1776C 题解</title>
    <url>/post/CF1776C-solution/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 $m$ 的序列，以及大小为 $n$ 的可重集。两个人依次进行操作：先手在可重集中选择一个数 $L$，再在序列上选择一段长度为 $L$ 的区间，满足区间内的所有位置均未被标记，然后从可重集重删除 $L$；后手在先手上一次选择的区间中选择一个位置并进行标记。如果先手无法选择一个合法的区间则失败，把可重集删完则获胜，求最终谁会获胜，并与交互库模拟这个过程。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>先考虑先手如何操作。我们可以考虑一个贪心策略，把区间长度从大到小排序，每次尝试放置最长的区间，并找到可以放置的间隔最小的两个标记位置中间放置。</p>
<p>考虑后手。后手进行标记的最终目的是让对方有一个区间放不进去，我们可以枚举这个区间的长度 $x$，显然在 $x$ 的倍数位置标记是最优方案。如果当前先手选的区间包含了 $x$ 的整数倍位置，那么就标记这个位置，否则这个区间长度小于 $x$，任意放置。</p>
<p>我们可以发现能标记 $x$ 整数倍位置的个数就是已选择区间中长度大于 $x$ 的区间个数，而使得长度大于等于 $x$ 的区间无法放置至少需要标记 $\lfloor \frac{m}{x} \rfloor$ 个，所以只需要判断长度大于等于 $x$ 的区间个数即可。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n,m,t,a[N];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n/a[i]&lt;=m-i)</span><br><span class="line">        &#123;</span><br><span class="line">            t=a[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">solve1</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[p]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">1e9</span>,z=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(z&gt;=a[m]&amp;&amp;z&lt;y) x=i-z,y=z;</span><br><span class="line">            z=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ++z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(z&gt;=a[m]&amp;&amp;z&lt;y-x+<span class="number">1</span>) x=n-z+<span class="number">1</span>,y=z;</span><br><span class="line">    --m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(x,x+a[m+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --m;</span><br><span class="line">    <span class="type">int</span> x=z.first,y=z.second;</span><br><span class="line">    <span class="keyword">if</span>(y-x+<span class="number">1</span>&lt;t) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alessia\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; z=<span class="built_in">solve1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,z.second-z.first+<span class="number">1</span>,z.first);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="keyword">while</span>(m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; z=<span class="built_in">solve1</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,z.second-z.first+<span class="number">1</span>,z.first);</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bernardo\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="keyword">while</span>(m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve2</span>(<span class="built_in">make_pair</span>(y,y+x<span class="number">-1</span>)));</span><br><span class="line">            <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>




]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 775 A ~ D 题解</title>
    <url>/post/CF1648-solution/</url>
    <content><![CDATA[<h2 id="A-Weird-Sum"><a href="#A-Weird-Sum" class="headerlink" title="A. Weird Sum"></a>A. Weird Sum</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $m \times n$ 的矩阵，求任意一对值相同的元素的曼哈顿距离和。</p>
<p>$m \times n \leq 10^5$</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>枚举值，取出所有这个值的元素，用 vector 记录即可。$x$ 从小到大扫描，依次加入元素，用树状数组维护当前元素和前面所有的和。具体的，树状数组以 $y$ 为下标，分别记录元素个数、$y$ 坐标加 $x$ 坐标、$y$ 坐标减 $x$ 坐标，分别计算 $y$ 坐标比当前元素小的和大的贡献。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">ll T1[N],T2[N],T3[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll *T,<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n) T[x]+=k,x+=x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll *T,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>) s+=T[x],x-=x&amp;-x;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">str</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">str</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;str&gt; a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(<span class="built_in">str</span>(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s+=<span class="built_in">sum</span>(T1,j.y)*(j.x+j.y)-<span class="built_in">sum</span>(T2,j.y);</span><br><span class="line">            s+=(<span class="built_in">sum</span>(T3,n)-<span class="built_in">sum</span>(T3,j.y))-(<span class="built_in">sum</span>(T1,n)-<span class="built_in">sum</span>(T1,j.y))*(j.y-j.x);</span><br><span class="line">            <span class="built_in">add</span>(T1,j.y,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(T2,j.y,j.y+j.x);</span><br><span class="line">            <span class="built_in">add</span>(T3,j.y,j.y-j.x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(T1,j.y,<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">add</span>(T2,j.y,-(j.y+j.x));</span><br><span class="line">            <span class="built_in">add</span>(T3,j.y,-(j.y-j.x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="B-Integral-Array"><a href="#B-Integral-Array" class="headerlink" title="B. Integral Array"></a>B. Integral Array</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组 $a$，求是否对于任意 $a$ 中的两个元素 $x,y,x \geq y$，$\lfloor \frac{x}{y} \rfloor$ 都出现在数组中。</p>
<p>$n \leq 10^6,1 \leq a_i \leq 10^6$</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>考虑枚举没有出现在数组中的数 $z$，如果数组中存在 $x,y,x \geq y$ 满足 $\lfloor \frac{x}{y} \rfloor &#x3D; z$，这个数组就不不合法。考虑枚举 $y$，判断是否存在  $x \in [yz,(y+1)z-1]$ 即可。由于 $1 \leq y \leq \lfloor \frac{x}{z} \rfloor$，所以 $y$ 的总个数是调和级数。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) b[i]=c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            ++b[a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) c[i]=c[i<span class="number">-1</span>]+b[i];</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]!=<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m/i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j]&amp;&amp;c[<span class="built_in">min</span>(j*(i+<span class="number">1</span>)<span class="number">-1</span>,m)]-c[j*i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    u=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="C-Tyler-and-Strings"><a href="#C-Tyler-and-Strings" class="headerlink" title="C. Tyler and Strings"></a>C. Tyler and Strings</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串 $s$ 和 $t$，求重排 $s$ 后有多少种情况 $s$ 的字典序小于 $t$。</p>
<p>$|s|,|t| \leq 2 \times 10^5$，字符集 $2 \times 10^5$。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>枚举 $s$ 第一个比 $t$ 小的地方 $i$，$[1,i-1]$ 的部分 $s$ 和 $t$ 一定相同，如果无法满足情况数为 $0$，下面讨论的情况已钦定此条件满足。如果能够只需要满足 $s_i &lt; t_i$，后面任意。假如我们钦定了 $i$ 选什么，后面的总情况就是 $w&#x3D;(\sum a_j)! \prod (a_j!)^{-1}$，$a_i$ 为字符 $i$ 剩下的个数。考虑上 $s_i$，选定 $s_i$ 的影响就是 $a_{s_i}$ 减 $1$，总情况变为 $w&#x3D;((\sum a_j)-1)! \prod ((a_j-[j&#x3D;s_i])!)^{-1}$，可以发现对于不同的 $s_i$，变化的项只有 $1$ 个，我们令 $w’&#x3D;((\sum a_j)-1)! \prod (a_j!)^{-1}$，选定 $s_i$ 的贡献即为 $w&#x3D;w’\times (a_j!) \times ((a_j-1)!)^{-1}$，我们只需要统计后面这一块的和 $t$ 即可，用树状数组维护。</p>
<p>$i$ 每向后移动一位，$a_{s_{i-1}}$ 都会减少 $1$，$w$ 和 $t$ 也会相应改变，但是每次只改变一项，直接维护即可。</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">const</span> ll P=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> m,n,a[N],b[N],h[N];</span><br><span class="line">ll jc[N],T[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">exgcd</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,P,x,y);</span><br><span class="line">    x=(x%P+P)%P;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=<span class="number">200000</span>) T[x]+=k,x+=x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>) s+=T[x],x-=x&amp;-x;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;++i) jc[i]=(jc[i<span class="number">-1</span>]*i)%P;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        ++a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w=jc[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i,jc[a[i]]*<span class="built_in">inv</span>(jc[a[i]<span class="number">-1</span>])%P);</span><br><span class="line">            w=w*<span class="built_in">inv</span>(jc[a[i]])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(m,n);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        w=w*<span class="built_in">inv</span>(jc[m-i+<span class="number">1</span>])%P*jc[m-i]%P;</span><br><span class="line">        s=(s+w*<span class="built_in">sum</span>(b[i]<span class="number">-1</span>)%P)%P;</span><br><span class="line">        <span class="keyword">if</span>(a[b[i]]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w=w*jc[a[b[i]]]%P;</span><br><span class="line">            <span class="built_in">add</span>(b[i],-(jc[a[b[i]]]*<span class="built_in">inv</span>(jc[a[b[i]]<span class="number">-1</span>])%P));</span><br><span class="line">            --a[b[i]];</span><br><span class="line">            <span class="keyword">if</span>(a[b[i]]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(b[i],jc[a[b[i]]]*<span class="built_in">inv</span>(jc[a[b[i]]<span class="number">-1</span>])%P);</span><br><span class="line">                w=w*<span class="built_in">inv</span>(jc[a[b[i]]])%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            w=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;n&amp;&amp;w!=<span class="number">0</span>) s=(s+<span class="number">1</span>)%P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="D-Serious-Business"><a href="#D-Serious-Business" class="headerlink" title="D. Serious Business"></a>D. Serious Business</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $3 \times n$ 的矩阵，每个位置有一个值。第一行和第三行可以走，第二行不可以。共有 $q$ 个操作，第 $i$ 个操作可以用 $k_i$ 的代价把第二行 $[l_i,r_i]$ 变为可以走，求经过的位置的价值和减去总代价的最大值。</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>显然在第二行经过的位置是一段连续的区间，所以选择的操作的区间也是连续的，且除了第一段和最后一段区间之外全部会走满。我们把总价值拆成两部分：$a_l-b_{l-1}$ 与 $b_r+(c_n-c_{r-1})$，其中 $a,b,c$ 分别是三行的价值， $l,r$ 是进入和离开第二行的位置。我们考虑把第一部分贡献转移到最后一段区间：首先把 $a_j-b_{j-1}$ 转移到 $f_j$，由于第一个和中间的区间都是走到了区间末尾的，所以区间 $i$ 的贡献就是把 $\max\limits_{l_i \leq j \leq r_i} f_j-k_i$ 贡献到 $f_{r_i}$。用线段树维护。</p>
<p>然后我们需要把在同一个区间的两种贡献合并，也就是对于区间 $i$，对于任意 $j,p \in [l_i,r_i],j \leq p$，把 $f_j + b_p+(c_n-c_{p-1}) -p_i$ 贡献到总答案。这里需要保证 $j \leq p$，也可以用线段树维护，每次把左子树最大的 $f_j$ 和右子树最大的 $b_p+(c_p-c_{p-1})$ 相加贡献到答案即可。</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N],b[N],c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,k;</span><br><span class="line">    <span class="built_in">str</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">str</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y),<span class="built_in">k</span>(k)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;str&gt; d[N],e;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll s,t1,t2,s2;</span><br><span class="line">&#125;T[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(tree &amp;T,tree T1,tree T2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T.s=<span class="built_in">max</span>(T1.s,T2.s);</span><br><span class="line">    T.s2=<span class="built_in">max</span>(T1.t1+T2.t2,<span class="built_in">max</span>(T1.s2,T2.s2));</span><br><span class="line">    T.t1=<span class="built_in">max</span>(T1.t1,T2.t1);</span><br><span class="line">    T.t2=<span class="built_in">max</span>(T1.t2,T2.t2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].l=l;</span><br><span class="line">    T[x].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].s=a[l]-b[l<span class="number">-1</span>];</span><br><span class="line">        T[x].t1=a[l]-b[l<span class="number">-1</span>];</span><br><span class="line">        T[x].t2=b[l]+(c[n]-c[l<span class="number">-1</span>]);</span><br><span class="line">        T[x].s2=T[x].t1+T[x].t2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(T[x],T[x&lt;&lt;<span class="number">1</span>],T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> q,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].l==T[x].r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].s=<span class="built_in">max</span>(T[x].s,k);</span><br><span class="line">        T[x].t1=<span class="built_in">max</span>(T[x].t1,k);</span><br><span class="line">        T[x].s2=T[x].t1+T[x].t2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=T[x].l+T[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=z) <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,q,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,q,k);</span><br><span class="line">    <span class="built_in">pushup</span>(T[x],T[x&lt;&lt;<span class="number">1</span>],T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].l&gt;=l&amp;&amp;T[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> T[x].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=T[x].l+T[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll s=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=z) s=<span class="built_in">max</span>(s,<span class="built_in">sum</span>(x&lt;&lt;<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;z) s=<span class="built_in">max</span>(s,<span class="built_in">sum</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tree <span class="title">sum2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].l&gt;=l&amp;&amp;T[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> T[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=T[x].l+T[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree s;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=z&amp;&amp;(!(r&gt;z))) s=<span class="built_in">sum2</span>(x&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((!(l&lt;=z))&amp;&amp;r&gt;z) s=<span class="built_in">sum2</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">pushup</span>(s,<span class="built_in">sum2</span>(x&lt;&lt;<span class="number">1</span>,l,r),<span class="built_in">sum2</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">        b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;c[i]);</span><br><span class="line">        c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">        d[y].<span class="built_in">push_back</span>(<span class="built_in">str</span>(x,y,k));</span><br><span class="line">        e.<span class="built_in">push_back</span>(<span class="built_in">str</span>(x,y,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll s=<span class="number">-1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            s=<span class="built_in">max</span>(s,<span class="built_in">sum</span>(<span class="number">1</span>,j.x,j.y)-j.k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n) <span class="built_in">add</span>(<span class="number">1</span>,i+<span class="number">1</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="built_in">max</span>(s,<span class="built_in">sum2</span>(<span class="number">1</span>,i.x,i.y).s2-i.k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 692 A ~ C 题解</title>
    <url>/post/CF1464-solution/</url>
    <content><![CDATA[<h2 id="A-Peaceful-Rooks"><a href="#A-Peaceful-Rooks" class="headerlink" title="A. Peaceful Rooks"></a>A. Peaceful Rooks</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个 $n \times n$ 的棋盘和 $m$ 个棋子，任意两个棋子不在同一行或同一列。每次可以水平或竖直移动一个棋子，且移动后仍然任意两个棋子不在同一行或同一列，求把所有棋子移动到主对角线上所需的最少次数。</p>
<p>$n \leq 10^5$</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>假设我们现在想把在 $(x,y)$ 的棋子移动到 $(x,x)$，如果 $x$ 列上有棋子 $(z,x)$，我们就需要先移走这个棋子，显然可以直接尝试移动到 $(z,z)$。棋子的支配关系会形成一些链或环，链所需步数就是棋子个数，环所需步数是个数 $+1$，并查集统计即可。注意判断本来就在对角线上的棋子。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[N];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(x!=y) ++s;</span><br><span class="line">            <span class="keyword">else</span> fa[x]=<span class="number">0</span>;</span><br><span class="line">            fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i)==i) ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s-(n-m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="B-Grime-Zoo"><a href="#B-Grime-Zoo" class="headerlink" title="B. Grime Zoo"></a>B. Grime Zoo</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个由 <code>0</code>、<code>1</code> 和 <code>?</code> 组成的字符串 $S$ 和参数 $x,y$，你需要在所有字符为 <code>?</code> 的位置填入字符 <code>0</code> 或者 <code>1</code>。</p>
<p>我们规定这个字符串的价值为：<code>01</code> 子序列的数量 $\times x + $ <code>10</code> 子序列的数量 $\times y$。</p>
<p>求字符串价值最小值。</p>
<p>$|S| \leq 10^5,0 \leq x,y \leq 10^6$</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>对于一个 <code>?</code>，如果填 <code>0</code>，贡献为 $y \times $ 前面 $1$ 的个数 $+$ $x \times $ 后面 $1$ 的个数，填 <code>1</code> 的贡献为 $x \times $ 前面 $0$ 的个数 $+$ $y \times $ 后面 $0$ 的个数。由于越靠后的 <code>?</code>，前面的 <code>0</code> 和 <code>1</code> 个数单调不降，后面的 <code>0</code> 和 <code>1</code> 个数单调不增，所以只可能是 <code>00..11</code> 或 <code>11..00</code> 的情况。</p>
<p>假定是 <code>00..11</code> 的情况，我们可以先算出全部填 <code>1</code> 的价值，然后从前往后把 <code>?</code> 变为 <code>0</code>，每次处理变化的贡献即可。<code>11..00</code> 的情况同理。</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,b1[N],b2[N],b3[N],c1[N],c2[N],c3[N];</span><br><span class="line">ll k1,k2;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld%lld&quot;</span>,a+<span class="number">1</span>,&amp;k1,&amp;k2);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b1[i]=b1[i<span class="number">-1</span>];</span><br><span class="line">        b2[i]=b2[i<span class="number">-1</span>];</span><br><span class="line">        b3[i]=b3[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span>) ++b1[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;1&#x27;</span>) ++b2[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;?&#x27;</span>) ++b3[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        c1[i]=c1[i+<span class="number">1</span>];</span><br><span class="line">        c2[i]=c2[i+<span class="number">1</span>];</span><br><span class="line">        c3[i]=c3[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span>) ++c1[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;1&#x27;</span>) ++c2[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;?&#x27;</span>) ++c3[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span>) w+=(b2[i<span class="number">-1</span>]+b3[i<span class="number">-1</span>])*k2;</span><br><span class="line">        <span class="keyword">else</span> w+=b1[i<span class="number">-1</span>]*k1;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w-=(b1[i<span class="number">-1</span>]+b3[i<span class="number">-1</span>])*k1+c1[i+<span class="number">1</span>]*k2;</span><br><span class="line">            w+=b2[i<span class="number">-1</span>]*k2+(c2[i+<span class="number">1</span>]+c3[i+<span class="number">1</span>])*k1;</span><br><span class="line">        &#125;</span><br><span class="line">        s=<span class="built_in">min</span>(s,w);</span><br><span class="line">    &#125;</span><br><span class="line">    w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span>||a[i]==<span class="string">&#x27;?&#x27;</span>) w+=b2[i<span class="number">-1</span>]*k2;</span><br><span class="line">        <span class="keyword">else</span> w+=(b1[i<span class="number">-1</span>]+b3[i<span class="number">-1</span>])*k1;</span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="built_in">min</span>(s,w);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w-=(b2[i<span class="number">-1</span>]+b3[i<span class="number">-1</span>])*k2+c2[i+<span class="number">1</span>]*k1;</span><br><span class="line">            w+=b1[i<span class="number">-1</span>]*k1+(c1[i+<span class="number">1</span>]+c3[i+<span class="number">1</span>])*k2;</span><br><span class="line">        &#125;</span><br><span class="line">        s=<span class="built_in">min</span>(s,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<h2 id="C-Poman-Numbers"><a href="#C-Poman-Numbers" class="headerlink" title="C. Poman Numbers"></a>C. Poman Numbers</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个只含小写字母的字符串 $S$。</p>
<p>定义 $f(S)$。如果 $|S|&#x3D;1$，设这个小写字母的是第 $t$ 个（<code>a</code> 为 $0$，<code>b</code> 为 $1$，<code>z</code> 为 $25$），$f(S)&#x3D;2^t$。否则 $f(S)&#x3D;-f(S[1,m])+f(S[m+1,|S|])$，$m$ 在 $[1,|S|-1]$ 中自由选择。</p>
<p>求是否存在一种构造 $m$ 的方案（每一步的 $m$ 可以不同）使得 $f(S)&#x3D;T$。</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>我们观察 $S$ 每一位最后可能的符号。首先最后一位在每一步中都是 $+$，所以符号一定是 $+$。倒数第二位后面只有一位，所有只可能有一次 $-$，最终符号一定是 $-$。倒数第三位就两种均可，我们可以猜测除了最后两位位符号任取。</p>
<p>我们先把最后两位的贡献在 $T$ 中减去，接下来就是给一些 $2$ 的次幂定符号，使得和为 $T$。我们从大到小排序，当前的数是 $x$，剩下的数的和 $T’&lt; 0$，$+x$ 一定比 $-x$ 更优，因为如果 $-x$ 后仍然能使最后 $T’ &#x3D; 0$，又因为是 $2$ 的次幂，所以后面的数一定可以拼出 $x$，$+x$ 也有解。同理 $T’&gt;0$ 则 $-x$。</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll k;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%s&quot;</span>,&amp;n,&amp;k,a+<span class="number">1</span>);</span><br><span class="line">    k+=(<span class="number">1ll</span>&lt;&lt;(a[n<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>))-(<span class="number">1ll</span>&lt;&lt;(a[n]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) k+=(<span class="number">1ll</span>&lt;&lt;(a[i]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        <span class="keyword">else</span> k-=(<span class="number">1ll</span>&lt;&lt;(a[i]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI 2023 春季测试 T4 密码锁题解</title>
    <url>/post/NOI-spring-test-T4-solution/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个 $k$ 行 $n$ 列的矩阵（$k \leq 4$），每次可以选定一列进行一次循环位移，定义 $c(i)$ 为任意次操作后第 $i$ 行的最大值与最小值之差，求 $\max c(i)$ 的最小值。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>尝试二分答案。</p>
<p>考虑全局最大值一定是某一行的最大值，全局最小值一定是某一行最小值。</p>
<p>最大值和最小值在不同行一定不劣于在同一行。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最大值最小，考虑二分答案。</p>
<p>接下来我们要判定 $\forall i,c(i)\leq x$。我们按 $k$ 从小到大解决。</p>
<p>$k&#x3D;1$ 显然等于最大值减最小值。</p>
<p>假如我们已经钦定了某一行的最大值 $mx_i$，显然在这一行的每一数应该大于等于 $mx_i-x$。但是直接枚举显然不优。我们发现全局最大值 $mx$ 一定是某一行的最大值，由于行与行之间没有区别，我们直接钦定 $mx_1 &#x3D; mx$。</p>
<p>同理，我们也可以发现全局最小值 $mn$ 也一定是某一行的最小值。如果把 $mx$ 和 $mn$ 放在同一行，答案 $mx-mn$ 显然达到了上界，所以把 $mx$ 和 $mn$ 不同行一定不劣。所以我们钦定 $mx_1 &#x3D; mx,mn_2 &#x3D; mn$，就可以判断每一列是否可能满足限制。至此，我们已经解决了 $k&#x3D;2$。</p>
<p>对于 $k&#x3D;3$ 的情况，我们可以钦定 $mx_1 &#x3D; mx$，但是最小值在第二行或第三行实际上是不同的情况，所以我们需要枚举最小值所在的行，令剩下没有钦定的行为 $i$，钦定最小值为 $mn_i$。对于某一列，总共有三种情况，首先要去除不满足全局最大最小限制的情况，还要满足 $a_i \leq mn_i + x$，即<br>$$<br>a_i-x \leq mn_i \leq a_i<br>$$<br>总共有 $O(n)$ 个这样的式子，$mn_i$ 必须要满足每一列至少有一个式子成立。显然如果存在这样一个 $mn_i$，一定可以找到一个这一行的数满足每一列至少成立一个式子（即向上找到第一个上界）。问题转化为有 $n$ 种区间，求是否存在一个点使得每种区间都存在一个区间包含这个点。我们只需要使用扫描线，用一个数组记录当前点被第 $i$ 种区间包含了多少次即可。</p>
<p>对于 $k&#x3D;4$ 的情况，我们用一样的方法，发现变量变成了两个，即有 $O(n)$ 组</p>

$$
\left\{
\begin{aligned}
a_i-x \leq mn_i \leq a_i\\
a_j-x \leq mn_j \leq a_j
\end{aligned}
\right.
$$


<p>这样的式子，$mn_i$ 与 $mn_j$ 必须满足每一列至少有一组式子成立。转换过来就变成了二维的，有 $n$ 种矩阵，求平面上是否存在一个点使得每种矩阵都存在一个矩阵包含这个点。同样考虑扫描线，用线段树维护当前高度的一条线上每个点被多少种区间覆盖，和这个的全局最大值，但是这里不好去重，我采用的比较暴力的方法：由于每种矩阵最多只有 $4$ 个，所以我们可以容斥一下变成至多 $15$ 个矩阵。我们只需要判断被覆盖的区间数的最大值是不是 $n$ 即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,q,mx,mn,a[N][<span class="number">4</span>],e[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x1,<span class="type">int</span> x2,<span class="type">int</span> y1,<span class="type">int</span> y2):<span class="built_in">x1</span>(x1),<span class="built_in">x2</span>(x2),<span class="built_in">y1</span>(y1),<span class="built_in">y2</span>(y2) &#123;&#125;</span><br><span class="line">&#125;b[N][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,h,u;</span><br><span class="line">    <span class="built_in">line</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">line</span>(<span class="type">int</span> x1,<span class="type">int</span> x2,<span class="type">int</span> h,<span class="type">int</span> u):<span class="built_in">x1</span>(x1),<span class="built_in">x2</span>(x2),<span class="built_in">h</span>(h),<span class="built_in">u</span>(u) &#123;&#125;</span><br><span class="line">&#125;c[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(line a,line b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,s,k;</span><br><span class="line">&#125;T[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=<span class="built_in">max</span>(T[x&lt;&lt;<span class="number">1</span>].s,T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].k==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    T[x&lt;&lt;<span class="number">1</span>].s+=T[x].k;</span><br><span class="line">    T[x&lt;&lt;<span class="number">1</span>].k+=T[x].k;</span><br><span class="line">    T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s+=T[x].k;</span><br><span class="line">    T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].k+=T[x].k;</span><br><span class="line">    T[x].k=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].l=l;</span><br><span class="line">    T[x].r=r;</span><br><span class="line">    T[x].s=T[x].k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(T[x].l&gt;=l&amp;&amp;T[x].r&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].s+=k;</span><br><span class="line">        T[x].k+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> z=T[x].l+T[x].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=z) <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;z) <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_node</span><span class="params">(<span class="type">int</span> u,node p1=node(<span class="number">1</span>,<span class="number">3e4</span>,<span class="number">1</span>,<span class="number">3e4</span>),node p2=node(<span class="number">1</span>,<span class="number">3e4</span>,<span class="number">1</span>,<span class="number">3e4</span>),node p3=node(<span class="number">1</span>,<span class="number">3e4</span>,<span class="number">1</span>,<span class="number">3e4</span>),node p4=node(<span class="number">1</span>,<span class="number">3e4</span>,<span class="number">1</span>,<span class="number">3e4</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x1=<span class="built_in">max</span>(<span class="built_in">max</span>(p1.x1,p2.x1),<span class="built_in">max</span>(p3.x1,p4.x1));</span><br><span class="line">    <span class="type">int</span> x2=<span class="built_in">min</span>(<span class="built_in">min</span>(p1.x2,p2.x2),<span class="built_in">min</span>(p3.x2,p4.x2));</span><br><span class="line">    <span class="type">int</span> y1=<span class="built_in">max</span>(<span class="built_in">max</span>(p1.y1,p2.y1),<span class="built_in">max</span>(p3.y1,p4.y1));</span><br><span class="line">    <span class="type">int</span> y2=<span class="built_in">min</span>(<span class="built_in">min</span>(p1.y2,p2.y2),<span class="built_in">min</span>(p3.y2,p4.y2));</span><br><span class="line">    <span class="keyword">if</span>(x1&lt;=x2&amp;&amp;y1&lt;=y2)</span><br><span class="line">    &#123;</span><br><span class="line">        c[++q]=<span class="built_in">line</span>(x1,x2,y1,u);</span><br><span class="line">        c[++q]=<span class="built_in">line</span>(x1,x2,y2+<span class="number">1</span>,-u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">1</span>],b[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">1</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">2</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">1</span>],b[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">1</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">2</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">1</span>,b[i][<span class="number">1</span>],b[i][<span class="number">2</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">add_node</span>(<span class="number">-1</span>,b[i][<span class="number">0</span>],b[i][<span class="number">1</span>],b[i][<span class="number">2</span>],b[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+q+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=q&amp;&amp;c[x].h==i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>,c[x].x1,c[x].x2,c[x].u);</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T[<span class="number">1</span>].s==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,x)-e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;++k) b[j][k]=<span class="built_in">node</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mx-a[j][k]&gt;x||a[j][(k+i)%<span class="number">4</span>]-mn&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> z1=<span class="number">0</span>,z2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>) z1=a[j][(k+<span class="number">2</span>)%<span class="number">4</span>],z2=a[j][(k+<span class="number">3</span>)%<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">2</span>) z1=a[j][(k+<span class="number">1</span>)%<span class="number">4</span>],z2=a[j][(k+<span class="number">3</span>)%<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">3</span>) z1=a[j][(k+<span class="number">1</span>)%<span class="number">4</span>],z2=a[j][(k+<span class="number">2</span>)%<span class="number">4</span>];</span><br><span class="line">                b[j][k]=<span class="built_in">node</span>(<span class="built_in">find</span>(<span class="built_in">max</span>(<span class="number">1</span>,z1-x)),<span class="built_in">find</span>(z1),<span class="built_in">find</span>(<span class="built_in">max</span>(<span class="number">1</span>,z2-x)),<span class="built_in">find</span>(z2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> u=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mx-a[i][j]&gt;x||a[i][(j+<span class="number">1</span>)%<span class="number">2</span>]-mn&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                u=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c[N],q;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,h,u;</span><br><span class="line">        <span class="built_in">str</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">str</span>(<span class="type">int</span> x,<span class="type">int</span> h,<span class="type">int</span> u):<span class="built_in">x</span>(x),<span class="built_in">h</span>(h),<span class="built_in">u</span>(u) &#123;&#125;</span><br><span class="line">    &#125;b[N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(str a,str b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+q+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(x&lt;=q&amp;&amp;b[x].h==i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c[b[x].x]==<span class="number">0</span>) ++s;</span><br><span class="line">                c[b[x].x]+=b[x].u;</span><br><span class="line">                <span class="keyword">if</span>(c[b[x].x]==<span class="number">0</span>) --s;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            q=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mx-a[j][k]&gt;x||a[j][(k+i)%<span class="number">3</span>]-mn&gt;x) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">1</span>) z=a[j][(k+<span class="number">2</span>)%<span class="number">3</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">2</span>) z=a[j][(k+<span class="number">1</span>)%<span class="number">3</span>];</span><br><span class="line">                    b[++q]=<span class="built_in">str</span>(j,<span class="built_in">find</span>(<span class="built_in">max</span>(<span class="number">1</span>,z-x)),<span class="number">1</span>);</span><br><span class="line">                    b[++q]=<span class="built_in">str</span>(j,<span class="built_in">find</span>(z+<span class="number">1</span>),<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    mx=<span class="number">1</span>,mn=<span class="number">3e4</span>;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[j][i]);</span><br><span class="line">            e[++m]=a[j][i];</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,a[j][i]);</span><br><span class="line">            mn=<span class="built_in">min</span>(mn,a[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mx-mn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">unique</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>)-e<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">auto</span> chk=[&amp;](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">2</span>) <span class="keyword">return</span> Solve2::<span class="built_in">solve</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">3</span>) <span class="keyword">return</span> Solve3::<span class="built_in">solve</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">solve</span>(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">3e4</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chk</span>(z)) r=z;</span><br><span class="line">        <span class="keyword">else</span> l=z+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;T,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">abc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
  </entry>
  <entry>
    <title>CF827F 题解</title>
    <url>/post/CF827F-solution/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一张无向图，边权为 $1$，第 $i$ 条边仅能在 $[l_i,r_i]$ 的时间通过，求 $1$ 到 $n$ 的最短路。</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>注意这个是无向图，所以只要在这条边的时间范围内，就可以反复走同一条边。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意，接下来定义第 $i$ 条边可以走的时间范围是 $[l_i,r_i]$，也就是 $r_i$ 等于题目中的 $r_i-1$。</p>
<p>首先这是一张无向图，我们考虑如果在到达一个点但是还要等一会才能走出去时，我们可以反复走一条边来拖时间。由于需要 $2$ 的时间往返一次，所以需要把时间分奇偶讨论。也就是说，如果我们能在 $t \in [l_i,r_i]$ 的时间到达边 $i$ 的起点，那么我们可以在 $[t+1,r_i+1]$ 中奇偶性相同的任意时间到达终点。</p>
<p>我们可以考虑每一个点拆成奇数点和偶数点，然后对于一条边，一个点的奇数点向另一个点的偶数点连边，偶数点向奇数点连边，并调整时间边界的奇偶性。接下来的讨论已经没有奇偶限制。</p>
<p>假如从边 $i$ 到达了 $x$，接下来要走边 $j$，如果 $i$ 已经无法走了 $j$ 还没到时间，我们可以考虑反复走 $x$ 连出去的其他边 $k$。这种情况其实不用单独考虑，因为我们可以把从 $i$ 到 $j$（重复走 $i$ 和 $k$）转换为先从 $i$ 到 $k$（重复走 $k$），然后再从 $k$ 走到 $j$（重复走 $k$）。</p>
<p>我们用一个三元组 $(x,l,r)$ 表示我们可以在 $[l,r]$ 的时间内都可以从点 $x$ 出发，枚举出边 $i$。如果 $l_i&gt;r$ 显然没法走。显然到达终点的时间最早是 $l+1$ 和 $l_i+1$ 取最大值，最晚是 $r_i+1$，因为我们可以重复走这条边。然后我们用一个类似 $\text{Dijkstra}$ 的东西维护：每一次取所有三元组中 $l$ 最小的，更新答案，一个点可以重复更新。但是每次遍历边显然要寄，我们可以发现每一次更新的 $l$ 是不降的，所以能更新的边的左端点也是不降的，我们只需要将边排序，每一次从上一次结束的地方开始。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,l,r;</span><br><span class="line">    <span class="built_in">str</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">str</span>(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r):<span class="built_in">x</span>(x),<span class="built_in">l</span>(l),<span class="built_in">r</span>(r)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(str a,str b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.l&gt;b.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;str&gt; a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(str a,str b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;l,&amp;r);</span><br><span class="line">        --r;</span><br><span class="line">        <span class="type">int</span> l1=l,l2=l,r1=r,r2=r;</span><br><span class="line">        <span class="keyword">if</span>(l%<span class="number">2</span>==<span class="number">1</span>) ++l1;</span><br><span class="line">        <span class="keyword">else</span> ++l2;</span><br><span class="line">        <span class="keyword">if</span>(r%<span class="number">2</span>==<span class="number">1</span>) --r1;</span><br><span class="line">        <span class="keyword">else</span> --r2;</span><br><span class="line">        <span class="keyword">if</span>(l1&lt;=r1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(<span class="built_in">str</span>(y+n,l1,r1));</span><br><span class="line">            a[y].<span class="built_in">push_back</span>(<span class="built_in">str</span>(x+n,l1,r1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2&lt;=r2)</span><br><span class="line">        &#123;</span><br><span class="line">            a[x+n].<span class="built_in">push_back</span>(<span class="built_in">str</span>(y,l2,r2));</span><br><span class="line">            a[y+n].<span class="built_in">push_back</span>(<span class="built_in">str</span>(x,l2,r2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a[i].<span class="built_in">begin</span>(),a[i].<span class="built_in">end</span>(),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;str&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">str</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        str k=Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(k.x==n||k.x==n*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k.l);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k.x];i&lt;a[k.x].<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k.x][i].l&gt;k.r) <span class="keyword">break</span>;</span><br><span class="line">            t[k.x]=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(k.l&lt;=a[k.x][i].r) Q.<span class="built_in">push</span>(<span class="built_in">str</span>(a[k.x][i].x,<span class="built_in">max</span>(k.l,a[k.x][i].l)+<span class="number">1</span>,a[k.x][i].r+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1340F 题解</title>
    <url>/post/CF1340F-solution/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长为 $n$ 的有 $k$ 种括号的括号序列，$q$ 个操作，每次操作修改一个位置的字符或查询一个区间是否为合法括号序列。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>显然朴素的做法是维护一个栈来判断。</p>
<p>我们可以考虑分块，每一块维护这一块的栈然后合并之类的。</p>
<p>对于每一块，由于它前面可能还有东西，所以最前面的右括号被认为是合法的。同理最后的左括号也是合法的，剩下的就应该被消完。也就是一个序列是合法的当且仅当这个序列消除完之后是由一段右括号接上一段左括号组成的，我们只需要维护这个东西即可。</p>
<p>但是我们在合并两个块的时候，显然需要判断一段左括号与一段右括号能不能匹配，暴力复杂度可能达到 $O(\text{块长})$，无法接受。考虑使用哈希判断，维护左右括号序列的前缀哈希，具体的维护从外层到内层的哈希，方便添加东西。</p>
<p>如果合并时我们依然用栈来维护左括号，复杂度还是 $O(n)$ 的，但是左括号序列可以划分成很多段，每一段来自同一块，我们只需要用 vector 来维护每一段的长度和前缀哈希，用一个指针指向算好的哈希数组。而最左边和最右边的散块暴力处理。</p>
<p>修改时我们只需要暴力重构某一个块即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200001</span>,M=<span class="number">500</span>,K=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,a[N],b1[N],b2[N],g1[N],g2[N],T,S1[N],T1,S2[N],T2;</span><br><span class="line"><span class="type">bool</span> h[M];</span><br><span class="line">ll f1[M][M],f2[M][M],f3[M],f4[M],powb[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    ll *f;</span><br><span class="line">    <span class="built_in">str</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">str</span>(<span class="type">int</span> g,ll *f):<span class="built_in">g</span>(g),<span class="built_in">f</span>(f)&#123;&#125;</span><br><span class="line">&#125;S[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T1=T2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>) S2[++T2]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(T2==<span class="number">0</span>) S1[++T1]=-a[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(S2[T2]!=-a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> --T2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>(b1[x<span class="number">-1</span>]+<span class="number">1</span>,b1[x])==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h[x]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g1[x]=T1,g2[x]=T2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f1[x][i]=(f1[x][i<span class="number">-1</span>]*K+S1[T1-i+<span class="number">1</span>])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f2[x][i]=(f2[x][i<span class="number">-1</span>]*K+S2[i])%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,ll *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>&amp;&amp;T&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z=<span class="built_in">min</span>(S[T].g,x);</span><br><span class="line">        <span class="keyword">if</span>(((S[T].f[S[T].g]-S[T].f[S[T].g-z]*powb[z]%P)%P+P)%P!=((f[x]-f[x-z]*powb[z]%P)%P+P)%P) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        S[T].g-=z;</span><br><span class="line">        x-=z;</span><br><span class="line">        <span class="keyword">if</span>(S[T].g==<span class="number">0</span>) --T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b2[l]==b2[r])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>(l,r)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(T1!=<span class="number">0</span>||T2!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>(l,b1[b2[l]])==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(T1!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T2;++i) f3[i]=(f3[i<span class="number">-1</span>]*K+S2[i])%P;</span><br><span class="line">    <span class="keyword">if</span>(T2!=<span class="number">0</span>) S[++T]=<span class="built_in">str</span>(T2,f3);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b2[l]+<span class="number">1</span>;i&lt;=b2[r]<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(g1[i],f1[i])==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(g2[i]!=<span class="number">0</span>) S[++T]=<span class="built_in">str</span>(g2[i],f2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>(b1[b2[r]<span class="number">-1</span>]+<span class="number">1</span>,r)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T1;++i) f4[i]=(f4[i<span class="number">-1</span>]*K+S1[T1-i+<span class="number">1</span>])%P;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(T1,f4)==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(T&gt;=<span class="number">1</span>&amp;&amp;S[T].g==<span class="number">0</span>) --T;</span><br><span class="line">    <span class="keyword">if</span>(T2!=<span class="number">0</span>||T!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%*d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    powb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) powb[i]=powb[i<span class="number">-1</span>]*K%P;</span><br><span class="line">    q=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i) b1[i]=(n/q)*i;</span><br><span class="line">    b1[q]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=b1[i<span class="number">-1</span>]+<span class="number">1</span>;j&lt;=b1[i];++j) b2[j]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">build</span>(i);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;z);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,k;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;k);</span><br><span class="line">            a[x]=k;</span><br><span class="line">            <span class="built_in">build</span>(b2[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(l,r)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>




]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1495F 题解</title>
    <url>/post/CF1495F-solution/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一排格子，每个格子有三个数 $p_i,a_i,b_i$，现在你要玩一个游戏，你站在第一个格子上，要跳到第 $n+1$ 个格子，$p_{n+1}&#x3D;\infty$。有一个格子集合 $S$，你必须跳到 $S$ 中的所有格子(其它随意)。</p>
<p>假设你站在格子 $i$，下一步你可以选择 : </p>
<ul>
<li><p>花费 $a_i$ 的代价，跳到 $i+1$。</p>
</li>
<li><p>花费 $b_i$ 的代价，跳到 $i$ 后面第一个满足 $p_j&gt;p_i$ 的位置 $j$。</p>
</li>
</ul>
<p>一轮游戏的代价是跳的总代价。</p>
<p>$q$ 次询问，每次可以在上一次的 $S$ 中添加或删除一个元素。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为起点是 $1$，终点是 $n+1$，我们直接把这两个点塞进 $S$，并无法删除。</p>
<p>首先因为需要经过 $S$ 中的所有点，我们可以转换为 $S$ 中相邻两点的距离和，也就是 $dis(S_1,S_k) &#x3D; \sum_{i&#x3D;1}^{k-1} dis(S_{i-1},S_i)$。由于相邻两次询问只修改了一个点，所以相邻两次询问的答案只有 $O(1)$ 次询问的差距，比如第 $t$ 次添加一个点 $S_k$，就有：</p>
<p>$$ans_t &#x3D; ans_{t-1} - dis(S_{t-1},S_{t+1}) + dis(S_{t-1},S_t) + dis(S_t,S_{t+1})$$</p>
<p>把询问离线下来后，就变成了 $O(n)$ 次询问 $dis(x,y)$。</p>
<p>我们把第一种走法和第二种走法放在一起看，看起来我们可以把左端点 $l$ 从 $n+1$ 移到 $1$，过程中处理跳跃 $l,r$ 的走法造成的贡献。如果当前情况下 $l$ 到 $r$ 的代价比直接走这个区间的代价小，那么就按原来的走，否则就走这个区间。但是这样并不对，因为我们按局部最优走，可能一下子走过了某个跳跃位置，导致结果不优。</p>
<p>但是我们还没有用到第二种走法的特殊之处，分析一下可以发现，第二种走法的区间之间要么包含要么不交。所以像上面那样走是不会跳过某个跳跃位置的。如果一个跳跃 $l,r$ 能造成贡献，那么 $l$ 到 $[r,n+1]$ 的代价都相应的减小相同的值 ，用树状数组即可维护。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3>
<details class="hcb-content box hcbsuccess">
  <summary><i class="fa fa-check fa-fw"></i>code<div class="hcb-box-open-button"><i class="fa fa-chevron-down fa-fw"></i></div></summary>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,c[N],d[N];</span><br><span class="line">ll a[N],b[N],f[N],T[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; Set;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,u,t;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;str&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[x]&gt;c[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x]+=k;</span><br><span class="line">        x+=(x&amp;-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=T[x];</span><br><span class="line">        x-=(x&amp;-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    c[n+<span class="number">1</span>]=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[x]&lt;=c[i]) x=d[x];</span><br><span class="line">        d[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    Set.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    Set.<span class="built_in">insert</span>(n+<span class="number">1</span>);</span><br><span class="line">    e[<span class="number">1</span>].<span class="built_in">push_back</span>((str)&#123;n+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(Set.<span class="built_in">count</span>(x))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z1=*(--Set.<span class="built_in">find</span>(x)),z2=*(++Set.<span class="built_in">find</span>(x));</span><br><span class="line">            e[z1].<span class="built_in">push_back</span>((str)&#123;x,<span class="number">-1</span>,i&#125;);</span><br><span class="line">            e[x].<span class="built_in">push_back</span>((str)&#123;z2,<span class="number">-1</span>,i&#125;);</span><br><span class="line">            e[z1].<span class="built_in">push_back</span>((str)&#123;z2,<span class="number">1</span>,i&#125;);</span><br><span class="line">            Set.<span class="built_in">erase</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Set.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> z1=*(--Set.<span class="built_in">find</span>(x)),z2=*(++Set.<span class="built_in">find</span>(x));</span><br><span class="line">            e[z1].<span class="built_in">push_back</span>((str)&#123;x,<span class="number">1</span>,i&#125;);</span><br><span class="line">            e[x].<span class="built_in">push_back</span>((str)&#123;z2,<span class="number">1</span>,i&#125;);</span><br><span class="line">            e[z1].<span class="built_in">push_back</span>((str)&#123;z2,<span class="number">-1</span>,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(i+<span class="number">1</span>,a[i]);</span><br><span class="line">            ll z=<span class="built_in">sum</span>(d[i]);</span><br><span class="line">            <span class="keyword">if</span>(b[i]&lt;z) <span class="built_in">add</span>(d[i],b[i]-z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;e[i].<span class="built_in">size</span>();++j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[e[i][j].t]+=e[i][j].u*<span class="built_in">sum</span>(e[i][j].x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>WC 2023 游记</title>
    <url>/post/wc-2023-travels/</url>
    <content><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>这次 WC 除集训队选手都是在线上，通过腾讯会议来上课。今天晚上开幕式属实离谱，放 CCF 宣传片，成都宣传片，cdqz 宣传片，然后一车人讲话，然后一车表演。CCF 的宣传片（PV），总共用标准的发音读了不下二十次的 C C F，放完之后就满脑子的标准发音读的 C C F，包括后面课间都要放。然后一车领导上去讲话（没有 ygg，悲），第一句话统一「尊敬的<del>肚子的</del>dzd主席」，然后背一通政治书。最后再来一波离大谱的表演，这玩意是 WC 的开幕式？和 OI 有毛线关系啊。</p>
<h2 id="Day-1-sim-5"><a href="#Day-1-sim-5" class="headerlink" title="Day 1 $\sim$ 5"></a>Day 1 $\sim$ 5</h2><p>上课。</p>
<p>基本上都是去的一课，但是第一节二课是 ygg 讲 「矩阵神法 &amp; 动态 dp」，那肯定得去捧场啊。</p>
<p>后面几节课都挺一般，一般听完前几道题就跑了，把这几道题做了基本上就完了。但是在一课中，有这样一位人物，WC 人尽皆知，他就是我们的罗老师<a href="https://www.zhihu.com/question/578857489/answer/2848819013">罗宜</a>。当然他只是代表，讨论区里听不懂提问的很多（包括「什么是网络流」「什么是线段树」）老师解答浪费了很多时间（我声称 ygg 是讲的最好的，因为他不看评论区）。</p>
<p>也有 CCF 的不完全迷惑的操作，<a href="https://www.zhihu.com/question/578498940">如何评价WC2023课程休息时间中有人因为发了一个“草”而被禁止上课一天？</a>。其实在教室里说脏话确实该被处罚，但是评论区有很多其他的影响上课的迷惑行为，比如刷无意义内容、问脑瘫问题，单刷一个 「草」相比于这些影响还是比较小吧。但也有可能是 CCF 的迷惑操作，之前不也有代码里有「暴戾语言」被禁三的。再说你要不要看看说的对象：</p>
<p><img src="/post-images/wc-2023-travels-1.png" alt="1"></p>
<p>不好评价。</p>
<h2 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h2><p>啊哈 CCF 居然不监考，那不是 ACM 赛制。</p>
<p>本来是早上 8:30 开始测试，结果一大早起来变九点了。。。</p>
<p>先看题，T1 想不到什么好的数据结构维护，但是 $m a_{max}$ 还是比较显然的。T2 连多项式算法都不会，暴力 16 分。T3 感觉很可做，先放着。</p>
<p>开 T1，$m a_{max}$ 只有 25 分，想怎么把值域给干掉。不久后想到 $a$ 的有效值的个数只有 $O(m)$ 个，这样就可以 $O(m)$ 查询，修改直接暴力 $O(m)$ 了，懒得搞，可持久化也不用了，暴力复杂度是对的。一个小时的时候开始写 T1，大概一个半小时后调完，自己写的 checker，不知道有没有锅（脑瘫 CCF 又没有 checker），估 35 分。</p>
<p>想 T3，因为大的会覆盖小的，所以从值小的开始推，显然当前值最小为 $q$ 的点中有且仅有一个通过边 $q$ 直接连的根节点，交换当前最小边 $p$ 和 $q$，现在值为 $p$ 的点 $t$ 就是和根节点相连的点，将这个点和根节点合并，问题规模缩小为 $n-1$。但是如果合并后的根节点不止一个点，我们还要准确的求出它的父亲，只需要把合并根节点包含的所有除了 $1$ 的点到它父亲的边与 $p$ 交换，看 $t$ 的值是否变化，取深度最大的点作为父亲即可。操作一的次数大约是 $n^2$，操作二是 $1.5n^2$。</p>
<p>在写 T3 之前我先把 T2 暴力写了，估 16 分。然后写 T3，写了一个多小时，能过第三个大样例，估 36 分。</p>
<p>总分估 50 吧，我声称要挂飞。</p>
<p>WC 打铁！<del>原地退役。</del></p>
<h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h2><p>出分。</p>
<p>$40 + 8 + 36 &#x3D; 84$</p>
<p>T1 多 hao 了 5 分，T2 数组开小挂了 8 分。</p>
<p>线 $\text{Au} \ \ 89,\text{Ag} \ \ 56,\text{Cu} \ \ 24$。</p>
<p><del>（差 5 分 Au，亏麻了）</del></p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP 2022 游记</title>
    <url>/post/noip-2022-travels/</url>
    <content><![CDATA[<p>寄了 sa</p>
<p>AFO</p>
<h2 id="Day-4-sim-0"><a href="#Day-4-sim-0" class="headerlink" title="Day -4 $\sim$ 0"></a>Day -4 $\sim$ 0</h2><p>这次 NOIP 在绵阳南山考，大家都来 <del>绵阳 5 日游</del> 隔离了，我要也去隔离酒店住几天。</p>
<p>迫真绵阳 5 日游。</p>
<p>每天都是早上起来就去 <a href="https://sukwants.pond.ink/">sgc</a> 和 <a href="https://syy.pond.ink/">syy</a> 的房间 219 做联考题，然后一个同学会了，大家都会了。</p>
<p>中午吃饭之后找了个餐桌打乒乓。下午基本就是各种颓，ygg 也不组织讨论，一直颓到晚上。晚上就有五六个人待在 219，边颓边看世界杯，还有两天晚上点了外卖。</p>
<p>后来 <a href="https://sukwants.pond.ink/">sgc</a> 开始放各种 WC 才艺展示，然后大家都开始听，直接投屏到电视上放《我的一个 OIer 朋友》。估计考场上要单曲循环了。</p>
<h2 id="Day-1-上午"><a href="#Day-1-上午" class="headerlink" title="Day 1 上午"></a>Day 1 上午</h2><p>11 月 26 号早上 8 点进入了考场，然后配好电脑。</p>
<p>考试开始后，我依然顺序开题，T1 一眼是傻逼题，只需要以 $\text{C}$ 和 $\text{F}$ 的左上角为参照，找 $\text{C}$ 的最下面一点和 $\text{F}$ 的中间一点的个数，要计算横或竖长度不同的情况。马上开始写，9 点左右写完。</p>
<p>T2 看起来像是傻逼题，但是完全没有思路，想了一下 $k&#x3D;2n-2$ 的部分，很容易就想出来了，大概就是前 $n-1$ 个栈每个栈放两个不同的元素，消上面的元素就直接放上去，消下面的元素就放在最后一个栈消。然后想了一个多小时，到了 10:30 还没想出来，放弃去看了一眼 T3。</p>
<p>T3 看起来很可做，因为只有守割边才有贡献，所以可以做边双缩点然后树形 dp。立马开始码，11 点就码出来了，但是发现过不了大样例，以为边双写挂了，调了一会，然后突然有了一点 T2 的思路，马上又去搞 T2。</p>
<p>T2 $k&#x3D;2n-1$ 的情况只需要多处理多出来的那一个数 $k$，假设 $k$ 后面的数是 $p$，如果 $p$ 在某一个栈 $A$ 下面，就可以把 $k$ 放到 $A$ 中，然后把 $p$ 放到最后一个栈，两个 $p$ 消掉就可以了。我认为这个算法没有假，马上开始写，但是很多地方写挂了，调了很多次才过大样例，这时候已经 12:55 了，T4 暴力都没来得及打，寄了 sa。</p>
<p>刚出考场，想了一下 T3 的做法，马上发现一个地方假了，只需要稍微改一下树形 dp 即可，亏麻了。但是 T2 许多人都没思路，又亏麻了。</p>
<p>后来测了民间数据，T1 没挂，T2 假了，只有大约一半的分，T3 居然有 15 分，大概是 $150 \sim 170$。寄了 sa，可能省选都进不了。真 ** 不该搞 3h 的 T2，亏麻了，T3 纯纯的傻逼题，5 分钟可以改过。</p>
<h2 id="Day-1-下午"><a href="#Day-1-下午" class="headerlink" title="Day 1 下午"></a>Day 1 下午</h2><p>一问各个巨佬，都考的比我高。ljy 和季老师大概是 300+，剩下的 1 队也基本 200+，但是看到 yl 在校门口快哭了，默哀。2 队的 <a href="https://www.cnblogs.com/Feyn/">zc</a> 切了 T3，lyh 大暴力凑了个 200+，%%%。剩下的貌似我最高，但是拿头进省选。</p>
<h2 id="Day-2-sim-4"><a href="#Day-2-sim-4" class="headerlink" title="Day 2 $\sim$ 4"></a>Day 2 $\sim$ 4</h2><p>从绵阳回来还是要居家隔离 3 天，去了 <a href="https://sukwants.pond.ink/">sgc</a> 家划水，大概就是天天打 generals.io，再搞点奇妙的技术问题。由于 <a href="https://wtyakioi.github.io/">zsq</a> 和 <a href="https://syy.pond.ink/">syy</a> 住的很近，还来一起耍了。</p>
<p>luogu、infOJ、小图灵都出分了。我引用一下 <a href="https://www.cnblogs.com/Feyn/">zc</a> 博客里小图灵的统计：</p>
<blockquote>
<p>zzh299，ljy220，zyt123，xby280，llt280，shr183，yxr86，wzx179，zlx240，cs270，syy76，swc240，zyc170，<a href="https://sukwants.pond.ink/">sgc</a>115，zym200，zsq87，yl29，hyy195，lyh209</p>
</blockquote>
<p>再补一个 zc235。</p>
<p>%%%</p>
<p>就我最菜。</p>
<p>退役力。</p>
<p>自开力。</p>
<p>AFO</p>
<h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>要返校了。</p>
<p>学校电脑莫名其妙有一坨电源跳闸了，刚好就有我的，预示我被踢出机房力。</p>
<h2 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h2><p>寄了 sa。</p>
<p>NOI 官网出分，数据极限强，T1 满，T2 $25$ 分，T3 爆 $0$，直接退役。</p>
<p>傻逼 T2。</p>
<p>我菜麻了。</p>
<p>真退役力。</p>
<h2 id="Day-N"><a href="#Day-N" class="headerlink" title="Day N"></a>Day N</h2><p>据说是一等以上全部进省选（同时女生全部进），虽然拿头进省队，但是不用上文化课了，舒服！</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 游记</title>
    <url>/post/csp-s-2022-travels/</url>
    <content><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>进了考场，才发现高新的机房挤得要死，还不隔开坐，跟某东辰国际一样，<del>但是某东辰国际至少有挡板，这里瞟代码完全发现不了</del>，手都活动不开，键盘盒子还是下沉的，打起来十分奇妙，不过质量感觉比我们机房好很多。</p>
<p>T1 求无向图上过点 $1$ 的最大权五元环，容易想到分成 $1$ 号点左半边和右半边，但是还有保证点互不相同，想了 $10$ 分钟，才想到可以维护前三大值来避免重复。码的时候比较脑车可以写 bfs 的写了个 SPFA。</p>
<p>15:10 开了 T2，策略很显然，如果对面既有正数也有负数，就分别选最接近 $0$ 的正数&#x2F;负数，否则就选符号相反且绝对值最大的。由于是静态的，可以用 ST 表，但是我怕写挂，还是写了线段树。然后我比较懒，没有分类讨论，直接暴力枚举最小&#x2F;最大的非负数&#x2F;负数这四个数组成的情况，反正都有一个 $\log$ 了。</p>
<p>15:40 开 T3，题目非常长，说了半天就是可以对一个数或一个集合中的数同时加 $1$ 或减 $1$，问当前是否每个数都是 $1$。然后我觉得可能是根号分治之类的，由于集合大小总和与点数同级，所以大小比 $\sqrt {N}$ 大的集合最多有 $\sqrt {N}$ 个，但是半个小时都没想出来。然后想到可以把点分成几组（一个点可以在多个组中），我们只需要看每个组的和是否等于它的大小，但是有想了一会，想不到保证正确的分法，但感觉不好卡，实在想不出来就写这个。看了一眼 T4，不会。等到 17:00，仍然想不出来，于是我就按二进制的每一位分组，写出来了。但是我犯了个非常<strong>脑车</strong>的错误，就是在分组判出来没错后线性判，主要是怕 WA，但是当时忘了可能出一堆 <code>YES</code> 来卡（心肌梗死的原因）。</p>
<p>17:40 开 T4，好像 $n,m \leq 2000$ 可以跑最短路，但是暴力建边会卡成 $n^2$ 或 $n^3$ 级别的，马上想到分层图，然后就写出来了。虽然还有 $8$ 分可以跑树剖，但是我还没有检查，便放弃了。</p>
<p>18:10 开始检查，首先检查在 Linux 下的编译，好家伙，还真有一个 CE，居然是有个函数忘写 <code>void</code> 了。然后检查空间、<code>ll</code>，过了遍大样例，还把 T1 拍了一遍。希望没挂分。</p>
<h2 id="Day-1-晚"><a href="#Day-1-晚" class="headerlink" title="Day 1 晚"></a>Day 1 晚</h2><p>出来叶老就问分，T1、T2、T4 加起来 244 分，T3 是真不知道。然后 <a href="https://sukwants.pond.ink/">sgc</a> 巨佬就来蹭车，还在和 <a href="https://song-gan.github.io/">sxg</a> 巨佬打电话，才发现 T1 脑车了，跑了个 SPFA，不过 <a href="https://www.cnblogs.com/Feyn/">zc</a> 巨佬说他 bfs 没判连通，我 SPFA 初始化的 <code>inf</code>，撞大运了。</p>
<p>晚上和 <a href="https://sukwants.pond.ink/">sgc</a> 巨佬一起吃饭，看到了 <a href="https://www.luogu.com.cn/discuss/520101">chen_zhe 的帖子</a>。回了寝室之后一直摆烂，结果 22:23 叶老突然就把代码发下来了。luogu 上已经有 T1，T2，T4 的数据，在寝室等了二十分钟不敢交 <del>（期间把 zym 的 T1 交了试试水，结果过了，更慌了）</del>。</p>
<p>22:45 终于交了，看起来 T1、T2、T4 都没挂分，刚好 244。T3 交到了 InfOJ 上，发现 T 了，这时才想起来会被卡，然后删了线性判断一交，95 分，当场心肌梗死了。所以我 T3 的瓶颈在于 <code>put(&quot;YES\n&quot;)</code>，然后就心肌梗死了一晚上，和 <a href="https://wtyakioi.github.io/">zsq</a> 巨佬刷表情，刷了整整 $10$ 分钟，摆烂了。一直到 12 点过才睡。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>绵阳又封了，只有待在机房划水。</p>
<p>晚上 <a href="https://www.cnblogs.com/Feyn/">zc</a> 巨佬来机房了，我发现他 T4 过了，问他咋做，他说他抽了一个人的代码交居然过了，得出结论，人均会 T4，就我不会。</p>
<p>luogu 居然一整天都没有 T3 数据。</p>
<p>然后突然发现计蒜客也可以估分，交了一发，T1 居然给我 T 掉了，但在 luogu 上只跑了 500ms，可能是机子太撇了。更震惊的是，T3 给我过了，希望 CCF 的数据也能用脚造。</p>
<p>看了一下 <a href="https://blog.zlx.pw/">zlx</a> 巨佬的题解，才发现 T3 脑车了，可以随机赋权值然后看和是否满足。T4 感觉如果多给一些时间应该有点思路。但是完全没有改题的心情，又开始摆烂。</p>
<p>等到快睡觉了才发现 luogu 已经有数据了，交了一发 T3，居然也过了，可能出题人根本不会想到卡我这种复杂度，只有看 rp 了。</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>下午讲 CSP，听说有人 luogu  T1 的数据 $O(n^4)$ 只 T 一个点，麻了，感觉 T1 各种乱搞都能过。</p>
<p>小图灵也出分了，和 luogu 一样。现在各个网站的分数如下：<br>luogu ：$100+100+100+44&#x3D;344$<br>InfOJ：$100+100+40+44&#x3D;284$<br>小图灵：$100+100+100+44&#x3D;344$<br>计蒜客：$100+100+100+44&#x3D;344$<br>（InfOJ 数据更新后就满了，计蒜客重交也满了）。</p>
]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>四边形不等式优化线性dp</title>
    <url>/post/Quadrilateral-inequality-optimization-linear-DP/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经典题：<a href="https://www.luogu.com.cn/problem/P1912">P1912 [NOI2009] 诗人小G</a><br>有一些奇怪的 dp 题目，它的转移方程有很多高次项，没办法单调队列优化或斜率优化， 但是我们仍然可以找到一些规律，比如说决策单调性。<br>我们举一个非常形象的例子，一个数列，$f[i]$ 表示前 ii 个数中的最大值，$g[i]$ 表示前 $i$ 个数中第一个出现的最大数的下标，那么很显然，$g$ 是单调不下降的，因为任意 $i,j(i&lt;j)$ 都必然有 $f[i] \leqslant f[j]$，又有 $\forall k \in [1,j),a[k] &lt; f[j] &#x3D; a[g[j]]$，所以如果 $g[j]&lt;g[i]$，必然有 $f[j] &#x3D; a[g[j] &lt; a[g[i]] &#x3D; f[i]$，矛盾，故 $g[j] \leqslant g[i]$。如果我们非常傻地用 $f[i]&#x3D;\max\limits_{1 \leqslant j \leqslant i}(a[i])$ 来转移，我们就可以将其优化为 $f[i]&#x3D;\max\limits_{g[i-1] \leqslant j \leqslant i}(a[i])$。这就叫做决策单调性，其中 $g[i]$ 叫做 $i$ 位置的最优决策。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>如果一个转移方程存在决策单调性，我们就可以像上面那样优化了。但是显然还不够，我们可以换一种思路，原来我们是知道 $i$ 寻找 $g[i]$，现在我们在知道 $g[i]$ 的情况下去找 $i$，就相当于是在转移时知道 $j$ 去枚举 $i$。虽然看起来没有什么变化，但是别忘了还有决策单调性。假如我们现在知道了 $[1,n]$ 每个位置的最优决策（决策在 $[1,j]$ 范围内），由于决策单调性，如果位置 $i$ 的最优决策是 $j$，那么 $\forall i \in[j,n],g[i] \geqslant j$，由于是在 $[1,j]$ 中的最优决策，所以 $\forall i \in[j,n],g[i] &#x3D; j$。所以我们一定能找到一个 $j$，使得 $\forall i \in[j,n],g[i] &#x3D; j$ 且 $\forall i \in[1,j-1],g[i] &lt; j$，我们只需要在序列中二分即可。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>但是二分之后我们还需要修改整个区间 $[j,n]$，很自然能想到线段树，但其实还有更好的做法：使用三元组。一个三元组 $(l,r,k)$ 表示在区间 $[l,r]$ 中所有位置的最优决策都是 $k$，然后用一个队列来存储所有三元组。首先插入三元组 $(1,n,0)$，之后的操作就很像单调队列了。<br>首先要找到 $i$ 的最优决策，只需要将队首右端点都比 $i$ 小的三元组出队，当前的队首三元组的最优决策 $k$ 就是 $i$ 的最优决策。然后我们要将 $i$ 作为一个决策插入序列，如果 $i$ 用来转移 $n$ 位置都没有当前最优决策 $g[n]$ 好，说明整个序列的最优决策都比 $i$ 小，跳过。否则，不断比较队尾元素 $(l,r,k)$ 与 $i$，如果用 $i$ 来转移 $l$ 比用 $k$ 来转移 $l$ 要好，就说明 $[l,r]$ 的最优决策都是 $i$，删除队尾。但是如果 $i$ 并不是整个 $[l,r]$ 的最优决策，就需要在 $[l,r+1]$ 中二分查找分界线 $t$（$t$ 的最优决策也为 $i$），把右端点改为$ t-1$，然后插入三元组 $(t,n,i)$。这里还要注意特判，如果队列中已经没有三元组了，直接插入 $(i+1,n,i)$。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>知道了如何解决满足决策单调性的问题。我们还要知道如何证明决策单调性。这就要引入四边形不等式：</p>
<p>$$\forall a \leqslant b \leqslant c \leqslant d,w(a,d)+w(b,c) \geqslant w(a,b)+w(c,d)$$</p>
<p>四边形不等式还有另一个表述方法：</p>
<p>$$\forall a&lt;b,w(a,b+1)+w(a+1,b) \geqslant w(a,b)+w(a+1,b+1)$$</p>
<p>证明：</p>
<p>设 $a&lt;c$，则有 $w(a,c+1)+w(a+1,c) \geqslant w(a,c)+w(a+1,c+1)$。</p>
<p>若 $a+1&lt;c$，则有 $w(a+1,c+1)+w(a+2,c) \geqslant w(a+1,c)+w(a+2,c+1)$。</p>
<p>两式相加，消去相同项可得 $w(a,c+1)+w(a+2,c) \geqslant w(a,c)+w(a+2,c+1)$。</p>
<p>类似的，只要 $a+k&lt;c$ 就可以得到 $w(a,c+1)+w(a+k,c) \geqslant w(a,c)+w(a+k,c+1)$。</p>
<p>所以对于 $a \leqslant b \leqslant c$，就有 $w(a,c+1)+w(b,c) \geqslant w(a,c)+w(b,c+1)$。</p>
<p>同理可证对于 $a \leqslant b \leqslant c \leqslant d$，有 $w(a,d)+w(b,c) \geqslant w(a,c)+w(b,d)$。</p>
<p>而对于证明决策单调性，有如下定理：</p>
<blockquote>
<p>在状态转移方程 $f[i]&#x3D;\min\limits_{0\leqslant j &lt;i}{f[j]+w(j,i)}$ 中，若函数 $w$ 满足四边形不等式，则 $f$ 具有决策单调性。<br>证明：</p>
</blockquote>
<p>$\forall i \in [1,n]$，$\forall j \in [0,g[i]−1]$，由 $g[i]$ 的最优性可得：</p>
<p>$$f[g[i]]+w(g[i],i)\leqslant f[j]+w(j,i)\tag1$$</p>
<p>设有 $i’ \in [i+1,n]$，因为 $w$ 满足四边形不等式，所以</p>
<p>$$w(j,i’)+w(g[i],i)\geqslant w(j,i)+w(g[i],i’)$$</p>
<p>$$w(g[i],i’)-w(g[i],i)\leqslant w(j,i’)-w(j,i)\tag2$$</p>
<p>$(1)(2)$ 两式相加，可得：</p>
<p>$$f[g[i]]+w(g[i],i’) \leqslant f[j]+w(j,i’)$$</p>
<p>所以，对于 $i$ 以后的任意一个 $i′$，$g[i]$ 都是比任意 $j&lt;g[i]$ 更优的决策，故 $f$ 具有决策单调性。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>下面是经典题 P1912 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n,k,T,R,g[N];</span><br><span class="line">ll m,a[N];</span><br><span class="line">ld f[N];</span><br><span class="line"><span class="type">char</span> c[N][<span class="number">101</span>];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,k;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function">ld <span class="title">pow</span><span class="params">(ll x,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ld s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;++i) s*=x;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ld <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[y]+<span class="built_in">pow</span>(<span class="built_in">abs</span>(a[x]-a[y]+x-y<span class="number">-1</span>-m),k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c[i]);</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+<span class="built_in">strlen</span>(c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="number">0</span>,R=<span class="number">-1</span>;</span><br><span class="line">    Q[++R]=(str)&#123;<span class="number">1</span>,n,<span class="number">0</span>&#125;;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;Q[T].r&lt;i) ++T;</span><br><span class="line">        Q[T].l=i;</span><br><span class="line">        f[i]=<span class="built_in">abc</span>(i,Q[T].k);</span><br><span class="line">        g[i]=Q[T].k;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&gt;<span class="number">1e18</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(T&lt;=R&amp;&amp;<span class="built_in">abc</span>(n,i)&gt;<span class="built_in">abc</span>(n,Q[R].k)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;<span class="built_in">abc</span>(Q[R].l,i)&lt;=<span class="built_in">abc</span>(Q[R].l,Q[R].k)) --R;</span><br><span class="line">        <span class="keyword">if</span>(T&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=Q[R].l,r=Q[R].r+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abc</span>(z,i)&lt;=<span class="built_in">abc</span>(z,Q[R].k)) r=z;</span><br><span class="line">                <span class="keyword">else</span> l=z+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q[R].r=l<span class="number">-1</span>;</span><br><span class="line">            Q[++R]=(str)&#123;l,n,i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Q[++R]=(str)&#123;i+<span class="number">1</span>,n,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[n]&gt;<span class="number">1e18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Too hard to arrange\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ll)f[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) h[i]=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> x=n;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h[x]=<span class="literal">true</span>;</span><br><span class="line">        x=g[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,c[i]);</span><br><span class="line">        <span class="keyword">if</span>(h[i]==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dp</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>四边形不等式优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3356 火星探险问题</title>
    <url>/post/P3356-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3356">P3356 火星探险问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题的方法同 <a href="/post/P4012-solution/">P4012</a> ，但是还要求输出一种方案，我们就需要知道流量的流动情况。如果一条边有流量流过，那么这条边的反向边容量 $r$ 一定不为 $0$，而且流过的流量就是 $r$，也就是有 $r$ 个探测车经过。我们只需要从源点开始一直走反向边容量不为 $0$ 的边，且每走一次容量减一，注意要判断有没有往回走，还要注意处理拆开的两个点的关系。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>,M=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[N],t0[N];</span><br><span class="line">ll v,f[N],q;</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">road</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r,w;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">-1e18</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;f[k]+a[i].w&gt;f[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+a[i].w;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">-1e18</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(h[a[i].m]==<span class="literal">false</span>&amp;&amp;a[i].r&gt;<span class="number">0</span>&amp;&amp;f[a[i].m]==f[x]+a[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            ll z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            h[a[i].m]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">                v+=z*a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="built_in">sum</span>(m,n)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[m*n+x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==x||a[i^<span class="number">1</span>].r==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ++a[i].r;</span><br><span class="line">        --a[i^<span class="number">1</span>].r;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==x+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d 1\n&quot;</span>,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d 0\n&quot;</span>,k);</span><br><span class="line">        <span class="built_in">dfs0</span>(a[i].m,k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>,&amp;q,&amp;n,&amp;m);</span><br><span class="line">    s1=m*n*<span class="number">2</span>+<span class="number">1</span>,s2=m*n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),m*n+<span class="built_in">sum</span>(i,j),<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(m*n+<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i,j),<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),m*n+<span class="built_in">sum</span>(i,j),<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">road</span>(m*n+<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i,j),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(m*n+<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i+<span class="number">1</span>,j),<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i+<span class="number">1</span>,j),m*n+<span class="built_in">sum</span>(i,j),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(m*n+<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i,j+<span class="number">1</span>),<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j+<span class="number">1</span>),m*n+<span class="built_in">sum</span>(i,j),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">road</span>(s1,<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>),q,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">road</span>(<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>),s1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">road</span>(m*n+<span class="built_in">sum</span>(m,n),s2,q,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">road</span>(s2,m*n+<span class="built_in">sum</span>(m,n),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            t0[i]=t[i];</span><br><span class="line">            h[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs0</span>(<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>费用流题单</title>
    <url>/post/minimum-cost-maximum-flow-problemlist/</url>
    <content><![CDATA[<p>这是 <a href="/post/minimum-cost-maximum-flow-EK">费用流</a> 的几道经典题目，建议按照顺序来做。</p>
<p><a href="/post/P1251-solution">P1251 餐巾计划问题</a></p>
<p><a href="/post/P4015-solution">P4015 运输问题</a></p>
<p><a href="/post/P4014-solution">P4014 分配问题</a></p>
<p><a href="/post/P2604-solution">P2604 [ZJOI2010]网络扩容</a></p>
<p><a href="/post/P4012-solution">P4012 深海机器人问题</a></p>
<p><a href="/post/P3356-solution">P3356 火星探险问题</a></p>
]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4012 深海机器人问题</title>
    <url>/post/P4012-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4012">P4012 深海机器人问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是网格类的费用流，将深海机器人看做流量，每个生物标本看做 $1$ 点费用即可。但要注意每个生物标本只能采集一次，也就意味着流量为 $1$ 时费用为 $1$，多余 $1$ 的流量费用为 $0$。所以我们又要用到同 <a href="/post/P2604-solution/">P2604</a> 的拆边思想，然后按题意连边跑最大费用最大流即可。<br>注意，这道题的坐标十分诡异，有的储存方法必须要反过来，有的就不能反，在写的时候仔细想一下。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>,M=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,t1,t2,s1,s2,t[N],t0[N];</span><br><span class="line">ll v,f[N];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">road</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r,w;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">-1e18</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;f[k]+a[i].w&gt;f[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+a[i].w;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">-1e18</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(h[a[i].m]==<span class="literal">false</span>&amp;&amp;a[i].r&gt;<span class="number">0</span>&amp;&amp;f[a[i].m]==f[x]+a[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            ll z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            h[a[i].m]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">                v+=z*a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;m,&amp;n);</span><br><span class="line">    ++m,++n;</span><br><span class="line">    s1=m*n+<span class="number">1</span>,s2=m*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n<span class="number">-1</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ll w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i,j+<span class="number">1</span>),<span class="number">1</span>,w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j+<span class="number">1</span>),<span class="built_in">sum</span>(i,j),<span class="number">0</span>,-w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i,j+<span class="number">1</span>),<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j+<span class="number">1</span>),<span class="built_in">sum</span>(i,j),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ll w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(j,i),<span class="built_in">sum</span>(j+<span class="number">1</span>,i),<span class="number">1</span>,w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(j+<span class="number">1</span>,i),<span class="built_in">sum</span>(j,i),<span class="number">0</span>,-w);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(j,i),<span class="built_in">sum</span>(j+<span class="number">1</span>,i),<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">road</span>(<span class="built_in">sum</span>(j+<span class="number">1</span>,i),<span class="built_in">sum</span>(j,i),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>,&amp;r,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(s1,<span class="built_in">sum</span>(x+<span class="number">1</span>,y+<span class="number">1</span>),r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(<span class="built_in">sum</span>(x+<span class="number">1</span>,y+<span class="number">1</span>),s1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d%d&quot;</span>,&amp;r,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(<span class="built_in">sum</span>(x+<span class="number">1</span>,y+<span class="number">1</span>),s2,r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(s2,<span class="built_in">sum</span>(x+<span class="number">1</span>,y+<span class="number">1</span>),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            t0[i]=t[i];</span><br><span class="line">            h[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2604 [ZJOI2010]网络扩容</title>
    <url>/post/P2604-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2604">P2604 [ZJOI2010]网络扩容</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们先来分析一下这个问题：我们要在一个图中跑费用流，当一条边流量在 $c$ 以下时，费用为 $0$，当这条边容量超过 $c$ 时，超过部分的费用为 $w$。我们可以发现，图中每一条边都有 $2$ 种计费方式，而且是分段的一次函数。这时候我们要用到经典的“拆边”，将这条边拆成 $2$ 条边，一条边的容量为 $c$，费用为 $0$，另一条边容量为 $inf$，费用为 $w$。如果这条边的流量不超过 $c$，那么为了费用最小，所有流量都会从第 $1$ 条边流过。而如果流量超过 $c$，多余的部分就会从第 $2$ 条边流过，且多余部分费用为 $w$。这种方法有时非常好用，但是仅限于此分段函数的斜率单调不下降的时候，也就是费用逐渐变大，否则无法使用（在最大费用最大流时相反）。<br>注意在跑完第一遍最大流之后的初始化。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>,M=<span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n,m,r0,p=<span class="number">1</span>,v,s1,s2,t[N],t0[N];</span><br><span class="line">ll f[N],b[N][<span class="number">4</span>];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r,w;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e18</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;f[k]+a[i].w&lt;f[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+a[i].w;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e18</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(h[a[i].m]==<span class="literal">false</span>&amp;&amp;a[i].r&gt;<span class="number">0</span>&amp;&amp;f[a[i].m]==f[x]+a[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            ll z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            h[a[i].m]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">                v+=z*a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;r0);</span><br><span class="line">    s1=<span class="number">1</span>,s2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll r,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;r,&amp;w);</span><br><span class="line">        b[i][<span class="number">0</span>]=x,b[i][<span class="number">1</span>]=y,b[i][<span class="number">2</span>]=r,b[i][<span class="number">3</span>]=w;</span><br><span class="line">        <span class="built_in">road</span>(x,y,r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            t0[i]=t[i];</span><br><span class="line">            h[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,r);</span><br><span class="line">    s1=n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">road</span>(s1,<span class="number">1</span>,r0,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">road</span>(<span class="number">1</span>,s1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(b[i][<span class="number">0</span>],b[i][<span class="number">1</span>],<span class="number">1e18</span>,b[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="built_in">road</span>(b[i][<span class="number">1</span>],b[i][<span class="number">0</span>],<span class="number">0</span>,-b[i][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            t0[i]=t[i];</span><br><span class="line">            h[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4014 分配问题</title>
    <url>/post/P4014-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4014">P4014 分配问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题其实是 <a href="/post/P4015-solution/">P4015</a> 的简化版，P4015 是仓库中可以有多个货物，商店也可能需要多个货物，而这道题中工件最多 $1$ 个，工人也只能做 $1$ 个工件。所以只需要把上一题所有的边流量变为 $1$，然后跑最大费用最大流即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s1,s2,p=<span class="number">1</span>,t[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],r[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> h[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,m,q,r1,r2,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].x=x;</span><br><span class="line">    a[p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r1=r;</span><br><span class="line">    a[p].r2=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e9</span>;</span><br><span class="line">        g[i]=<span class="number">1e9</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r1&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&lt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r1);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>+<span class="number">2</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e9</span>;</span><br><span class="line">        g[i]=<span class="number">-1e9</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r2&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&gt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r2);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    s1=<span class="number">1</span>;</span><br><span class="line">    s2=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i+n+<span class="number">1</span>,n*<span class="number">2</span>+<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(n*<span class="number">2</span>+<span class="number">2</span>,i+n+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">            <span class="built_in">road</span>(i+<span class="number">1</span>,j+n+<span class="number">1</span>,<span class="number">1</span>,w);</span><br><span class="line">            <span class="built_in">road</span>(j+n+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>,-w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> w1=<span class="number">0</span>,w2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        w1+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r1-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r1+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA2</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        w2+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r2-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r2+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,w1,w2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4015 运输问题</title>
    <url>/post/P4015-solution/</url>
    <content><![CDATA[<p>[P4015 运输问题]{<a href="https://www.luogu.com.cn/problem/P4015">https://www.luogu.com.cn/problem/P4015</a>)</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题其实不难看出可以把货物看做流量来跑费用流。我们建两组点，分别代表仓库和商店，然后和源汇点连边，跑费用流即可。如果还不清楚可以看下面，我们要建这几种边：</p>
<ol>
<li>源点向仓库 $i$ 连边，容量为 $a_i$，费用为 $0$。 </li>
<li>仓库 $i$ 向商店 $j$ 连边，容量为 $inf$，费用为 $c_{ij}$。 </li>
<li>商店 $i$ 向汇点连边，容量为 $b_i$，费用为 $0$。</li>
</ol>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,n1,n2,s1,s2,p=<span class="number">1</span>,t[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],r[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> h[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,m,q,r1,r2,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].x=x;</span><br><span class="line">    a[p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r1=r;</span><br><span class="line">    a[p].r2=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e9</span>;</span><br><span class="line">        g[i]=<span class="number">1e9</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r1&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&lt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r1);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e9</span>;</span><br><span class="line">        g[i]=<span class="number">-1e9</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r2&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&gt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r2);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n1,&amp;n2);</span><br><span class="line">    n=n1+n2+<span class="number">2</span>;</span><br><span class="line">    s1=<span class="number">1</span>;</span><br><span class="line">    s2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(<span class="number">1</span>,i+<span class="number">1</span>,r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(i+n1+<span class="number">1</span>,n,r,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(n,i+n1+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">            <span class="built_in">road</span>(i+<span class="number">1</span>,j+n1+<span class="number">1</span>,<span class="number">1e9</span>,w);</span><br><span class="line">            <span class="built_in">road</span>(j+n1+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>,-w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> w1=<span class="number">0</span>,w2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        w1+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r1-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r1+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA2</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        w2+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r2-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r2+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>,w1,w2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1251 餐巾计划问题</title>
    <url>/post/P1251-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1251">P1251 餐巾计划问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一道及其经典的费用流问题，我们只需要把餐巾看做流量即可。但是我们会发现，餐巾还分为两类：一类是干净的餐巾，另一类是脏的餐巾，这两种不能混在一起。对于这种状态有分类的题目，我们最好使用分层图来解决，每一层都代表一种状态，这样就可以分开不同状态的流量了。这道题中由于每天早上需要赶紧餐巾，然后把脏餐巾送到晚上，而晚上收到脏餐巾，又要给其他早上提供干净餐巾，我们就可以把整个图拆成两部分：早上和晚上。<br>然后我们要保证每天早上都有足够的干净餐巾，解决方法非常简单只需要从每天早上向汇点连边，容量为 $r_i$，同时从源点向晚上连边，容量为 $r_i$。但是这样一天用不完的餐巾就没法继续使用了，我们只需要从每天早上或晚上向下一条边连边，就表示我们可以把餐巾留到后面使用。<br>解决了这些，剩下的我们按题意连边即可。要连的边有以下 $6$ 种。</p>
<ol>
<li>第 $i$ 天早上向汇点连边，容量为 $r_i$，费用为 $0$。</li>
<li>源点向第 $i$ 天晚上连边，容量为 $r_i$，费用为 $0$。</li>
<li>第 $i$ 天晚上向第 $i+1$ 天晚上连边，容量为 $inf$，费用为 $0$。</li>
<li>源点向第 $i$ 天早上连边，容量为 $inf$，费用为 $p$。</li>
<li>第 $i$ 天晚上向第 $i+m$ 天早上连边，容量为 $inf$，费用为 $f$。</li>
<li>第 $i$ 天晚上向第 $i+n$ 天早上连边，容量为 $inf$，费用为 $s$。</li>
</ol>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,N,s1,s2,p=<span class="number">1</span>,t[<span class="number">10001</span>],r[<span class="number">10001</span>];</span><br><span class="line">ll b[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],w0,w1,w2,t1,t2;</span><br><span class="line"><span class="type">bool</span> h[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,m,q;</span><br><span class="line">    ll r,w;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].x=x;</span><br><span class="line">    a[p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e18</span>;</span><br><span class="line">        g[i]=<span class="number">1e18</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&lt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e18</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld%lld&quot;</span>,&amp;w0,&amp;t1,&amp;w1,&amp;t2,&amp;w2);</span><br><span class="line">    s1=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    s2=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    N=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span><span class="number">-1</span>,s2,b[i],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(s2,i*<span class="number">2</span><span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(s1,i*<span class="number">2</span>,b[i],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span>,s1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span>,(i+<span class="number">1</span>)*<span class="number">2</span>,<span class="number">1e18</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">road</span>((i+<span class="number">1</span>)*<span class="number">2</span>,i*<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(s1,i*<span class="number">2</span><span class="number">-1</span>,<span class="number">1e18</span>,w0);</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span><span class="number">-1</span>,s1,<span class="number">0</span>,-w0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-t1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span>,(i+t1)*<span class="number">2</span><span class="number">-1</span>,<span class="number">1e18</span>,w1);</span><br><span class="line">        <span class="built_in">road</span>((i+t1)*<span class="number">2</span><span class="number">-1</span>,i*<span class="number">2</span>,<span class="number">0</span>,-w1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-t2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i*<span class="number">2</span>,(i+t2)*<span class="number">2</span><span class="number">-1</span>,<span class="number">1e18</span>,w2);</span><br><span class="line">        <span class="built_in">road</span>((i+t2)*<span class="number">2</span><span class="number">-1</span>,i*<span class="number">2</span>,<span class="number">0</span>,-w2);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        w+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/post/Tree-chain-subdivision/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树链剖分是用来解决树上问题的经典方法，而且常数极小。这其中的一个经典问题就是 <a href="https://www.luogu.com.cn/problem/P3379">最近公共祖先（LCA）</a>，这道题可以当做树剖的模板题。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>树链剖分，顾名思义，是把树剖分成很多条链。为什么要剖分成链？因为在解决树上问题时，一条链往往可以一次性操作，就如模板题 LCA，我们在两个点向上跳时就可以直接跳到所在链的链头。如何剖分？剖分有多种方法，其中重链剖分和长链剖分较为常见。重链剖分就是将这个节点与其子节点的子树中节点个数最多的子节点（又称“重儿子”）与这个节点连在一起组成一条链，其余子节点各自成一条链；长链剖分就是将这个节点与其子节点的子树深度最深的子节点连在一起组成一条链，其与子节点各自成一条链。</p>
<p><img src="/post-images/Tree-chain-subdivision-1.png?300x" alt="1"></p>
<p>比如这样一棵树，对它进行重链剖分后就是这个样子：</p>
<p><img src="/post-images/Tree-chain-subdivision-2.png?500x" alt="2"></p>
<p>而长链剖分后就是这个样子：</p>
<p><img src="/post-images/Tree-chain-subdivision-3.png?500x" alt="3"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>树剖理解起来很容易，但是不容易实现。进行重链剖分对于每个节点，我们要处理一下信息：父亲，子树大小、深度、所在链头与重儿子。我们要进行两次 dfs，第一次处理基本信息：父亲、子树大小、深度与重儿子，第二次进行剖分，首先访问重儿子（顺序不能换，以后会用到），将当前节点的链头传递给重儿子；然后访问其余子节点，链头为子节点本身。这样我们就成功剖分了这棵树。<br>对于长链剖分，只需要将子树大小改为最大深度即可。</p>
<h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><p>要实现 LCA，我们需要先进行重链剖分，因为子树大小越多求这里面的点的可能越大。要找到点 $x$ 与点 $y$ 的 LCA，首先判断两个点有没有在同一条链中，也就是两个点的链头是否相同。如果不相同，将深度较深的点跳转至其链头的父节点，再进行判断；如果在，那么深度较浅的那一个点就是 LCA。证明也非常简单，如果不在同一条链中，深度较深的点所在的链头一定不是另一个点的祖先，所以 LCA 也一定不在这条链中，就跳到上一条链。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500001</span>;</span><br><span class="line"><span class="type">int</span> n,m,r,p=<span class="number">1</span>,t[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> f,s,d,t,z;</span><br><span class="line">&#125;T[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">road</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">&#125;a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=<span class="number">1</span>;</span><br><span class="line">    T[x].d=T[T[x].f].d+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==T[x].f) <span class="keyword">continue</span>;</span><br><span class="line">        T[a[i].m].f=x;</span><br><span class="line">        <span class="built_in">dfs1</span>(a[i].m);</span><br><span class="line">        T[x].s+=T[a[i].m].s;</span><br><span class="line">        <span class="keyword">if</span>(T[a[i].m].s&gt;T[T[x].z].s) T[x].z=a[i].m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].t=k;</span><br><span class="line">    <span class="keyword">if</span>(T[x].z!=<span class="number">0</span>) <span class="built_in">dfs2</span>(T[x].z,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==T[x].f||a[i].m==T[x].z) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dfs2</span>(a[i].m,a[i].m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T[x].t!=T[y].t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T[T[x].t].d&gt;=T[T[y].t].d) x=T[T[x].t].f;</span><br><span class="line">        <span class="keyword">else</span> y=T[T[y].t].f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].d&lt;T[y].d) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(x,y);</span><br><span class="line">        <span class="built_in">road</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r);</span><br><span class="line">    <span class="built_in">dfs2</span>(r,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>最小费用最大流Dinic</title>
    <url>/post/minimum-cost-maximum-flow-Dinic/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3381">P3381 【模板】最小费用最大流</a><br><a href="/post/minimum-cost-maximum-flow-problemlist/">费用流题单</a><br>前置知识：<a href="/post/minimum-cost-maximum-flow-EK/">最小费用最大流Dinic</a><br>我们已经学习了用 EK 解决费用流的问题，但是 EK 每一次增广都要一次 SPFA，效率低，于是我们想，费用流能不能用 Dinic 呢？答案是肯定的。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>最大流的 Dinic 就是用一次 bfs 来分层，然后进行 dfs，而费用流的 EK 用的是多次 SPFA，如果我们把 Dinic 中的 bfs 换成 SPFA 就可以了，只需要判断这条边是否在最短路图中，也就起点到这个点的距离加上边权等于下一个点到起点的距离。但是有一个问题，最大流中的分层图是不存在环路的，但是最短路图就有可能，就有可能死循环并 $\color{black}{\text{MLE}}$，我们需要用一个数组来判断一个点是否走过，到达这个点标记真，离开后标记为假。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>,M=<span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,v,s1,s2,t[N],t0[N];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="type">bool</span> h[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r,w;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e18</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;f[k]+a[i].w&lt;f[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+a[i].w;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e18</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(h[a[i].m]==<span class="literal">false</span>&amp;&amp;a[i].r&gt;<span class="number">0</span>&amp;&amp;f[a[i].m]==f[x]+a[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            ll z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            h[a[i].m]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">                v+=z*a[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s1,&amp;s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll r,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;r,&amp;w);</span><br><span class="line">        <span class="built_in">road</span>(x,y,r,w);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) </span><br><span class="line">        &#123;</span><br><span class="line">            t0[i]=t[i];</span><br><span class="line">            h[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld&quot;</span>,r,v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>P5030 长脖子鹿放置</title>
    <url>/post/P5030-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5030">P5030 长脖子鹿放置</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题和 P3355 很像，但是分组方法不一样。我们来看两个互相攻击的点有什么特点：$(x,y) \Leftrightarrow (x+1,y+3)$，$(x,y) \Leftrightarrow (x-1,y+3)$，$(x,y) \Leftrightarrow (x-3,y+1)$，$\cdots$。显然，任意两个相互攻击的点横纵坐标的奇偶性都不相同。这样我们只需要按横坐标的奇偶性分组即可，虽然可以分成 $4$ 组，但是没有必要，只要保证同一组内不相互攻击即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50001</span>,M=<span class="number">2000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,q,p=<span class="number">1</span>,s1,s2,t[N],t0[N],f[N];</span><br><span class="line"><span class="type">short</span> dx[<span class="number">8</span>]=&#123;<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-3</span>&#125;,dy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=m&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;q);</span><br><span class="line">    s1=m*n+<span class="number">1</span>;</span><br><span class="line">    s2=m*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="built_in">sum</span>(x,y)]==<span class="literal">true</span>) --i,--q;</span><br><span class="line">        b[<span class="built_in">sum</span>(x,y)]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="built_in">sum</span>(i,j)]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(s1,<span class="built_in">sum</span>(i,j),<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s1,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">7</span>;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i+dx[k],j+dy[k]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="number">1e18</span>);</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s2,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(s2,<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,m*n-q-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4304 [TJOI2013]攻击装置</title>
    <url>/post/P4304-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4304">P4304 [TJOI2013]攻击装置</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>同 P3355，双倍经验。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50001</span>,M=<span class="number">2000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[N],t0[N],f[N];</span><br><span class="line"><span class="type">short</span> dx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;,dy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    s1=n*n+<span class="number">1</span>;</span><br><span class="line">    s2=n*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++m;</span><br><span class="line">            <span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(s1,<span class="built_in">sum</span>(i,j),<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s1,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">7</span>;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i+dx[k],j+dy[k]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="number">1e18</span>);</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s2,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(s2,<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,m-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P3355 骑士共存问题</title>
    <url>/post/P3355-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3355">P3355 骑士共存问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题和 P2774 是一个类型的题，只是分组方式不同。我们来看两个互相攻击的点有什么特点：$(x,y) \Leftrightarrow (x+1,y+2)$，$(x,y) \Leftrightarrow (x-1,y+2)$，$(x,y) \Leftrightarrow (x-2,y+1)$，$\cdots$。不难发现，两个相互攻击的点横纵坐标之和奇偶性不同，我们就可以通过横纵坐标的奇偶性来分组。这道题还多了障碍物的限制，只要有障碍物的点不向外连边即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50001</span>,M=<span class="number">2000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[N],t0[N],f[N];</span><br><span class="line"><span class="type">short</span> dx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>&#125;,dy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> b[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    s1=n*n+<span class="number">1</span>;</span><br><span class="line">    s2=n*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        b[x][y]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i][j]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(s1,<span class="built_in">sum</span>(i,j),<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s1,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">7</span>;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i+dx[k],j+dy[k]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="number">1e18</span>);</span><br><span class="line">                        <span class="built_in">road</span>(<span class="built_in">sum</span>(i+dx[k],j+dy[k]),<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(<span class="built_in">sum</span>(i,j),s2,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(s2,<span class="built_in">sum</span>(i,j),<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,n*n-m-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2774 方格取数问题</title>
    <url>/post/P2774-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2774">P2774 方格取数问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这实际上也是一道网络流的问题，但是和以前做的题都不一样，同时也很难想到怎么做。题目中要求任意两个相邻的方格不能同时取，如果我们把一个方格放在 A 组，另一个方块放在 B 组，那么所有和 A 中方格相邻的方格都要放在 B 组，和 B 中方格相邻的都要放在 A 组。我们可以发现，同一组中方格横纵坐标的和奇偶性相同，这样我们就可以直接分组了。于是我们就把这个图分成了两组，只有两组之间有关系，同一组的方格没有关系，是不是很像二分图？我们把所有相邻的方格都用一条边连上，问题转换为删去一些节点，使得两组之间连通，求出删去节点权值的最小值。<br>于是我们又可以自然而然地想到最小割（最小割&#x3D;最大流），但是最小割删去的是边，而不是点。我们转化一下，将源点和 A 组所有点相连，汇点和 B 组所有点相连，容量均为该点对应的数，这样删去一条边的代价刚好是对应点的数值。但是我们不能删去两组之间的边，为了不删去这些边，把这些边的容量设为正无穷，就永远不可能删去这些边了。由于最小割 $&#x3D;$ 最大流，所以我们只需要跑一遍最大流即可。注意只能由 A 组连向 B 组或 B 组连向 A 组，不能同时连。<br>建出来的图大概长这样：<br><img src="/post-images/P2774-solution-1.png" alt="1"></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10001</span>,M=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[N],t0[N],f[N];</span><br><span class="line">ll q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    s1=m*n+<span class="number">1</span>;</span><br><span class="line">    s2=m*n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">            q+=r;</span><br><span class="line">            <span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(s1,(i<span class="number">-1</span>)*n+j,r);</span><br><span class="line">                <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,s1,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,(i<span class="number">-2</span>)*n+j,<span class="number">1e18</span>);</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-2</span>)*n+j,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,(i<span class="number">-1</span>)*n+j<span class="number">-1</span>,<span class="number">1e18</span>);</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j<span class="number">-1</span>,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i!=m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,i*n+j,<span class="number">1e18</span>);</span><br><span class="line">                    <span class="built_in">road</span>(i*n+j,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,(i<span class="number">-1</span>)*n+j+<span class="number">1</span>,<span class="number">1e18</span>);</span><br><span class="line">                    <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j+<span class="number">1</span>,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,s2,r);</span><br><span class="line">                <span class="built_in">road</span>(s2,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s2;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,q-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2472 [SCOI2007] 蜥蜴</title>
    <url>/post/P2472-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2472">P2472 [SCOI2007] 蜥蜴</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题同样也要拆点，每个点最多能经过的蜥蜴数就是它的高度，拆点后中间边的流量设为这个石柱的高度即可。剩下的就枚举两个合法石柱并建边，把源点和有蜥蜴的点相连，容量为 $1$，把能跳出地图的点与汇点相连。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n,N,d,o,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;m,&amp;n,&amp;d);</span><br><span class="line">    N=m*n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    s1=N<span class="number">-1</span>;</span><br><span class="line">    s2=N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">getchar</span>()-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a1=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                <span class="built_in">road</span>(a1+m*n,a1,r);</span><br><span class="line">                <span class="built_in">road</span>(a1,a1+m*n,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> z=<span class="built_in">getchar</span>();</span><br><span class="line">            <span class="keyword">if</span>(z==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++o;</span><br><span class="line">                <span class="type">int</span> a1=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                <span class="built_in">road</span>(s1,a1+m*n,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(a1+m*n,s1,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=d||i&gt;=m-d+<span class="number">1</span>||j&lt;=d||j&gt;=n-d+<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a1=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                <span class="built_in">road</span>(a1,s2,<span class="number">1e9</span>);</span><br><span class="line">                <span class="built_in">road</span>(s2,a1,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a1=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;++l)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> a2=(k<span class="number">-1</span>)*n+l;</span><br><span class="line">                    <span class="keyword">if</span>((i-k)*(i-k)+(j-l)*(j-l)&lt;=d*d)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">road</span>(a1,a2+m*n,<span class="number">1e9</span>);</span><br><span class="line">                        <span class="built_in">road</span>(a2+m*n,a1,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,o-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1402 酒店之王</title>
    <url>/post/P1402-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1402">P1402 酒店之王</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题也是一道需要拆点的题，和 P1231 一样，这里不再赘述。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,n1,n2,n3,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;n3);</span><br><span class="line">    n=n1*<span class="number">2</span>+n2+n3+<span class="number">2</span>;</span><br><span class="line">    s1=<span class="number">1</span>;</span><br><span class="line">    s2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(j+n1*<span class="number">2</span>+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(i+<span class="number">1</span>,j+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n3;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(i+n1+<span class="number">1</span>,j+n1*<span class="number">2</span>+n2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">road</span>(j+n1*<span class="number">2</span>+n2+<span class="number">1</span>,i+n1+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i+<span class="number">1</span>,i+n1+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+n1+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(<span class="number">1</span>,i+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n3;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i+n1*<span class="number">2</span>+n2+<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(n,i+n1*<span class="number">2</span>+n2+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1231 教辅的组成</title>
    <url>/post/P1231-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1231">P1231 教辅的组成</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题咋一看非常简单，只需要将书和练习册、答案的对应关系转换成边，每条边容量为 $1$，规定一个顺序：$\text{源点} \rightarrow \text{练习册} \rightarrow \text{书}\rightarrow \text{答案} \rightarrow \text{汇点}$。但是我们发现，如果简单地按照上面这种方式建图，可能有多于 $1$ 的流量流过一本书，也就是这本书被选了两次，这是不允许的。如何解决？这就要用到最大流的一个经典思想：拆点。<br><img src="/post-images/P1231-solution-1.png?400x" alt="1"><br>拆点的思想就是把一个点拆成两个点，其中入边全部连在一个点，出边连在另一个点，并把两个点用容量为 $1$ 的边相连，这样就可以保证流过每个点的流量最多为 $1$。将这个思想加入到上面建的图中，就可以解决这个问题了。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,n1,n2,n3,m1,m2,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;n3,&amp;m1);</span><br><span class="line">    n=n1*<span class="number">2</span>+n2+n3+<span class="number">2</span>;</span><br><span class="line">    s1=<span class="number">1</span>;</span><br><span class="line">    s2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(y+n1*<span class="number">2</span>+<span class="number">1</span>,x+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(x+<span class="number">1</span>,y+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">road</span>(x+n1+<span class="number">1</span>,y+n1*<span class="number">2</span>+n2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(y+n1*<span class="number">2</span>+n2+<span class="number">1</span>,x+n1+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i+<span class="number">1</span>,i+n1+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+n1+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(<span class="number">1</span>,i+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i+n1*<span class="number">2</span>+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n3;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(i+n1*<span class="number">2</span>+n2+<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(n,i+n1*<span class="number">2</span>+n2+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流题单</title>
    <url>/post/maximum-flow-problemlist/</url>
    <content><![CDATA[<p>这是 <a href="/post/maximum-flow-Dinic">最大流</a> 的几道经典题目，建议按照顺序来做。</p>
<p><a href="/post/P2740-solution">P2740 [USACO4.2]草地排水Drainage Ditches</a></p>
<p><a href="/post/P1343-solution">P1343 地震逃生</a></p>
<p><a href="/post/P2936-solution">P2936 [USACO09JAN]Total Flow S</a></p>
<p><a href="/post/P3254-solution">P3254 圆桌问题</a></p>
<p><a href="/post/P2763-solution">P2763 试题库问题</a></p>
<p><a href="/post/P2065-solution">P2065 [TJOI2011]卡片</a></p>
<p><a href="/post/P4638-solution">P4638 [SHOI2011]银行家</a></p>
<p><a href="/post/P2754-solution">P2754 [CTSC1999]家园 &#x2F; 星际转移问题</a></p>
<p><a href="/post/P1231-solution">P1231 教辅的组成</a></p>
<p><a href="/post/P1402-solution">P1402 酒店之王</a></p>
<p><a href="/post/P2472-solution">P2472 [SCOI2007] 蜥蜴</a></p>
<p><a href="/post/P2774-solution">P2774 方格取数问题</a></p>
<p><a href="/post/P3355-solution">P3355 骑士共存问题</a></p>
<p><a href="/post/P4304-solution">P4304 [TJOI2013]攻击装置</a></p>
<p><a href="/post/P5030-solution">P5030 长脖子鹿放置</a></p>
]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2754 [CTSC1999]家园 / 星际转移问题</title>
    <url>/post/P2754-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2754">P2754 [CTSC1999]家园 &#x2F; 星际转移问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题其实也可以用网络流来做，每一个太空站（地球、月球）在每个时间都建一个点。由于人可以在太空站上停留，所以每一个点都要向下一个时间的对应点连边，容量为正无穷。对于每个太空船将当前时间的起点和终点连接起来，容量为太空船的承载能力。建出来的图如下：<br><img src="/post-images/P2754-solution-1.png" alt="1"><br>（图片来自网络）<br>但是我们只能在确定时间的情况下求出最多的转移人数，无法直接求出最少天数，必须二分。但是还有另一个方法，假设我们已经跑了时间在 $m$ 以内的图，得到了最大流和残留网络，如果我们加上 $m+1$ 时间的点和边，再在残留网络上跑最大流，将得到的最大流加在原来的最大流上，是不是就可以得到 $m+1$ 天的转移人数了？因为这相当于我们已经找到了一些増广路，继续寻找更多増广路的过程。这样我们跑出 $1\sim m$ 时间的最大转移人数，只相当于跑了一遍时间 $m$ 的图上的最大流。对于无解情况，我们只需要选一个比较大的数，如果都跑不出来就判无解即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,M=<span class="number">200</span>,n,m,q,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],e[<span class="number">201</span>][<span class="number">501</span>],y[<span class="number">501</span>],z[<span class="number">501</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    n+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;z[i],&amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=y[i]<span class="number">-1</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e[i][j]);</span><br><span class="line">            e[i][j]+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s1=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        N=(i+<span class="number">1</span>)*n;</span><br><span class="line">        s2=i*n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">road</span>((i<span class="number">-1</span>)*n+j,i*n+j,<span class="number">1e9</span>);</span><br><span class="line">            <span class="built_in">road</span>(i*n+j,(i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">road</span>((i<span class="number">-1</span>)*n+e[j][(i<span class="number">-1</span>)%y[j]],i*n+e[j][i%y[j]],z[j]);</span><br><span class="line">            <span class="built_in">road</span>(i*n+e[j][i%y[j]],(i<span class="number">-1</span>)*n+e[j][(i<span class="number">-1</span>)%y[j]],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;++j) t0[j]=t[j];</span><br><span class="line">            r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2763 试题库问题</title>
    <url>/post/P2763-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2763">P2763 试题库问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道网络流问题，我们把每道题和所属类型相连，容量为 $1$，再将源点和每道题相连，容量为 $1$，汇点和每个类型相连，容量为地 $i$ 个类型的题数，如果跑出来的最大流和总题数相同，表示每个类型都有足够的题数，也就是有一个合法方案。<br>在跑完网络流后，要输出结果，我们可以观察残留网络。一条边有流量流过，表示这条边起点表示的题目被作为这条边终点表示的类型选中了。对于每个类型，找到它的出边，如果有剩余容量，表示其反向边有流量流过。当然每个类型的出边还有到汇点的边，但是这条边一定没有剩余容量，不用考虑。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,q=<span class="number">0</span>,N,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s2);</span><br><span class="line">    f[s2]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                ++g[f[a[i].m]];</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[x]==f[a[i].m]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --g[f[x]];</span><br><span class="line">    <span class="keyword">if</span>(g[f[x]]==<span class="number">0</span>) u=<span class="literal">false</span>;</span><br><span class="line">    ++f[x];</span><br><span class="line">    ++g[f[x]];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    N=n+m+<span class="number">2</span>;</span><br><span class="line">    s1=N<span class="number">-1</span>;</span><br><span class="line">    s2=N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(s1,i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i,s1,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r);</span><br><span class="line">        q+=r;</span><br><span class="line">        <span class="built_in">road</span>(m+i,s2,r);</span><br><span class="line">        <span class="built_in">road</span>(s2,m+i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=d;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="built_in">road</span>(i,m+x,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">road</span>(m+x,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t[m+i];j!=<span class="number">0</span>;j=a[j].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].r==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,a[j].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P3254 圆桌问题</title>
    <url>/post/P3254-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3254">P3254 圆桌问题</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题也比较容易发现是一道网络流，我们来考虑如何建图。左边 $m$ 个点代表每个单位，右边 $n$ 个点代表每个圆桌，每一个单位在一个圆桌只能有 $1$ 个人，也就是从每个单位到每个圆桌的边容量为 $1$。然后将源点与每个单位相连，容量为 $r_i$，将每个圆桌与汇点相连，容量为 $c_i$。最后跑一边最大流，得到的最大流就是答案。<br>由于有很多点，初始化的时候注意要初始化全部的点。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">0</span>,m1,m2,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s2);</span><br><span class="line">    f[s2]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                ++g[f[a[i].m]];</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[x]==f[a[i].m]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --g[f[x]];</span><br><span class="line">    <span class="keyword">if</span>(g[f[x]]==<span class="number">0</span>) u=<span class="literal">false</span>;</span><br><span class="line">    ++f[x];</span><br><span class="line">    ++g[f[x]];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m1,&amp;m2);</span><br><span class="line">    n=m1+m2+<span class="number">2</span>;</span><br><span class="line">    s1=<span class="number">1</span>;</span><br><span class="line">    s2=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        m+=r;</span><br><span class="line">        <span class="built_in">road</span>(<span class="number">1</span>,i+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">road</span>(i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(i+m1+<span class="number">1</span>,n,r);</span><br><span class="line">        <span class="built_in">road</span>(n,i+m1+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">road</span>(i+<span class="number">1</span>,j+m1+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">road</span>(j+m1+<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r!=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t[i+<span class="number">1</span>];j!=<span class="number">0</span>;j=a[j].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].m!=<span class="number">1</span>&amp;&amp;a[j].r==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[j].m-m1<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2936 [USACO09JAN]Total Flow S</title>
    <url>/post/P2936-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2936">P2936 [USACO09JAN]Total Flow S</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最大流的模板题，注意输入。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">127</span>;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    s1=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    s2=<span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x,y;</span><br><span class="line">        x=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>((x&lt;<span class="string">&#x27;A&#x27;</span>||x&gt;<span class="string">&#x27;Z&#x27;</span>)&amp;&amp;(x&lt;<span class="string">&#x27;a&#x27;</span>||x&gt;<span class="string">&#x27;z&#x27;</span>)) x=<span class="built_in">getchar</span>();</span><br><span class="line">        y=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">while</span>((y&lt;<span class="string">&#x27;A&#x27;</span>||y&gt;<span class="string">&#x27;Z&#x27;</span>)&amp;&amp;(y&lt;<span class="string">&#x27;a&#x27;</span>||y&gt;<span class="string">&#x27;z&#x27;</span>)) y=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(<span class="built_in">int</span>(x),<span class="built_in">int</span>(y),r);</span><br><span class="line">        <span class="built_in">road</span>(<span class="built_in">int</span>(y),<span class="built_in">int</span>(x),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2740 [USACO4.2]草地排水Drainage Ditches</title>
    <url>/post/P2740-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2740">P2740 [USACO4.2]草地排水Drainage Ditches</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最大流的模板。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,t[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;a[<span class="number">10000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].w&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[n]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> w;</span><br><span class="line">    ll v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>&amp;&amp;w!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].w&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(w,a[i].w));</span><br><span class="line">            a[i].w-=z;</span><br><span class="line">            a[i^<span class="number">1</span>].w+=z;</span><br><span class="line">            w-=z;</span><br><span class="line">            v+=z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v==<span class="number">0</span>) f[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        <span class="built_in">road</span>(x,y,w);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w+=<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P1343 地震逃生</title>
    <url>/post/P1343-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1343">P1343 地震逃生</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题我们把学生看成流量，可以发现这道题就是最大流模板题，注意处理分的批数。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,t[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].w&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[n]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].w&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(w,a[i].w));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].w-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].w+=z;</span><br><span class="line">                w-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        <span class="built_in">road</span>(x,y,w);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Orz Ni Jinan Saint Cow!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,s,<span class="built_in">int</span>(<span class="built_in">ceil</span>(r*<span class="number">1.0</span>/s)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P4360 [CEOI2004]锯木厂选址</title>
    <url>/post/P4360-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4360">P4360 [CEOI2004]锯木厂选址</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题与仓库建设十分相似，只是不需要一定在 $n$ 处建立锯木厂。由于只有 $2$ 个锯木厂，我们只需要先预处理好第一个锯木厂的情况，再斜率优化求出第二个锯木厂。把前两个锯木厂放好后，枚举第二个锯木厂的位置再加上剩下的木材运到山脚下的费用取最小值即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll a[N],b[N],c[N],f[N],g[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x]==a[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((g[x]+c[x])-(g[y]+c[y]))/(a[x]-a[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+x;</span><br><span class="line">        b[i+<span class="number">1</span>]=b[i]+y;</span><br><span class="line">        c[i]=c[i<span class="number">-1</span>]+x*b[i];</span><br><span class="line">        g[i]=b[i]*a[i]-c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&lt;b[i]) ++T;</span><br><span class="line">        f[i]=g[Q[T]]+b[i]*(a[i]-a[Q[T]])-(c[i]-c[Q[T]]);</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],i)&lt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="built_in">min</span>(s,f[i]+b[n+<span class="number">1</span>]*(a[n]-a[i])-(c[n]-c[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P5785 [SDOI2012]任务安排</title>
    <url>/post/P5785-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5785">P5785 [SDOI2012]任务安排</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题和往常的斜率优化 dp 不太一样。我们设计的状态要做到一维，就只能储存当前处理到了哪个任务，已经分了多少批就无法储存，但是处理的批数不同会导致启动时间不同，会对后面的 dp 产生影响。这里有一个非常巧妙的方法，我们知道后面所有任务的费用系数，就可以把启动时间对后面所有任务的影响提前计算，也就是在费用中加上 $s \times (b[n]-b[j])$，其中 $a$ 是完成所需时间的前缀和，$b$ 是费用系数的前缀和。于是我们可以得到转移方程：<br>$$f[i]&#x3D;f[j]+a[i] \times (b[i]-b[j])+s \times (b[n]-b[j])$$<br>$$f[j]-s \times b[j]&#x3D;a[i] \times b[j]+f[i]-a[i] \times b[i]-s \times b[n]$$<br>但是还有一个问题，数据范围中写道 $|T_i| \leqslant 2^8$，什么意思，说明 $T_i$ 可能是负的，也就是 $a$ 不单调。所以我们就不能用单调队列了，需要每一次在队列中二分查找，直到前一条线段斜率比它小，后一条线段斜率大于等于它。我们还是需要维护整个队列的“下凸性”，如果队尾存在“上凸”，还是要将队尾出队。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300001</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll a[N],b[N],f[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[x]==b[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((f[x]-m*b[x])-(f[y]-m*b[y]))/(b[x]-b[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+x;</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+y;</span><br><span class="line">    &#125;</span><br><span class="line">    Q[++R]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=T,r=R;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abc</span>(Q[z],Q[z+<span class="number">1</span>])&lt;a[i]) l=z+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abc</span>(Q[z],Q[z+<span class="number">1</span>])&gt;a[i]) r=z;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                l=z;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=f[Q[l]]+a[i]*(b[i]-b[Q[l]])+m*(b[n]-b[Q[l]]);</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],i)&lt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化dp题单</title>
    <url>/post/Slope-optimization-DP-problemlist/</url>
    <content><![CDATA[<p>这是 <a href="/post/Slope-optimization-DP">斜率优化dp</a> 的几道经典题目，建议按照顺序来做。</p>
<p><a href="/post/P3195-solution">P3195 [HNOI2008]玩具装箱</a></p>
<p><a href="/post/P3628-solution">P3628 [APIO2010]特别行动队</a></p>
<p><a href="/post/P2120-solution">P2120 [ZJOI2007]仓库建设</a></p>
<p><a href="/post/P4072-solution">P4072 [SDOI2016]征途</a></p>
<p><a href="/post/P3648-solution">P3648 [APIO2014]序列分割</a></p>
<p><a href="/post/P4360-solution">P4360 [CEOI2004]锯木厂选址</a></p>
<p><a href="/post/P5785-solution">P5785 [SDOI2012]任务安排</a></p>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3648 [APIO2014]序列分割</title>
    <url>/post/P3648-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3648">P3648 [APIO2014]序列分割</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题也是一个分层斜率优化 dp，但是一眼看上去毫无头绪，我们会发现每一次操作的位置可以在上一次操作之前。但是我们来推一下：有三个数 $a,b,c$，如果我们先分开 $a,b$，再分开 $b.c$，得到的结果为 $a \times b+(a+b) \times c&#x3D;a\times b+b\times c+c\times a$；如果我们先分开 $b,c$，再分开 $a,b$，得到的结果为 $b \times c+(b+c) \times a&#x3D;a\times b+b\times c+c\times a$。这两种情况的结果是一样的，说明最终结果与切的顺序无关，只与切的位置有关。我们就假设切的位置递增，就可以用斜率优化 dp 了，$f[i]$ 表示最后一次切的位置是 $i-1$ 与 $i$ 即可。<br>另外，这道题要求求出最优情况的方案，我们只需要用一个 $h$ 数组来记录，$h[i][j]$ 表示切了 $i$ 次，最后一次切的位置是$j-1$ 与 $j$ 的情况中上一个切的位置。由于这里不管顺序，最后直接倒序输出也可以。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>,M=<span class="number">201</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q[N*<span class="number">2</span>],h[M][N],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll a[N],f[N],g[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x]==a[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((g[x]-a[x]*a[x])-(g[y]-a[y]*a[y]))/(a[x]-a[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">        Q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&gt;-a[j]) ++T;</span><br><span class="line">            f[j]=g[Q[T]]+a[Q[T]]*(a[j]-a[Q[T]]);</span><br><span class="line">            h[i][j]=Q[T];</span><br><span class="line">            <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],j)&gt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">            Q[++R]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j) g[j]=f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m,j=h[m][n];i&gt;=<span class="number">1</span>;j=h[--i][j]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3628 [APIO2010]特别行动队</title>
    <url>/post/P3628-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3628">P3628 [APIO2010]特别行动队</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这时一道斜率优化 dp 的裸题，简单地推一下转移方程，$s$ 为战斗力前缀和：<br>$$f[i]&#x3D;f[j]+a \times (s[i]-s[j])^2+b \times (s[i]-s[j])+c$$<br>$$f[i]&#x3D;f[j]+a \times s[i]^2-2 \times a \times s[i] \times s[j]+a \times s[j]^2+b \times s[i]-b \times s[j]+c$$<br>$$f[j]-a \times s[j]^2+b \times b[j]&#x3D;2 \times a \times s[i] \times s[j]+f[i]-a \times s[i]^2-b \times s[i]-c$$<br>可以得到 $Y&#x3D;f[j]-a \times s[j]^2+b \times b[j]$，$A&#x3D;2 \times a \times s[i]$，$X&#x3D;s[j]$，$B&#x3D;f[i]-a \times s[i]^2-b \times s[i]-c$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3000001</span>;</span><br><span class="line"><span class="type">int</span> n,a,b,c,Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll d[N],f[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]==d[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((f[x]+a*d[x]*d[x]-b*d[x])-(f[y]+a*d[y]*d[y]-b*d[y]))/(d[x]-d[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&gt;<span class="number">2</span>*a*d[i]) ++T;</span><br><span class="line">        f[i]=f[Q[T]]+a*(d[i]-d[Q[T]])*(d[i]-d[Q[T]])+b*(d[i]-d[Q[T]])+c;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])&lt;<span class="built_in">abc</span>(Q[R],i)) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P3195 [HNOI2008]玩具装箱</title>
    <url>/post/P3195-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008]玩具装箱</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>斜率优化 dp 的裸题，用 $s$ 表示前缀和，只是转移方程比较复杂：<br>$$f[i]&#x3D;f[j]+(i-j-1+s[i]-s[j]-L)^2$$<br>我们稍微化简一下，设 $b[i]&#x3D;s[i]+i$，$c[i]&#x3D;s[i]+i+L+1$，上述转移方程就可以写成：<br>$$f[i]&#x3D;f[j]+(b[i]-c[j])^2$$<br>$$f[i]&#x3D;f[j]+b[i]^2-2 \times b[i] \times c[j]+c[j]^2$$<br>$$f[j]+c[j]^2&#x3D;2 \times b[i] \times c[j]+f[i]-b[i]^2$$<br>于是，我们可以得到 $Y&#x3D;f[j]+c[j]^2$，$A&#x3D;2 \times b[i]$，$X&#x3D;c[j]$，$B&#x3D;f[i]-b[i]^2$</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll b[N],c[N],f[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[x]==c[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((f[x]+c[x]*c[x])-(f[y]+c[y]*c[y]))/(c[x]-c[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    c[<span class="number">0</span>]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i]+<span class="number">1</span>;</span><br><span class="line">        c[i]=c[i<span class="number">-1</span>]+a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&lt;<span class="number">2</span>*b[i]) ++T;</span><br><span class="line">        f[i]=f[Q[T]]+b[i]*b[i]<span class="number">-2</span>*b[i]*c[Q[T]]+c[Q[T]]*c[Q[T]];</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],i)&lt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P2120 [ZJOI2007]仓库建设</title>
    <url>/post/P2120-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2120">P2120 [ZJOI2007]仓库建设</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是一道很经典又很裸的斜率优化 dp，用 $f[i]$ 表示在 $i$ 号点建立仓库的最小费用，用斜率优化即可。但是转移的时候，我们需要知道第 $j+1$ 个仓库至第 $i$ 个仓库之间的所有仓库到仓库 $i$ 的距离，也就是<br>$$\sum_{k&#x3D;j+1}^{i} (b[k] \times (a[i]-a[k]))$$<br>我们把这个式子拆开，得到<br>$$\sum_{k&#x3D;j+1}^{i} (b[k] \times a[i])-\sum_{k&#x3D;j+1}^{i} (b[k] \times a[k])$$<br>也就是<br>$$a[i] \times \sum_{k&#x3D;j+1}^{i} b[k]-\sum_{k&#x3D;j+1}^{i} (b[k] \times a[k])$$<br>我们只需要把 $b[i]$ 和 $a[i] \times b[i]$ 分别前缀和，就可以解决这个问题了。<br>但是，如果你打的是裸的斜率优化，你就会发现神奇的东西 $\color{red}{\text{Unaccepted 100}}$。为什么？这 hack 数据是真的神，因为我们忽略了一点，如果后面有一堆仓库没有成品怎么办。这种情况下我们就不一定要在 $n$ 工厂建仓库了，只需要在第一个有成品的工厂之后建即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3000001</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],c[N],Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll d[N],e[N],f[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]==d[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((f[x]+e[x])-(f[y]+e[y]))/(d[x]-d[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">        d[i]=d[i<span class="number">-1</span>]+b[i];</span><br><span class="line">        e[i]=e[i<span class="number">-1</span>]+a[i]*b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&lt;a[i]) ++T;</span><br><span class="line">        f[i]=f[Q[T]]+a[i]*(d[i]-d[Q[T]])-(e[i]-e[Q[T]])+c[i];</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])&gt;<span class="built_in">abc</span>(Q[R],i)) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll s=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="built_in">min</span>(s,f[i]);</span><br><span class="line">        <span class="keyword">if</span>(b[i]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P4072 [SDOI2016]征途</title>
    <url>/post/P4072-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4072">P4072 [SDOI2016]征途</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是分了层的斜率优化 dp，它与普通的斜率优化的不同之处就是它限制了只能分成 $m$ 段，所以我们需要先枚举走多少段。对于每一段，重新开一个单调队列存储点，但是这个单调队列维护的每一个点上一次的信息。假设当前走了 $i$ 段，那么单调队列维护的就是 $i-1$ 段的信息。我们不需要在算出 $i$ 天的情况时就建立单调队列，我们只需要在更新 $i+1$ 段的时候依次将第 $i$ 天的信息入队即可。<br>为了节约空间和方便建立单调队列，这里使用滚动数组存储信息。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10001</span>,N=<span class="number">10001</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>,f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x]==a[y]) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">return</span> ((g[x]+a[x]*a[x])-(g[y]+a[y]*a[y]))/(a[x]-a[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+x;</span><br><span class="line">        g[i]=<span class="number">1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&lt;<span class="number">2</span>*a[j]) ++T;</span><br><span class="line">            f[j]=g[Q[T]]+(a[j]-a[Q[T]])*(a[j]-a[Q[T]]);</span><br><span class="line">            <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],j)&lt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">            Q[++R]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j) g[j]=f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]*m-a[n]*a[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化dp</title>
    <url>/post/Slope-optimization-DP/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经典题：<a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008]玩具装箱</a><br><a href="/post/Slope-optimization-DP-problemlist/">斜率优化题单</a><br>之前我们学习了单调队列优化 dp，它可以用来解决转移方程中有 $i,j$ 相关项的和。但是如果转移方程中有 $i,j$ 的乘积项 $f[i]&#x3D;\min(f[j]+x \times a[i]+y \times a[j]+z \times a[i] \times a[j])(1\leqslant j &lt; i)$，单调队列就无法解决这种问题了，因为对于不同的 $i$，$j$ 相关项的最小值并不相同。所以我们需要用新的方法来解决。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>我们再来改写一下转移方程，就变成：$f[j]+y \times a[j]&#x3D;-z \times a[i] \times a[j]+f[i]-x \times a[i](1\leqslant j &lt; i)$，当 $i$ 不变时，以 $j$ 为自变量，于是这个转移方程就变成了一个一次函数 $Y&#x3D;A \times X+B$，其中 $Y&#x3D;f[j]+y \times a[j]$，$A&#x3D;-z \times a[i]$，$X&#x3D;a[j]$，$B&#x3D;f[i]-x \times a[i]$。如果我们要求 $f[i]$ 最小值，我们就是要求 $B$ 的最大值。我们先把已经求出的所有点 $P(X,Y)$ 画出来：<br><img src="/post-images/Slope-optimization-DP-1.png" alt="1"><br>我们再画一条直线，直线的斜率就是 $A$，如果这条直线过点 $P(X_j,Y_j)$ ，那么对于这条直线这条直线就可以列出 $Y_j&#x3D;A \times X_j+B$，而 $B$ 就是我们要求的值。我们就要让 $B$ 尽量地小，也就是直线要尽量靠下。<br><img src="/post-images/Slope-optimization-DP-2.png" alt="2"><br><img src="/post-images/Slope-optimization-DP-3.png" alt="3"></p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>就像这样我们就找到了 $B$ 的最小值，那么我们要如何实现呢？我们可以发现，如果一个点与他左右的两个点形成了“上凸”的形状，如上图的 $P_4$，可以肯定，这个点不可能成为一个最优解，也就是任意斜率的直线在 $B$ 最小的时候都不会经过这个点，那么我们就可以删去这个点。于是图就变成了这样：<br><img src="/post-images/Slope-optimization-DP-4.png" alt="4"><br>下图是三根不同斜率的直线在 $B$ 取得最小值的情况，可以发现，每一条线过的第一个点，左边的线段的斜率小于这条直线的斜率，右边的线段大于等于这条直线时，$B$ 取得最小值。<br><img src="/post-images/Slope-optimization-DP-5.png" alt="5"><br>于是我们自然而然地想到二分查找，可以在 $O(n\log n)$ 的时间内完成。但是一般情况下，$a$ 是递增的，也就是说直线的斜率也是递增的。在这种情况下，我们又可以用单调队列了，只需要维护所有比当前直线斜率大的线段即可。枚举 $i$，对于每个 $i$：首先弹出队首，知道队首点和它的下一个点的线段斜率比直线 $i$ 的斜率小，就一直弹出队首。然后用队首点计算 $f[i]$。然后弹出队尾，如果队尾点与它的上一个点的线段斜率比点 $i(X_i,Y_i)$ 与队尾点的线段斜率大，也就是出现“上凸”，就一直弹出队尾。最后将点 $i$ 入队。<br>于是我们用 $O(n)$ 的时间完成了这个 dp，这就是著名的斜率优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们来总结一下斜率优化的普遍规律。对于一个转移方程，$Y$ 就是只与 $j$ 有关的项，$A$ 就是 $i,j$ 的乘积项中与 $i$ 有关的因式，$X$ 就是 $i,j$ 乘积项中与 $j$ 有关的因式，$B$ 就是只与 $i$ 有关的项。知道了这些，就可以轻松解决许多斜率优化 dp 的题目了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>实现斜率优化时需要注意几点：注意最小值与最大值的区别，最大值的判断方法与最小值相反，也就是整个图形是上凸的，每一个直线 $B$ 最大的时候前一个线段斜率比它大，后一个线段斜率比它小。注意计算斜率时判断两个点横坐标是否相同，如果忽略则会导致出现 $\div 0$ 的情况出现，直接 $\color{purple}{\text{RE}}$。<br>但是有的时候数组 $a$ 并不单调，意味着直线的斜率也不是单调的，这是我们就需要保存所有的节点，每一次二分查找，时间 $O(n\log n)$。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>此代码为经典题 <a href="https://www.luogu.com.cn/problem/P3195">P3195</a> 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],Q[N*<span class="number">2</span>],T=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">ll b[N],c[N],f[N];</span><br><span class="line"><span class="function">ll <span class="title">abc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c[x]==c[y]) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">return</span> ((f[x]+c[x]*c[x])-(f[y]+c[y]*c[y]))/(c[x]-c[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    c[<span class="number">0</span>]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i]+<span class="number">1</span>;</span><br><span class="line">        c[i]=c[i<span class="number">-1</span>]+a[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[T],Q[T+<span class="number">1</span>])&lt;<span class="number">2</span>*b[i]) ++T;</span><br><span class="line">        f[i]=f[Q[T]]+b[i]*b[i]<span class="number">-2</span>*b[i]*c[Q[T]]+c[Q[T]]*c[Q[T]];</span><br><span class="line">        <span class="keyword">while</span>(T&lt;R&amp;&amp;<span class="built_in">abc</span>(Q[R],i)&lt;<span class="built_in">abc</span>(Q[R<span class="number">-1</span>],Q[R])) --R;</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列优化dp</title>
    <url>/post/Monotone-queue-dp/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经典题：<a href="https://www.luogu.com.cn/problem/P2627">P2627 [USACO11OPEN]Mowing the Lawn G</a><br>如果 dp 中每一个状态 $f[i]$ 都需要由 $f[j]$ 推过来，形如 $f[i]&#x3D;\max(f[j]+x\times a[i]+y\times a[j])(i-k\leqslant j &lt; i)$ 或 $f[i]&#x3D;\min(f[j]+x\times a[i]+y\times a[j])(i-k\leqslant j &lt; i)$，这类转移方程的特点是转移方程中有与 $i$ 相关的项和与 $j$ 相关的项的和。如果用朴素方法，就需要枚举 $i,j$ 复杂度为 $O(n^2)$。于是我们就需要一个方法来优化它。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>但是有没有发现，如果我们改写一下转移方程，就变成了 $f[i]-x\times a[i]&#x3D;\min(f[j]+y\times a[j])(i-k\leqslant j &lt; i)$，对于一个固定的 $i$，左边是定值，我们只需要找到 $[i-k,i)$ 中 $f[j]+y\times a[j]$ 的最小值（最大值）即可。如何实现？显然，可以用单调队列来实现，我们可以类比之前学过的单调队列优化背包问题，其实实质是一样的。<br>于是问题就转化为了求出一个长度为 $k$ 的区间的最小值（最大值），具体实现方法如下：枚举 $i$ ，对于每个 $i$，作如下操作。首先弹出队头，如果队头元素超出了区间范围就一直弹出。然后弹出队尾，如果队尾元素比当前元素大（小）就一直弹出队尾。取队首元素为 $j$，更新 $f[i]$。最后将 $i$ 入队。<br>注意，这里建议手写队列而不是使用双端队列 deque，因为 deque 的常数实在是太大了。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>$#8195; 此代码为例题 <a href="https://www.luogu.com.cn/problem/P2627">P2627</a> 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],Q[N],T=<span class="number">0</span>,R=<span class="number">-1</span>;</span><br><span class="line">ll b[N],f[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Q[++R]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;i-Q[T]&gt;m) ++T;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;f[Q[R]][<span class="number">0</span>]-b[Q[R]]&lt;=f[i][<span class="number">0</span>]-b[i]) --R;</span><br><span class="line">        f[i][<span class="number">1</span>]=f[Q[T]][<span class="number">0</span>]+b[i]-b[Q[T]];</span><br><span class="line">        Q[++R]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>单调队列优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI Online 2022 提高组] 丹钓战</title>
    <url>/post/P8251-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8251">P8251 [NOI Online 2022 提高组] 丹钓战</a><br>这道题我的方法是<strong>主席树</strong>，请不了解主席树的同学移步这道题： <a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="模拟入栈"><a href="#模拟入栈" class="headerlink" title="模拟入栈"></a>模拟入栈</h3><p>首先我们可以发现，这个栈的元素 $b_i$ 一定是单调下降的，如果要模拟入栈的操作，我们可以通过二分查找第一个比 $b_i$ 大的元素来模拟，可以在 $n\log n$ 的复杂度内完成一次模拟。但是同时还要满足任意两个相邻元素的 $a$ 不同，我们只需要在找到第一个比 $b_i$ 大的元素后，弹出栈顶直到栈顶元素的 $a$ 与 $a_i$ 不相等。注意要首先把 $inf$ 入栈，防止越界。<br>$b$ 代表 $b$ 序列，$c$ 代表栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=t,z;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line"> &#123;</span><br><span class="line">    z=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[i]&lt;b[c[z]]) l=z;</span><br><span class="line">    <span class="keyword">else</span> r=z<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(a[c[l]]==a[i]) --l;</span><br></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>如果我们先把所有元素按顺序入栈，由于任意的 $[l,r]$ 都应该是 $[1,n]$ 的一部分，并且栈中的元素编号一定递减，所以 $\forall [l,r]$，最终形成的栈一定是 $[1,r]$ 形成的栈的一部分，具体来说就是 $[1,r]$ 形成的栈去掉所有编号比 $l$ 小的元素。如果 $r$ 号元素想要在 $[l,r]$ 形成的栈中成为第一个，那么 $[1,r]$ 所形成的的栈中在 $r$ 之前的元素的编号必然都比 $l$ 小，只有这样前面所有元素才会被删去。所以用 $d$ 来储存每个数入栈后前一个元素的编号，那么 $[l,r]$ 中成功二元组的个数就是 $k \in [l,r],d_k &lt; l$ 成立的 $k$ 的个数。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>但是上面这种方法的复杂度为 $O(n\times q)$ ，显然过不了。通过上面的分析，我们发现查询的实质是求 $d$ 中 $[l,r]$ 中小于 $l$ 的数的个数。有什么数据结构能实现？主席树！于是这道题就变成了主席树的板子题。然后，就没有然后了。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="type">int</span> x=<span class="number">0</span>;<span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())f^=!(c^<span class="number">45</span>);</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f)x=-x;<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,p,t,a[<span class="number">500001</span>],b[<span class="number">500001</span>],c[<span class="number">500001</span>],rt[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,s;</span><br><span class="line">&#125;T[<span class="number">30000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].l].s+T[T[x].r].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(T[x].l,l,z);</span><br><span class="line">    <span class="built_in">build</span>(T[x].r,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[++p]=T[x];</span><br><span class="line">    ++T[p].s;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=z) <span class="built_in">modify</span>(T[x].l,l,z,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(T[x].r,z+<span class="number">1</span>,r,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==z) <span class="keyword">return</span> T[T[x].l].s;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;z) <span class="keyword">return</span> <span class="built_in">num</span>(T[x].l,l,z,k);</span><br><span class="line">    <span class="keyword">return</span> T[T[x].l].s+<span class="built_in">num</span>(T[x].r,z+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;stack.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;stack.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">1e9</span>;</span><br><span class="line">    c[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt[<span class="number">0</span>],<span class="number">0</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=t,z;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            z=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[i]&lt;b[c[z]]) l=z;</span><br><span class="line">            <span class="keyword">else</span> r=z<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[c[l]]==a[i]) --l;</span><br><span class="line">        t=l+<span class="number">1</span>;</span><br><span class="line">        c[t]=i;</span><br><span class="line">        rt[i]=rt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">modify</span>(rt[i],<span class="number">0</span>,n,c[l]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">num</span>(rt[r],<span class="number">0</span>,n,l<span class="number">-1</span>)-<span class="built_in">num</span>(rt[l<span class="number">-1</span>],<span class="number">0</span>,n,l<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>可持续化线段树</tag>
        <tag>主席树</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡树Splay</title>
    <url>/post/Balanced-tree-Splay/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3369">P3369 【模板】普通平衡树</a><br>我们已经学会了使用 Treap 来实现平衡树的功能，但是还有很多其他其它的平衡树，比如 Splay，Splay 不仅有平衡树功能，还可以用于其它地方，这是其它平衡树无法做到的。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>Splay 的核心是提根操作，也就是把一个节点提到根节点，每一次操作后都将当前节点提到根节点，这样 Splay 的形状就是在不断变化的，就可以较好地防止被卡。<br>Splay 的提根操作不止是讲一个节点提到根节点，它可以将一个节点提到它的某个祖先的儿子节点，这样在一些操作时直接将要操作的节点提到指定位置就可以很简单地解决问题。</p>
<h2 id="储存与更新"><a href="#储存与更新" class="headerlink" title="储存与更新"></a>储存与更新</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">splay</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k,a[<span class="number">2</span>],f,s,t;</span><br><span class="line">&#125;T[<span class="number">10000001</span>];</span><br></pre></td></tr></table></figure>
<p>Splay 需要储存当前节点的元素值 $k$，左右儿子 $a$，父节点 $f$，当前节点子树的元素总数 $s$，当前节点的元素个数 $t$。<br>Splay 的更新方法与Treap相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].a[<span class="number">0</span>]].s+T[T[x].a[<span class="number">1</span>]].s+T[x].t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提根操作"><a href="#提根操作" class="headerlink" title="提根操作"></a>提根操作</h2><p>Splay 的提根操作同样也要用到 Treap 中的旋转操作，但是它不分左旋和右旋，旋转都是将当前节点旋转到它的父节点的位置。这样一直旋转，直到旋转到对应位置就停止即可。实际上我们会把当前节点旋转到目标节点的儿子节点，要判断当前节点的父节点是否为目标节点。<br>Splay 的旋转操作比较麻烦，因为我们需要在旋转的同时判断当前节点 $x$ 与其父节点 $y$、祖父节点 $z$ 的关系。用 $k$ 来储存当前节点 $x$ 是 $y$ 的左儿子还是右儿子，$0$ 表示左儿子，$1$ 表示右儿子。首先 $x$ 连接到 $z$ 的下面，替换 $y$ 的位置；接着把 $x$ 的儿子接到 $y$ 下面；最后把 $y$ 接在 $x$ 的下面。这里用了一个技巧：$k$^$1$ 其实就是 $y$ 除了 $k$ 的另一个儿子，当 $k$  为 $0$ 是，$k$^$1$ 为 $1$ 。<br>由于 $0$ 的儿子就是根节点 $rt$，所以如果目标是 $0$，当前节点就是根节点，需要在最后判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=T[x].f,z=T[y].f,k=T[y].a[<span class="number">1</span>]==x;</span><br><span class="line">    T[z].a[T[z].a[<span class="number">1</span>]==y]=x;</span><br><span class="line">    T[x].f=z;</span><br><span class="line">    T[y].a[k]=T[x].a[k^<span class="number">1</span>];</span><br><span class="line">    T[T[x].a[k^<span class="number">1</span>]].f=y;</span><br><span class="line">    T[x].a[k^<span class="number">1</span>]=y;</span><br><span class="line">    T[y].f=x;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T[x].f!=k) <span class="built_in">rotate</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建树操作"><a href="#建树操作" class="headerlink" title="建树操作"></a>建树操作</h2><p>不知道为什么，Splay 不加上下界就会 $\color{red}{WA}$，但是 Treap 就不会。我们需要在最开始时插入两个节点：正无穷和负无穷，来防止越界。根节点最好手动添加，另一个就用插入操作即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt=q=<span class="number">1</span>;</span><br><span class="line">    T[<span class="number">1</span>].f=<span class="number">0</span>;</span><br><span class="line">    T[<span class="number">1</span>].s=T[<span class="number">1</span>].t=<span class="number">1</span>;</span><br><span class="line">    T[<span class="number">1</span>].k=<span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">add</span>(rt,<span class="number">0</span>,<span class="number">-1e9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>Splay 的很多操作与 Treap 极其类似，包括插入操作，只需要在最后的时候进行提根改变Splay的形状即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++q;</span><br><span class="line">        T[x].k=k;</span><br><span class="line">        T[x].t=T[x].s=<span class="number">1</span>;</span><br><span class="line">        T[x].f=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].k==k)</span><br><span class="line">    &#123;</span><br><span class="line">        ++T[x].t;</span><br><span class="line">        ++T[x].s;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T[x].k) <span class="built_in">add</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>利用 Splay 可以改变形状的特点，就可以用独特的方法来删除节点。如果通过提根来使要删除的节点成为叶子结点，就可以直接删除这个点。我们可以先找到这个节点 $x$ 的前驱 $l$ 与后继 $r$，$l$ 和 $r$ 之间只有一个节点 $x$。我们先把 $l$ 提到根节点，再将 $r$ 提到 $l$ 的儿子节点。由于 $T[r].k&gt;T[l].k$ ，所以 $r$ 一定是 $l$ 的右子节点。而 $r$ 的左子树，也就是比 $l$ 大而比 $r$ 小的部分就只有一个节点 $x$，直接删除或元素个数减一即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">find_f</span>(rt,rt,k),r=<span class="built_in">find_b</span>(rt,rt,k);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">splay</span>(r,l);</span><br><span class="line">    --T[T[r].a[<span class="number">0</span>]].t;</span><br><span class="line">    --T[T[r].a[<span class="number">0</span>]].s;</span><br><span class="line">    <span class="keyword">if</span>(T[T[r].a[<span class="number">0</span>]].t==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T[T[r].a[<span class="number">0</span>]].k=<span class="number">0</span>;</span><br><span class="line">        T[r].a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(r,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询排名"><a href="#查询排名" class="headerlink" title="查询排名"></a>查询排名</h2><p>在 Splay 中，查询一个元素的排名十分简单，就只需要将这个元素 $x$ 的前驱 $l$ 提到根节点，那么根节点与左子树中的元素一定比这个元素小。而且不存在一个元素比 $l$ 大而比 $x$ 小，也就是 $x$ 没有左儿子，说明比 $x$ 小的元素全部都在根节点与左子树中。所以 $x$ 的排名就是左子树的大小加上根节点的元素个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(<span class="built_in">find_f</span>(rt,rt,k),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> T[T[rt].a[<span class="number">0</span>]].s+T[rt].t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询对应排名的元素"><a href="#查询对应排名的元素" class="headerlink" title="查询对应排名的元素"></a>查询对应排名的元素</h2><p>Splay 的这个操作和 Treap 相同，只需要找到这个节点后将其提根即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;T[T[x].a[<span class="number">0</span>]].s+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].a[<span class="number">0</span>],k);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[T[x].a[<span class="number">0</span>]].s+T[x].t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].a[<span class="number">1</span>],k-T[T[x].a[<span class="number">0</span>]].s-T[x].t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询前驱和后继"><a href="#查询前驱和后继" class="headerlink" title="查询前驱和后继"></a>查询前驱和后继</h2><p>Splay 查询前驱后后继的操作也和 Treap 相同，只需要记录当前节点 $x$ 的根节点 $f$，并在找到了不存在的节点，也就是 $x&#x3D;0$，那么就将这个点的上一个点也就是 $f$ 提根。对于后继的操作也一模一样。<br>由于 Splay 很多操作都要用到前驱和后继，所以这里的前驱和后继返回的都是节点编号，而不是元素的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(f,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_f</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_f</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_b</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(f,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_b</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_b</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Splay的调用"><a href="#Splay的调用" class="headerlink" title="Splay的调用"></a>Splay的调用</h2><p>Splay 的这些操作调用方法与 Treap 一样，只有前驱、后继和相应排名的元素是返回的节点编号，需要转换为元素值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;z,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="built_in">add</span>(rt,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="built_in">remove</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">num</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">sum</span>(rt,k+<span class="number">1</span>)].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">find_f</span>(rt,rt,k)].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">find_b</span>(rt,rt,k)].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,rt=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">splay</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k,a[<span class="number">2</span>],f,s,t;</span><br><span class="line">&#125;T[<span class="number">10000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].a[<span class="number">0</span>]].s+T[T[x].a[<span class="number">1</span>]].s+T[x].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=T[x].f,z=T[y].f,k=T[y].a[<span class="number">1</span>]==x;</span><br><span class="line">    T[z].a[T[z].a[<span class="number">1</span>]==y]=x;</span><br><span class="line">    T[x].f=z;</span><br><span class="line">    T[y].a[k]=T[x].a[k^<span class="number">1</span>];</span><br><span class="line">    T[T[x].a[k^<span class="number">1</span>]].f=y;</span><br><span class="line">    T[x].a[k^<span class="number">1</span>]=y;</span><br><span class="line">    T[y].f=x;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T[x].f!=k) <span class="built_in">rotate</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++q;</span><br><span class="line">        T[x].k=k;</span><br><span class="line">        T[x].t=T[x].s=<span class="number">1</span>;</span><br><span class="line">        T[x].f=f;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[x].k==k)</span><br><span class="line">    &#123;</span><br><span class="line">        ++T[x].t;</span><br><span class="line">        ++T[x].s;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T[x].k) <span class="built_in">add</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rt=q=<span class="number">1</span>;</span><br><span class="line">    T[<span class="number">1</span>].f=<span class="number">0</span>;</span><br><span class="line">    T[<span class="number">1</span>].s=T[<span class="number">1</span>].t=<span class="number">1</span>;</span><br><span class="line">    T[<span class="number">1</span>].k=<span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">add</span>(rt,<span class="number">0</span>,<span class="number">-1e9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(f,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_f</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_f</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_b</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(f,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_b</span>(T[x].a[<span class="number">1</span>],x,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_b</span>(T[x].a[<span class="number">0</span>],x,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">find_f</span>(rt,rt,k),r=<span class="built_in">find_b</span>(rt,rt,k);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">splay</span>(r,l);</span><br><span class="line">    --T[T[r].a[<span class="number">0</span>]].t;</span><br><span class="line">    --T[T[r].a[<span class="number">0</span>]].s;</span><br><span class="line">    <span class="keyword">if</span>(T[T[r].a[<span class="number">0</span>]].t==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T[T[r].a[<span class="number">0</span>]].k=<span class="number">0</span>;</span><br><span class="line">        T[r].a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(r,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;T[T[x].a[<span class="number">0</span>]].s+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].a[<span class="number">0</span>],k);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[T[x].a[<span class="number">0</span>]].s+T[x].t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">splay</span>(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].a[<span class="number">1</span>],k-T[T[x].a[<span class="number">0</span>]].s-T[x].t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(<span class="built_in">find_f</span>(rt,rt,k),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> T[T[rt].a[<span class="number">0</span>]].s+T[rt].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;z,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="built_in">add</span>(rt,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="built_in">remove</span>(k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">num</span>(k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">sum</span>(rt,k+<span class="number">1</span>)].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">find_f</span>(rt,rt,k)].k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,T[<span class="built_in">find_b</span>(rt,rt,k)].k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>可持续化线段树</title>
    <url>/post/Sustainable-segment-tree/</url>
    <content><![CDATA[<h1 id="可持续化线段树"><a href="#可持续化线段树" class="headerlink" title="可持续化线段树"></a>可持续化线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;#8195； 模板题：<a href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组）</a><br>我们学习了很多的数据结构，它们支持修改、查询的操作。但是如果我们想在过去的某个版本上进行操作，我们就需要可持续化数据结构，比如说可持续化线段树，它支持在 $O(\log n)$ 的时间内进行操作。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>朴素的方法实现可持续化需要记录每个版本，修改一次就需要 $O(n)$ 的时间来复制，不能接受。但是我们可以发现，线段树上每一次操作都只改变树上的一条链，如果我们只复制这条链，就只需要 $O(\log n)$ 的时间来复制了。<br>我们要在只复制一条链的情况下保持原树和新树都是完整的，就需要把没有改变的所有点与新的链连在一起，并记录每一个版本的根节点。由于每一次修改都要改变根节点，所以每一个版本都对应一个根节点，这个根节点的子树就是一颗完整的线段树。如下图：<br>![0](&#x2F;post-images&#x2F;Sustainable-segment-tree-1.jpg &#x3D;450x)<br>![1](&#x2F;post-images&#x2F;Sustainable-segment-tree-2.jpg &#x3D;450x)<br>（图片来自网络）</p>
<h2 id="储存及更新"><a href="#储存及更新" class="headerlink" title="储存及更新"></a>储存及更新</h2><p>可持续化线段树不再像线段树那样储存左端点与右端点，而是左儿子与右儿子，因为可持续化线段树不再满足完全二叉树那样的编号规律，但是左右端点都可以轻松算出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,s;</span><br><span class="line">&#125;T[<span class="number">100000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].l].s+T[T[x].r].s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>可持续化线段树的建立和线段树几乎一样，只是新节点的编号要单独算，这个过程要传址，就像平衡树那样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++p;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].s=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(T[x].l,l,z);</span><br><span class="line">    <span class="built_in">build</span>(T[x].r,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>可持续化线段树的单点修改需要把所修改节点到根节点的所有节点全部备份一遍、更改，注意这个过程还要传递当前区间的左右端点，同时也要传址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[++p]=T[x];</span><br><span class="line">    T[p].s=k;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=z) <span class="built_in">modify</span>(T[x].l,l,z,q,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(T[x].r,z+<span class="number">1</span>,r,q,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>查询操作就和线段树十分相似了，只是同时需要传递左右端点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> l0,<span class="type">int</span> r0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=l0&amp;&amp;r&lt;=r0) <span class="keyword">return</span> T[x].s;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l0&lt;=z) s+=<span class="built_in">sum</span>(T[x].l,l,z,l0,r0);</span><br><span class="line">    <span class="keyword">if</span>(r0&gt;z) s+=<span class="built_in">sum</span>(T[x].r,z+<span class="number">1</span>,r,l0,r0);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>可持续化线段树调用的根节点是指定版本的根节点复制过来的根节点，这样调用的时候就会在这个根节点下面新建节点，同时这个根节点也会在操作后指向新的节点。不过板子题比较特殊的是查询操作也要新建版本，我们只需要把根节点复制一遍即可，其它节点都不用变。可持续化线段树一般也要建树，对应的根节点为 $0$，这样可以防止在一些操作中越界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">build</span>(rt[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d,z,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;d,&amp;z,&amp;x,&amp;y);</span><br><span class="line">    rt[i]=rt[d];</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">modify</span>(rt[i],<span class="number">1</span>,n,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(rt[i],<span class="number">1</span>,n,x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">0</span>,a[<span class="number">1000001</span>],b[<span class="number">1000001</span>],rt[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,s;</span><br><span class="line">&#125;T[<span class="number">100000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].l].s+T[T[x].r].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++p;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].s=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(T[x].l,l,z);</span><br><span class="line">    <span class="built_in">build</span>(T[x].r,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[++p]=T[x];</span><br><span class="line">    T[p].s=k;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=z) <span class="built_in">modify</span>(T[x].l,l,z,q,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(T[x].r,z+<span class="number">1</span>,r,q,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> l0,<span class="type">int</span> r0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=l0&amp;&amp;r&lt;=r0) <span class="keyword">return</span> T[x].s;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l0&lt;=z) s+=<span class="built_in">sum</span>(T[x].l,l,z,l0,r0);</span><br><span class="line">    <span class="keyword">if</span>(r0&gt;z) s+=<span class="built_in">sum</span>(T[x].r,z+<span class="number">1</span>,r,l0,r0);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(rt[<span class="number">0</span>],<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d,z,x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;d,&amp;z,&amp;x,&amp;y);</span><br><span class="line">        rt[i]=rt[d];</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(rt[i],<span class="number">1</span>,n,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(rt[i],<span class="number">1</span>,n,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>&amp;#8195； 模板题：<a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2</a><br>主席树是可持续化线段树的一种经典应用，但是它不是用来解决需要操作历史版本的问题的，而是用来解决一个不可修改的序列的，经典问题就是一个数在区间 $[l,r]$ 的排名和区间第 $k$ 小，不带修改操作的话主席树就是最好的解法。</p>
<h2 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h2><p>要找一个数在区间 $[l,r]$ 的排名，我们很容易想到对于每个数做前缀和的方法，但是要从第 $i-1$ 个数转移到第 $i$ 个数，就需要转移 $q$ 次（$q$ 是所有数离散化后的数的个数），不能接受。但是我们发现，每一次转移都只有一个数发生了改变，其它的都与上一个版本相同。而可持续化线段树就是在历史版本上用 $\log n$ 的时间复制并修改一个版本上的一个点。<br>主席树的基本思想是把 $1\sim n$ 这 $n$ 个点看做 $n$ 个版本，对于版本 $i$ 记录每个数 $1\sim q$ 在 $[1,i]$ 中出现的次数 $b$，而主席树维护的就是 $b$ 数组。为什么要这样做？如果我们要找离散化后的数 $x$ 在区间 [l,r] 中的排名，我们只需要在版本 $l-1$ 中找到 $[1,x-1]$ 的和，同时在 $r$ 中找到 $[1,r]$ 的和，相减即为答案。而主席树版本 $i$ 与版本 $i-1$ 之间只有原序列 $a$ 的第 $i$ 上的数对应的位置的值改变了，相当于单点修改。但是在查询的时候有可能要访问到版本 $0$ 所以我们要先建立 $0$ 号版本，防止越界。<br>要解决区间第 $k$ 小的问题，我们只需要在线段树上进行二分。同时维护版本 $l-1$ 的当前节点 $x1$ 与版本 $r$ 上的当前节点 $x2$，如果 $x2$ 的左子树的和减去 $x1$ 左子树的和小于等于 $k$，表明区间 $[l,r]$ 中 $1\sim a_q$ 的数的总数比 $k$ 多，答案在左子树上，否则在右子树上。</p>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">0</span>,a[<span class="number">1000001</span>],b[<span class="number">1000001</span>],rt[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,s;</span><br><span class="line">&#125;T[<span class="number">10000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].l].s+T[T[x].r].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=++p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(T[x].l,l,z);</span><br><span class="line">    <span class="built_in">build</span>(T[x].r,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[++p]=T[x];</span><br><span class="line">    ++T[p].s;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=z) <span class="built_in">modify</span>(T[x].l,l,z,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(T[x].r,z+<span class="number">1</span>,r,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> x2,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> b[l];</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>,k=T[T[x2].l].s-T[T[x1].l].s;</span><br><span class="line">    <span class="keyword">if</span>(q&lt;=k) <span class="keyword">return</span> <span class="built_in">sum</span>(T[x1].l,T[x2].l,l,z,q);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">sum</span>(T[x1].r,T[x2].r,z+<span class="number">1</span>,r,q-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> q=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">build</span>(rt[<span class="number">0</span>],<span class="number">1</span>,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        rt[i]=rt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">modify</span>(rt[i],<span class="number">1</span>,q,<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+q+<span class="number">1</span>,a[i])-b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(rt[l<span class="number">-1</span>],rt[r],<span class="number">1</span>,q,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>可持续化线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>P4638 [SHOI2011]银行家</title>
    <url>/post/P4638-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4638">P4638 [SHOI2011]银行家</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题题目十分的冗杂，我们先来整理一下题意：一些客户要来银行取金币，如果 $i$ 个客户需要 $c_i$ 个金币，能打开的所有保险箱中金币总数多于 $c_i$ 就会取走对应的金币数，否则会全部取走，而且一个客户来取金币后就可以交换他打开的保险箱的金币，请问所有客户最多可以取走多少金币。<br>这道题初看就可以发现是一道网络流的题，金币即为流。在每一个客户打开了几个保险箱之后就把这些保险箱合并成一个保险箱即可。但是对于特定的客户（也就是第一个打开这些保险箱的客户之后的客户）才可以合并保险箱，而其他的客户就不行。如果我们把这些保险箱简单地连在一起，就可以给所有客户交换金币。<br>由于在第一个打开这个保险箱之后的客户才能合并保险箱，我们可以把合并起来的保险箱指向后面的所有客户，而不指向之前的客户就可以了。但是处理合并保险箱也比较麻烦，比如第一个人打开了保险箱 $1,2$，第二个人打开了 $2,3$，此时 $2,3$ 保险箱都可以取到保险箱 $1$ 的金币了，所以我们需要将每一个保险箱对应的合并保险箱再合并起来才对，而不是单独的原始保险箱。而且注意，此时对于保险箱 $2,3$ 来说 $1,2,3$ 是一个保险箱，但是对于保险箱 $1$ 来说只有 $1,2$ 是一个保险箱。<br>由于一个客户打开的所有保险箱都要合并，我们就可以把这个合并保险箱与这个客户捆绑。如果一个保险箱已经与一个客户捆绑了，那么当前客户就可以把这个保险箱里的金币从上一个人接手全部或部分过来。如果这个保险箱还没有人开过就直接把原始保险箱中的金币放在自己对应的保险箱中。<br>我们来看一眼样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">3 1 10</span><br><span class="line">2 1 2 2</span><br><span class="line">2 1 3 3</span><br><span class="line">1 2 6</span><br></pre></td></tr></table></figure>
<p>样例建出来的图如下（每一条边的容量都是正无穷），再加上源汇点即可。<br><img src="/post-images/p4638-solution-1.png?400x" alt="1"></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> N,n,m,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],v[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q;</span><br><span class="line">    ll r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s2);</span><br><span class="line">    f[s2]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                ++g[f[a[i].m]];</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[x]==f[a[i].m]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --g[f[x]];</span><br><span class="line">    <span class="keyword">if</span>(g[f[x]]==<span class="number">0</span>) u=<span class="literal">false</span>;</span><br><span class="line">    ++f[x];</span><br><span class="line">    ++g[f[x]];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    N=n+m+<span class="number">2</span>;</span><br><span class="line">    s1=N<span class="number">-1</span>;</span><br><span class="line">    s2=N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(s1,i,r);</span><br><span class="line">        <span class="built_in">road</span>(i,s1,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=d;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(v[x]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(x,m+i,<span class="number">1e18</span>);</span><br><span class="line">                <span class="built_in">road</span>(m+i,x,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">road</span>(m+v[x],m+i,<span class="number">1e18</span>);</span><br><span class="line">                <span class="built_in">road</span>(m+i,m+v[x],<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            v[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        ll r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(m+i,s2,r);</span><br><span class="line">        <span class="built_in">road</span>(s2,m+i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    ll r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>P2065 [TJOI2011]卡片</title>
    <url>/post/P2065-solution/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2065">P2065 [TJOI2011]卡片</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题显然可以用最大流来做，将红色卡片放在一边，蓝色卡片放在另一边，从源点 $s$ 向每个红色卡片连一条容量为 $1$ 的边，从每个蓝色卡片向汇点 $t$ 连一条容量为 $1$ 的边，并把所有公约数不为 $1$ 的异色卡片用一条容量为 $1$ 的边连起来，再从源点向汇点跑最大流即可。这道题看似可以这样简单地建图，但是这样其实会 $\color{purple}{TLE}$ ，只有 $70$ 分。分析一下，我们总共有 $n\times m$ 条边，每一次都要跑一边最大公约数，这些数最大是 $1000000$ ，很容易被卡掉。我们需要一个新的建边方法。<br><img src="/post-images/P2065-solution-1.png?500x" alt="1"><br>我们之前的方法需要 $n\times m$ 条边，如果能找到一种 $n+m$ 次的建边就可以了。建边的标准是两个数的最大公约数不为 $1$ ，也就是两个数存在同样的质因数。这 $n+m$ 个数中对于异色的卡片，所有有质因数 $2$ 的数都相互匹配，有质因数 $3$ 的数都可以相互匹配，等等。如果我们把有质因数 $2$ 的连在一个点上，有质因数 $3$ 的连在一个点上，依此类推，只需要 $n+m$ 次分解质因数即可。其中红色卡片与质因数点的边由红色卡片指向质因数点，蓝色卡片与质因数点的边由质因数点指向蓝色卡片，再连接源汇点就可以了。如图：<br><img src="/post-images/P2065-solution-2.png?600x" alt="2"></p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,n1,n2,q=<span class="number">0</span>,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],d[<span class="number">10000001</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s2);</span><br><span class="line">    f[s2]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                ++g[f[a[i].m]];</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[x]==f[a[i].m]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --g[f[x]];</span><br><span class="line">    <span class="keyword">if</span>(g[f[x]]==<span class="number">0</span>) u=<span class="literal">false</span>;</span><br><span class="line">    ++f[x];</span><br><span class="line">    ++g[f[x]];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ss1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x)&amp;&amp;x!=<span class="number">1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">0</span>) d[i]=++q;</span><br><span class="line">            <span class="built_in">road</span>(k,n1+n2+d[i],<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">road</span>(n1+n2+d[i],k,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[x]==<span class="number">0</span>) d[x]=++q;</span><br><span class="line">        <span class="built_in">road</span>(k,n1+n2+d[x],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(n1+n2+d[x],k,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ss2</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x)&amp;&amp;x!=<span class="number">1</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]==<span class="number">0</span>) d[i]=++q;</span><br><span class="line">            <span class="built_in">road</span>(n1+n2+d[i],k,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">road</span>(k,n1+n2+d[i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[x]==<span class="number">0</span>) d[x]=++q;</span><br><span class="line">        <span class="built_in">road</span>(n1+n2+d[x],k,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(k,n1+n2+d[x],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n1,&amp;n2);</span><br><span class="line">    p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) f[i]=g[i]=t[i]=<span class="number">0</span>;</span><br><span class="line">    u=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">ss1</span>(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">ss2</span>(n1+i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    N=n1+n2+q+<span class="number">2</span>;</span><br><span class="line">    s1=N<span class="number">-1</span>;</span><br><span class="line">    s2=N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(s1,i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(i,s1,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">road</span>(n1+i,s2,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">road</span>(s2,n1+i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">abc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>上下界网络流</title>
    <url>/post/Upper-and-lower-bound-network-flow/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在一般的网络流问题中，每条边都有一定的容量，也就是流量上限。而有的问题中，每条边还需要限制一个“流量下限”，也就是流过这条边的流量必须大于等于流量上限且小于等于流量下限。这样的问题需要新的思路来解决，我们需要将其转换为朴素的最大流。<br>上下界网络流分为几个问题：无源汇上下界可行流、有源汇上下界可行流、有源汇上下界最大流与有源汇上下界最小流。</p>
<h2 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h2><p>我们知道上下界网络流问题中每条边都有流量下限，所以是不是可以将最小流量流满，然后再跑最大流？显然不行，因为将最小流量流满后的图不一定满足流量守恒，也就是一个点流入的流量等于流出的流量（除源点、汇点）。如下图：<br><img src="/post-images/Upper-and-lower-bound-network-flow-1.png?500x" alt="1"><br>这个图就会变成下面两个图，第一幅是流满最小流量的图，第二幅是剩下最大流量的图。<br><img src="/post-images/Upper-and-lower-bound-network-flow-2.png" alt="2"><br>显然，第一幅图并不满足流量守恒，这样第二幅图跑出来了原图也不一定有解。第一幅图中 $1$ 号点流入流量比流出流量少了 $15$，$2$ 号点流入流量比流出流量少了 $10$，$3$ 号点流入流量比流出流量多了 $15$，$4$ 号点流入流量比流出流量多了 $10$。多的流量去哪里，少的流量从哪里来？我们可以用新建的超级源点和超级汇点，用源点补充少的流量，汇点吸走多的流量，如果这个点流入流量较多就连一条边到汇点，这个点流出流量较多从源点向这个点连一条边。但是超级源点和汇点并不存在，流量也不能这样流。所以源点补充的流量应该从第二幅图中来，汇点多出的流量也应该流到第二幅图中去。所以我们在第二幅图中也建立超级源点和汇点，并像第一幅图一样连边，只不过附加边方向反向，超级源点和超级汇点互换。如下图：<br><img src="/post-images/Upper-and-lower-bound-network-flow-3.png?500x" alt="3"><br><img src="/post-images/Upper-and-lower-bound-network-flow-4.png?500x" alt="4"><br>如何判断是否存在可行流？我们只需要在第二幅图中从源点到汇点跑最大流，如果从源点流出的按所有边已经流满，也就是流入汇点的所有边都流满了，就说明存在可行流。因为这样就说明第二幅图可以提供第一幅图的超级源点和超级汇点需要的流量，反之则无法满足第一幅图的超级源汇点所需流量，原图也就不存在可行流。由于从源点流出的边的总容量和流入汇点的边的总容量相等，所以只需要判断一边即可。上图就不存在可行流。</p>
<h2 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h2><p>如果我们在上图把 $1$ 号点设为源点，$4$ 号点设为汇点，情况就又不一样了。源点和汇点的特点是源点可以流出无限流量，汇点可以接收无限流量，源点流出的流量和汇点流入的流量相等。如何实现？我们只需要从汇点向源点连一条容量为无穷的边，就可以保证源点和汇点的流量相等。注意这条容量为正无穷的边是在建立了超级源点与超级汇点之后建立的，不影响与超级源点和超级汇点的连边。<br><img src="/post-images/Upper-and-lower-bound-network-flow-5.png" alt="5"><br>判断方法同上无源汇上下界可行流。这样我们就可以发现原图有解了。从源点流出或汇点流入的流量就是从源点流向汇点的流量。</p>
<h2 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h2><p>我们现在这个图中跑一边有源汇上下界可行流，找到从汇点到源点的附加边的实际流量，也就是这条边反向边的容量。但是我们只能得到一个可行流，并不是最大流，所以我们要再在残留网络上从源点到汇点跑一边最大流，注意这时要先删去附加边。跑出来的最大流加上原来附加边的实际流量就是最大流。<br>我们可以发现图中汇点到源点除了附加边，还有一条容量为 $15$ 的边，则就导致可能有流量从汇点到源点的部分流量这种边流过，我们也就无法得到真实的可行流的流量，但是这个对于最后的最大流没有影响，因为如果有流量从这些边流到源点，跑最大流的时候也一定能沿着反向边流过相同的流量到达终点，最后的和就没有变化。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t1,t2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],b[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t1,&amp;t2);</span><br><span class="line">    s1=n+<span class="number">1</span>;</span><br><span class="line">    s2=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,r1,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r1,&amp;r2);</span><br><span class="line">        <span class="built_in">road</span>(x,y,r2-r1);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>);</span><br><span class="line">        b[x]+=r1;</span><br><span class="line">        b[y]-=r1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">road</span>(s1,i,-b[i]);</span><br><span class="line">            <span class="built_in">road</span>(i,s1,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">road</span>(i,s2,b[i]);</span><br><span class="line">            <span class="built_in">road</span>(s2,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">road</span>(t2,t1,<span class="number">1e9</span>);</span><br><span class="line">    <span class="built_in">road</span>(t1,t2,<span class="number">0</span>);</span><br><span class="line">    n+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t0[i]=t[i];</span><br><span class="line">        <span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[s1];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;please go home to sleep&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n-=<span class="number">2</span>;</span><br><span class="line">    s1=t1;</span><br><span class="line">    s2=t2;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t[s2];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].m==s1)</span><br><span class="line">        &#123;</span><br><span class="line">            r+=a[i^<span class="number">1</span>].r;</span><br><span class="line">            a[i].r=a[i^<span class="number">1</span>].r=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡树Treap</title>
    <url>/post/Balanced-tree-Treap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3369">P3369 【模板】普通平衡树</a><br>在一堆元素中查找一个元素，线性查找需要 $O(n)$ 的时间，于是人们就发明了 BST 二叉搜索树，一个节点左子树上的元素的值总小于此节点的值，此节点的右子树上的元素的值总小于此节点的值。这样根据一个元素的值就可以快速（$O(\log n)$）在 BST 上查找到一个元素。BST 有一个特点，就是它的中序遍历序列就是所有元素排序后的结果。不过同样的一些元素组成的 BST 两个 BST 记录的是同一组数。<br><img src="/post-images/Balanced-tree-Treap-1.png" alt="1"><br>不过这样还是容易被卡，比如所有元素按照大小顺序加入 BST，这个 BST 就会退化为一个链，复杂度就退化为 $O(n)$ 了，如下图。<br><img src="/post-images/Balanced-tree-Treap-2.png?300x" alt="2"><br>这时候我们就需要适当调整这个 BST 的形状，让这个 BST 更加平衡，于是又出现了平衡树，这里介绍一种较简单的平衡树，它就是 Treap。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>Treap 其实是一个合成词“Tree+Heap”，翻译过来就是树堆，它既有 BST 的性质，也有堆的性质。Treap 会在插入元素的时候给每个元素一个随机的优先级，然后通过旋转操作，使得它满足 BST 的同时，还要满足一个节点的优先级小于它的所有儿子的优先级。由于优先级是随机的，所以这个 BST 的形状是随机的，就不会出现被卡成一条链的情况（只要人品正常）。</p>
<h2 id="储存及更新"><a href="#储存及更新" class="headerlink" title="储存及更新"></a>储存及更新</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">treap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,l,r,s,k,t;</span><br><span class="line">&#125;T[<span class="number">1000001</span>];</span><br></pre></td></tr></table></figure>
<p>平衡树的储存如上。Treap 的每个节点总共需要储存这几个值：这个节点的元素的值 $x$，这个节点的左、右儿子 $l,r$，这个节点的子树上总共的元素个数 $s$，这个节点的优先级 $k$ 和这个节点的元素个数 $t$。<br>平衡树需要动态更新当前子树的节点个数，我们就需要一个类似线段树的 pushup 函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].s=T[T[x].l].s+T[T[x].r].s+T[x].t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h2><p>Treap中非常难懂的一部分就是它的旋转操作，它可以改变 BST 的形状。旋转分为左旋与右旋。右旋操作其实就是将这个节点的父节点变为这个点的右子节点，这个点调整到原父节点的位置，并将这个点的右节点调整为其原父节点的左节点。如下图，从左图到右图的操作就是将 $2$ 号节点进行右旋。<br><img src="/post-images/Balanced-tree-Treap-3.png" alt="3"><br>左旋的操作刚好和右旋相反。我们可以发现，第一个BST的中序遍历为 $4,2,5,1,3$ ，而第二个 $4,2,5,1,3$，这两个 BST 实质上记录的东西实质上是一样的，但是它的形状已经改变了。我们就可以通过旋转操作改变一个 BST 的形状。<br>由于旋转操作要改变指向当前节点的指针，所以我们要使用传址的方法，这样在旋转改变当前节点的时候在调用它的函数中的指针也会改变。<br>旋转操作的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_l</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=T[x].r;</span><br><span class="line">    T[x].r=T[p].l;</span><br><span class="line">    T[p].l=x;</span><br><span class="line">    T[p].s=T[x].s;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(T[x].l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_r</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=T[x].l;</span><br><span class="line">    T[x].l=T[p].r;</span><br><span class="line">    T[p].r=x;</span><br><span class="line">    T[p].s=T[x].s;</span><br><span class="line">    x=p;</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(T[x].r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>Treap 的插入操作很简单，只需要一直找到对应元素值与插入值相等的位置或者发现不存在值相等的元素即可。如果我们要插入的元素值为 $k$，每到一个节点，如果对应元素值等于 $k$，就把这个点的元素个数加一；如果 $k$ 小于这个点的元素值，那么就进入这个点的左子节点；如果 $k$ 大于这个点的元素值，那么就进入这个点的右子节点；如果这个点的编号为 $0$，那么表明不存在与 $k$ 相等的元素，就新建一个节点，并随机赋优先级。<br>插入操作看似很简单，但是这样有可能不满足堆的性质，我们就需要进行旋转操作。如果左节点的优先级比这个节点小，那么就将这个节点右旋；如果右子节点的优先级比这个节点小，那么就将这个节点左旋。并且更新 Treap 的状态。<br>同样，插入操作由于要旋转，也要通过传址的方法传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=++q;</span><br><span class="line">        T[x].l=T[x].r=<span class="number">0</span>;</span><br><span class="line">        T[x].s=T[x].t=<span class="number">1</span>;</span><br><span class="line">        T[x].k=k;</span><br><span class="line">        T[x].h=<span class="built_in">rand</span>()*<span class="built_in">rand</span>()%<span class="number">1000000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==T[x].k) ++T[x].t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T[x].k) <span class="built_in">add</span>(T[x].l,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;T[x].k) <span class="built_in">add</span>(T[x].r,k);</span><br><span class="line">    <span class="keyword">if</span>(T[x].l!=<span class="number">0</span>&amp;&amp;T[x].h&gt;T[T[x].l].h) <span class="built_in">rotate_r</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(T[x].r!=<span class="number">0</span>&amp;&amp;T[x].h&gt;T[T[x].r].h) <span class="built_in">rotate_l</span>(x);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>Treap 的删除操作和插入操作相似，要一直找到对应元素值与删除值相等的位置，然后把这个位置的元素个数减一，如果个数为 $0$ 了，就删除这个节点，并将优先级较小的子节点放在这个位置，不过这时需要注意左右子节点是否存在。如果不存在这个节点，就说明没有这个元素。同样，最后的时候要更新结点个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==T[x].k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T[x].t&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	--T[x].t;</span><br><span class="line">            <span class="built_in">pushup</span>(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T[x].l==<span class="number">0</span>&amp;&amp;T[x].r==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T[x].l!=<span class="number">0</span>&amp;&amp;(T[x].r==<span class="number">0</span>||T[T[x].l].h&lt;T[T[x].r].h))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rotate_r</span>(x);</span><br><span class="line">            <span class="built_in">remove</span>(T[x].r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="built_in">rotate_l</span>(x);</span><br><span class="line">            <span class="built_in">remove</span>(T[x].l,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;T[x].k) <span class="built_in">remove</span>(T[x].l,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(T[x].r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询排名"><a href="#查询排名" class="headerlink" title="查询排名"></a>查询排名</h2><p>在 Treap 中查询一个元素的排名，只需要像之前一样一直访问直到找到这个元素即可。根节点在当前子树的排名就是左子树的大小加一，而左子树的所有节点的排名就是这个节点在左子树中的排名，右子树的所有节点的排名就是这个节点在右子树的排名加上左子树以及根节点的大小。由于访问不需要修改节点，就不需要再传址了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==T[x].k) <span class="keyword">return</span> T[T[x].l].s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;T[x].k) <span class="keyword">return</span> <span class="built_in">num</span>(T[x].l,k);</span><br><span class="line">    <span class="keyword">return</span> T[T[x].l].s+T[x].t+<span class="built_in">num</span>(T[x].r,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询对应排名的元素"><a href="#查询对应排名的元素" class="headerlink" title="查询对应排名的元素"></a>查询对应排名的元素</h2><p>要查询相应排名的元素，只需要在每一次判断这个元素在当前节点的根节点、左子树还是右子树上。如果当前子树中的排名小于左子树的大小，那么这个元素就在左子树中，这个元素在左子树中的排名就是当前子树中的排名；如果不在左子树中但是排名小于等于左子树大小加上根节点的大小，那么这个元素就是根节点的元素值；否则就在右子树中，在右子树中的排名就是在当前子树中的排名减去左子树的大小和根节点的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;T[T[x].l].s+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].l,k);</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[T[x].l].s+T[x].t) <span class="keyword">return</span> T[x].k;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(T[x].r,k-T[T[x].l].s-T[x].t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询前驱和后继"><a href="#查询前驱和后继" class="headerlink" title="查询前驱和后继"></a>查询前驱和后继</h2><p>一个点的前驱指的是小于这个元素值的最大的元素，后继指的是大于这个元素值的最小的元素。要找到一个点的前驱，当这个点在这个子树中时，如果要找的元素值小于等于根节点的元素值，说明这个元素在左子树中，就搜索左子树，否则在右子树中或者就是根节点，就搜索右子树。如果在左子树中但是最后没有找到，也就是返回了 $0$，说明这个节点没有在这个子树中，返回 $0$。如果在右子树中没有找到，说明这个元素的前驱就是根节点。最后，返回找到的元素或者 $0$。后继的查询操作刚好相反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_f</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_f</span>(T[x].l,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_f</span>(T[x].r,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> T[x].k;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_b</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=T[x].k) <span class="keyword">return</span> <span class="built_in">find_b</span>(T[x].r,k);</span><br><span class="line">    <span class="type">int</span> p=<span class="built_in">find_b</span>(T[x].l,k);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> T[x].k;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Treap函数的调用"><a href="#Treap函数的调用" class="headerlink" title="Treap函数的调用"></a>Treap函数的调用</h2><p>我们总共学习了 $6$ 个 Treap 的相关函数。调用的时候我们需要调用 Treap 的根节点。由于 Treap 的形状在时刻变化，所以我们需要用一个变量 $r$ 来记录根节点，初始值为 $0$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> z,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;z,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="built_in">add</span>(r,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="built_in">remove</span>(r,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">num</span>(r,k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(r,k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_f</span>(r,k));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(z==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find_b</span>(r,k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
using namespace std;
int m,r=0,q=0;
struct treap
&#123;
    int k,l,r,s,h,t;
&#125;T[1000001];
void pushup(int x)
&#123;
    T[x].s=T[T[x].l].s+T[T[x].r].s+T[x].t;
&#125;
void rotate_l(int &amp;x)
&#123;
    int p=T[x].r;
    T[x].r=T[p].l;
    T[p].l=x;
    T[p].s=T[x].s;
    x=p;
    pushup(x);
    pushup(T[x].l);
&#125;
void rotate_r(int &amp;x)
&#123;
    int p=T[x].l;
    T[x].l=T[p].r;
    T[p].r=x;
    T[p].s=T[x].s;
    x=p;
    pushup(x);
    pushup(T[x].r);
&#125;
void add(int &amp;x,int k)
&#123;
    if(x==0)
    &#123;
        x=++q;
        T[x].l=T[x].r=0;
        T[x].s=T[x].t=1;
        T[x].k=k;
        T[x].h=rand()*rand()%1000000+1;
        return;
    &#125;
    if(k==T[x].k) ++T[x].t;
    else if(k&lt;T[x].k) add(T[x].l,k);
    else if(k&gt;T[x].k) add(T[x].r,k);
    if(T[x].l!=0&amp;&amp;T[x].h&gt;T[T[x].l].h) rotate_r(x);
    if(T[x].r!=0&amp;&amp;T[x].h&gt;T[T[x].r].h) rotate_l(x);
    pushup(x);
&#125;
void remove(int &amp;x,int k)
&#123;
    if(x==0) return;
    if(k==T[x].k)
    &#123;
        if(T[x].t&gt;1)
        &#123;
            --T[x].t;
            pushup(x);
            return;
        &#125;
        if(T[x].l==0&amp;&amp;T[x].r==0)
        &#123;
            x=0;
            return;
        &#125;
        if(T[x].l!=0&amp;&amp;(T[x].r==0||T[T[x].l].h&lt;T[T[x].r].h))
        &#123;
            rotate_r(x);
            remove(T[x].r,k);
        &#125;
        else
        &#123;   
            rotate_l(x);
            remove(T[x].l,k);
        &#125;
        pushup(x);
        return;
    &#125;
    if(k&lt;T[x].k) remove(T[x].l,k);
    else remove(T[x].r,k);
    pushup(x);
&#125;
int num(int x,int k)
&#123;
    if(x==0) return 1;
    if(k==T[x].k) return T[T[x].l].s+1;
    if(k&lt;T[x].k) return num(T[x].l,k);
    return T[T[x].l].s+T[x].t+num(T[x].r,k);
&#125;
int sum(int x,int k)
&#123;
    if(x==0) return 1e9;
    if(k&lt;T[T[x].l].s+1) return sum(T[x].l,k);
    if(k&lt;=T[T[x].l].s+T[x].t) return T[x].k;
    return sum(T[x].r,k-T[T[x].l].s-T[x].t);
&#125;
int find_f(int x,int k)
&#123;
    if(x==0) return 0;
    if(k&lt;=T[x].k) return find_f(T[x].l,k);
    int p=find_f(T[x].r,k);
    if(p==0) return T[x].k;
    return p;
&#125;
int find_b(int x,int k)
&#123;
    if(x==0) return 0;
    if(k&gt;=T[x].k) return find_b(T[x].r,k);
    int p=find_b(T[x].l,k);
    if(p==0) return T[x].k;
    return p;
&#125;
int main()
&#123;
    srand(time(NULL));
    scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;++i)
    &#123;
        int z,k;
        scanf(&quot;%d%d&quot;,&amp;z,&amp;k);
        if(z==1) add(r,k);
        else if(z==2) remove(r,k);
        else if(z==3) printf(&quot;%d\n&quot;,num(r,k));
        else if(z==4) printf(&quot;%d\n&quot;,sum(r,k));
        else if(z==5) printf(&quot;%d\n&quot;,find_f(r,k));
        else if(z==6) printf(&quot;%d\n&quot;,find_b(r,k));
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>面积并扫描线</title>
    <url>/post/Scan-line/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a><br>这是一道经典的题目，需要求出 $n$ 个矩形的面积并，直接开数组显然会炸，数学方法也很难，这时候就需要使用神奇的扫描线算法来解决了。<br>扫描线算法的基本思想就是用一条线从下往上扫过图形，计算出相邻两条横边之间的面积，然后求和即可。扫描线的过程中需要知道相邻两个横边之间的距离，以及这当前位置图形的宽度。我们只需要将横边排序就可以知道相邻两个横边之间的距离，而当前位置图形的宽度可以用线段树来维护。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树需要求出当前位置图形的宽度，我们要如何修改当前位置图形的宽度呢？我们看下图：<br><img src="https://img.ffis.me/images/2019/08/10/image.png" alt="1"><br><img src="https://img.ffis.me/images/2019/08/10/image1cba39d5beb42edc.png" alt="2"><br>（图片来自网络）<br>我们可以发现，扫过一个矩形的下边就会增加图形的宽度，而遇到一个图形的上边就会减少图形的宽度。我们可以拿括号序列来举例：如果一个位置前面的左括号个数等于右括号个数，那么这个位置就不在任何括号中。同理：如果一个位置扫过的矩形下边个数等于矩形上边个数，那么这个位置当前没有被图形覆盖，反之则被图形覆盖。我们只需要记录一个位置当前已扫过的矩形下边个数减去已扫过的矩形上边个数，我们就可以通过这个数是否为 $0$ 来判断这个位置是否被图形覆盖。<br>现在我们要记录一条横线上的每个位置的值，并且我们每次需要求出有多少个值不为 $0$ 的位置，我们就可以用线段树来实现，线段树维护当前区间值不为 $0$ 的位置个数：<br><img src="https://img.ffis.me/images/2019/08/10/image0a03aa15aca4877e.png" alt="3"><br>不过我们需要维护的是两个相邻 $x$ 之间扫过的个数，而不是端点，是两个端点之间的线段，所以总共 $n$ 个点，只有 $n-1$ 个线段，线段树只需要维护 $n-1$ 个值。由于这些点之间可能间隔很大，所以还需要进行离散化，用 $b$ 数组记录离散化后的点原来的值，那么一个区间 $[l.r]$ 的长度就是 $b[T[x].r+1]-b[T[x].l]$。我们用一个变量 $t$ 来记录此区间被扫过的次数，如果不为 $0$ 那么此区间已经整体被覆盖。<br>这样我们就可以写出线段树了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].t) T[x].s=b[T[x].r+<span class="number">1</span>]-b[T[x].l];</span><br><span class="line">    <span class="keyword">else</span> T[x].s=T[x&lt;&lt;<span class="number">1</span>].s+T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].l=l;</span><br><span class="line">    T[x].r=r;</span><br><span class="line">    T[x].t=T[x].s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll l,ll r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[T[x].l]&gt;=r||b[T[x].r+<span class="number">1</span>]&lt;=l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[T[x].l]&gt;=l&amp;&amp;b[T[x].r+<span class="number">1</span>]&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].t+=k;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>在扫描线算法中，我们总共需要两次排序：将端点的横坐标排序和横线的纵坐标排序。在进行排序之后，我们还需要将端点横坐标离散化和去重，用 STL 的 unique 函数就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l,r,h;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;a[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,t;</span><br><span class="line">    ll s;</span><br><span class="line">&#125;T[<span class="number">10000001</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(str a,str b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>]=(str)&#123;x1,x2,y1,<span class="number">1</span>&#125;;</span><br><span class="line">        a[i*<span class="number">2</span>]=(str)&#123;x1,x2,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        b[i*<span class="number">2</span><span class="number">-1</span>]=x1;</span><br><span class="line">        b[i*<span class="number">2</span>]=x2;</span><br><span class="line">    &#125;</span><br><span class="line">    n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>有了上面的所有准备，我们就可以写出扫描线了。我们只需要从第 $1$ 个横边扫到第 $n*2-1$  个横边即可，每一个区间的面积就是当前图形的宽度乘上这个横线到下一根横线的距离。用一个变量统计这些面积的和，最终的答案就是这个变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m<span class="number">-1</span>);</span><br><span class="line">ll s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,a[i].l,a[i].r,a[i].k);</span><br><span class="line">    s+=T[<span class="number">1</span>].s*(a[i+<span class="number">1</span>].h-a[i].h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll b[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    ll l,r,h;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">&#125;a[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,t;</span><br><span class="line">    ll s;</span><br><span class="line">&#125;T[<span class="number">10000001</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(str a,str b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[x].t) T[x].s=b[T[x].r+<span class="number">1</span>]-b[T[x].l];</span><br><span class="line">    <span class="keyword">else</span> T[x].s=T[x&lt;&lt;<span class="number">1</span>].s+T[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T[x].l=l;</span><br><span class="line">    T[x].r=r;</span><br><span class="line">    T[x].t=T[x].s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> z=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>,l,z);</span><br><span class="line">    <span class="built_in">build</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,z+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll l,ll r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[T[x].l]&gt;=r||b[T[x].r+<span class="number">1</span>]&lt;=l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[T[x].l]&gt;=l&amp;&amp;b[T[x].r+<span class="number">1</span>]&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x].t+=k;</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">add</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        a[i*<span class="number">2</span><span class="number">-1</span>]=(str)&#123;x1,x2,y1,<span class="number">1</span>&#125;;</span><br><span class="line">        a[i*<span class="number">2</span>]=(str)&#123;x1,x2,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        b[i*<span class="number">2</span><span class="number">-1</span>]=x1;</span><br><span class="line">        b[i*<span class="number">2</span>]=x2;</span><br><span class="line">    &#125;</span><br><span class="line">    n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">    m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m<span class="number">-1</span>);</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>,a[i].l,a[i].r,a[i].k);</span><br><span class="line">        s+=T[<span class="number">1</span>].s*(a[i+<span class="number">1</span>].h-a[i].h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>扫描线</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>最小费用最大流EK</title>
    <url>/post/minimum-cost-maximum-flow-EK/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3381">P3381 【模板】最小费用最大流</a><br><a href="/post/minimum-cost-maximum-flow-problemlist/">费用流题单</a><br>前置知识：<a href="/post/maximum-flow-Dinic/">最大流Dinic</a><br>进阶知识：<a href="/post/minimum-cost-maximum-flow-Dinic/">最小费用最大流Dinic</a><br>最小费用最大流问题，简称费用流。费用流问题是在最大流的基础上给每条边添加一个边权，也就是费用，总费用就是流过每条边的流量乘上费用的和，在保证流量最大的情况下，求出这个最小费用。<br>最大流问题可以使用每次 dfs 找增广路来解决，费用流就可以用 SPFA 来寻找增广路，这样就可以保证每一次的增广路的费用最小。由于最大流算法可以“反悔”，所以即使当前的增广路并不是全局最优的，也可以在之后的增广中“反悔”，所以最后找到的一定是最优解。不过 SPFA 在搜索过程中不知道最优解，所以要记录最优路线，搜索完成后再更新所有边的容量。</p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA 的过程中总共需要维护 $3$ 个数组：到达每个点的流量，到达每个点的费用，与这个点是由哪个点更新来的。不过SPFA是找到费用最小的增广路，而不是流量最大，因为可以进行多次 SPFA 增加流量。如果当前边的流量不为 $0$ ，到达每个点的最小费用 $g$ 的就可以做如下更新： $g[a[i].m]&#x3D;\max(g[a[i].m],g[x]))$。如果最小费用更新成功，流量 $f[a[i].m]$ 也要更新为 $min(f[x]),a[i].r$ ，这个点的父亲 $r[a[i].m]$ 则更新为 $x$。这样就可以找到当前费用最小的增广路。当汇点没有被走到的时候，就说明不存在增广路了。<br>进行完一次 SPFA 后，最大流量就要加上汇点的流量 $f[t]$，费用加上汇点的流量与到达汇点的费用之积 $f[t] \times g[t]$<br>在进行了 SPFA 之后，我们就需要更新每条边的容量。从汇点开始，每一次都到达当前点的父亲，并把经过的所有边的容量减去 $f[t]$，其相反边的容量加上 $f[s]$。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s1,s2,p=<span class="number">1</span>,t[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>],r[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> h[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,m,q,r,w;</span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].x=x;</span><br><span class="line">    a[p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">    a[p].w=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">1e9</span>;</span><br><span class="line">        g[i]=<span class="number">1e9</span>;</span><br><span class="line">        h[i]=<span class="literal">false</span>;</span><br><span class="line">        r[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g[s1]=<span class="number">0</span>;</span><br><span class="line">    h[s1]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(h[k]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        h[k]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].r&gt;<span class="number">0</span>&amp;&amp;g[k]+a[i].w&lt;g[a[i].m])</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=<span class="built_in">min</span>(f[k],a[i].r);</span><br><span class="line">                g[a[i].m]=g[k]+a[i].w;</span><br><span class="line">                r[a[i].m]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">                h[a[i].m]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[s2]!=<span class="number">1e9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s1,&amp;s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,r,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r,&amp;w);</span><br><span class="line">        <span class="built_in">road</span>(x,y,r,w);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">SPFA</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s+=f[s2];</span><br><span class="line">        w+=f[s2]*g[s2];</span><br><span class="line">        <span class="type">int</span> x=s2;</span><br><span class="line">        <span class="keyword">while</span>(x!=s1)</span><br><span class="line">        &#123;</span><br><span class="line">            a[r[x]].r-=f[s2];</span><br><span class="line">            a[r[x]^<span class="number">1</span>].r+=f[s2];</span><br><span class="line">            x=a[r[x]].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,s,w);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流ISAP</title>
    <url>/post/maximum-flow-ISAP/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3376">P3376 【模板】网络最大流</a><br><a href="/post/maximum-flow-problemlist/">最大流题单</a><br>前置知识：<a href="/post/maximum-flow-Dinic/">最大流Dinic</a><br>Dinic 算法已经能够很好地解决最大流问题了，但是它还是有一个弊端：会进行多次且次数不确定的 bfs，就会浪费时间，还可能被毒瘤出题人卡。Dinic 中，bfs 的作用就是将这个图分层，如果我们只在一开始时将图分层，在之后的 dfs 中调整每个点的高度，就可以大大减少bfs次数。</p>
<h2 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h2><p>ISAP 就成功地优化了 Dinic。不过 ISAP 是将汇点的高度设为 $1$，源点最高，流量会从高度较高的点流到高度较低的点，原因会在后面解释。在 dfs 过程中，如果一个点仍有剩余流量却流不出去了，那么就把这个点的高度加一，这样它才能流到更多的点。如果汇点高度最高，就需要其它点的高度减一，就可能出现负数，最好避免这种情况。这样就可以避免多次分层浪费时间。<br>但是 ISAP 不是在找不到汇点的时候结束，而是在出现断层的时候停止。断层指的是汇点的高度到源点的高度之间有一个高度没有点。由于流量都是从一层流向下一层，如果有一个高度没有点，流量就无法到达下一层，也就无法到达汇点，就可以直接停止算法。由于一开始高度是连续的，只要有剩余流量，就会增加高度，没有流量就不会，所以这个图在出现断层时一定是上一个层的所有点没有剩余流量了。<br>同样，ISAP 也可以添加当前弧优化，具体见最大流 Dinic 算法。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>],g[<span class="number">10001</span>];</span><br><span class="line"><span class="type">bool</span> u=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s2);</span><br><span class="line">    f[s2]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                ++g[f[a[i].m]];</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[x]==f[a[i].m]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --g[f[x]];</span><br><span class="line">    <span class="keyword">if</span>(g[f[x]]==<span class="number">0</span>) u=<span class="literal">false</span>;</span><br><span class="line">    ++f[x];</span><br><span class="line">    ++g[f[x]];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s1,&amp;s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(x,y,r);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u==<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流Dinic</title>
    <url>/post/maximum-flow-Dinic/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3376">P3376 【模板】网络最大流</a><br><a href="/post/maximum-flow-problemlist/">最大流题单</a><br>进阶知识：<a href="/post/maximum-flow-ISAP/">最大流ISAP</a><br>一个图中，每条边都有一定的承载能力，也就是容量，流过这条边的流量不得超过这条边的最大流量，从源点到汇点的最大流量就叫做最大流。<br>最大流问题有很多种解法，而 Dinic 是一种简单又比较实用的方法，但是多数解法都有一个思想：残留网络。</p>
<h2 id="残留网络"><a href="#残留网络" class="headerlink" title="残留网络"></a>残留网络</h2><p>增广路指的就是一条从源点到汇点，且经过的边最小容量不为 $0$ 的路径.显而易见，我们可以通过每一次搜索增广路，然后将经过的边的流量减去这条增广路的流量，这条增广路的流量就是经过的所有边的容量的最小值。但是这种算法是错误的，见下图：<br><img src="/post-images/maximum-flow-Dinic-1.png?300x" alt="1"><br>如果我们按照上述算法，可能就会找到这个路径：<br><img src="/post-images/maximum-flow-Dinic-2.png?300x" alt="2"><br>这样找出来的最大流为 $1$，而真实的最大流为 $2$，显然不正确。这是因为我们第一次找到的增广路影响了后面寻找更多增广路。如果我们让后续寻找更多增广路时可以“反悔”，也就是修改之前的增广路，这个问题就解决了。为了实现这个方案，残留网络就出现了。<br>我们对于每一条边都增加一条容量为 $0$ 反向边，找到增广路后经过的边流量要减去此增广路的流量，其反向边的流量还要加上此增广路的流量。所有反向边组成的图就是残留网络。于是刚刚的图就变成了这个图：<br><img src="/post-images/maximum-flow-Dinic-3.png?300x" alt="3"><br><img src="/post-images/maximum-flow-Dinic-4.png?300x" alt="4"><br>对于这个图，我们还可以找到一条增广路：<br><img src="/post-images/maximum-flow-Dinic-5.png?300x" alt="5"><br>于是我们就正确求解出了这个图的最大流。<br>残留网络并不是简单地增加了一条运输流量的边，它是让之后寻找增广路时可以使水流沿着这条边流回去，也就是将之前的增广路“反悔”了。所以这种思想是正确的。为什么反边的容量为 $0$ 呢？因为只有再原边有流量的时候才能反悔，原边流量多少才能反悔多少。</p>
<h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p>Dinic算法就成功实现了这种思想。寻找增广路就是寻找一条可行解，而不是最优解，若使用 bfs 会几乎遍历整张图，而 dfs 就可以很快找到一条增广路。但是 dfs 也容易被卡，因为可能会绕远路甚至流回已经过的点，就会浪费时间。所以 Dinic 结合了 bfs 与 dfs，新增了分层图这个概念。<br>DInic算法会首先进行一次 bfs，按照搜索的先后顺序分层，构建分层图。然后进行 dfs，此时 dfs 有一个限制，就是流量只会从上一层流到下一层。这样可能已经找不到增广路了，但实际上还有许多增广路没被发现。这时就需要再一次进行 bfs，注意 bfs 不会经过容量为 $0$ 的边，这样就会构建一个新的分层图，再进行 dfs 。最后直到一次 bfs 无法到达汇点，即不存在增广路，Dinic 结束。此时的总流量就是最大流。<br>Dinic成功解决了之前dfs被卡的问题，因为流量只能从高的点向低的点流，并且bfs次数较少。不过Dinic还是要进行数次bfs，所以出现了更优的算法ISAP，可以只进行一次bfs。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>dfs过程中我们会一直流直到把一条边流完再转到下一条边，如果一条边有容量但是却没有增广路，说明这条边的下一个点已经没有更多容量了，我们就可以把连接的这个点的高度标记为 $0$ ，下一次就不会再搜索到这个点了。<br>不过 Dinic 还是很慢，甚至比 EK 还慢，这时候我们就需要拯救 Dinic 的当前弧优化。上面说到，dfs 过程中会一直流直到把一条边流完再转到下一条边，当搜索到一条边的时候说明这条边之前的所有边都已经没有增广路了，我们就可以直接将 $t$ 指向这条边，这样下一次就不会再次搜索已经没有流量的边了。</p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>无向图的最大流可以通过建立两组边来实现，但是也可以更简单地去掉流量为 $0$ 的反向边，也就是对于一条容量为 $r$ 的无向边，从起点到终点建立一条容量为 $r$ 的无向边，再从终点到起点建立一条容量为 $r$ 的无向边即可。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,p=<span class="number">1</span>,s1,s2,t[<span class="number">10001</span>],t0[<span class="number">10001</span>],f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m,q,r;</span><br><span class="line">&#125;a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">road</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++p].m=y;</span><br><span class="line">    a[p].q=t[x];</span><br><span class="line">    t[x]=p;</span><br><span class="line">    a[p].r=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=<span class="number">0</span>;</span><br><span class="line">    f[s1]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t[k];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[a[i].m]==<span class="number">0</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f[a[i].m]=f[k]+<span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i].m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s2]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==s2) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=t0[x];i!=<span class="number">0</span>;i=a[i].q)</span><br><span class="line">    &#123;</span><br><span class="line">        t0[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(f[a[i].m]==f[x]+<span class="number">1</span>&amp;&amp;a[i].r!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z=<span class="built_in">dfs</span>(a[i].m,<span class="built_in">min</span>(r,a[i].r));</span><br><span class="line">            <span class="keyword">if</span>(z!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i].r-=z;</span><br><span class="line">                a[i^<span class="number">1</span>].r+=z;</span><br><span class="line">                r-=z;</span><br><span class="line">                s+=z;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> f[a[i].m]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">return</span> s; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s1,&amp;s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="built_in">road</span>(x,y,r);</span><br><span class="line">        <span class="built_in">road</span>(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) t0[i]=t[i];</span><br><span class="line">        r+=<span class="built_in">dfs</span>(s1,<span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包（单调队列优化）</title>
    <url>/post/Monotone-queue-optimization-knapsack/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多重背包问题的时间复杂度为 $O(nm^2)$，复杂度很高，所以我们需要将其优化。其中一种办法就是使用单调队列优化，可以使复杂度达到 $O(nm)$。</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列的一个元素有两个值：元素的值和位置（下标），单调队列会保证队首元素是原数列中值最小（或最大）的。单调队列的作用可以看下面的模板题：<br><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 &#x2F;【模板】单调队列</a><br>有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。<br>了解了单调队列的用途，我们以样例为例来看它如何实现。STL中的双端队列可以实现单调队列，但是常数不得不说有一点大，所以一般单调队列都用手写队列来实现。<br>$\text{1 3 -1 -3 5 3 6 7}$<br>首先定义两个队列 $p$ 与 $q$（也可以定义结构体队列），$p$ 中是每个元素在原数列的位置，$q$ 中是每个元素的值。<br>(1) 将 $1$ 入队，$q &#x3D; { 1 },p &#x3D; { 1 }$，此时队首元素为 $1$；<br>(2) 将 $3$ 入队，由于 $3 &gt; 1$，所以 $q &#x3D; { 1,3 },p &#x3D; { 1,2 }$，此时队首元素为 $1$；<br>(3) 将 $-1$ 入队，由于 $-1 &lt; 3,-1 &lt; 1$，所以 $1$ 和 $3$ 都出队，$q &#x3D; { -1 },p &#x3D; { 3 }$，此时队首元素为 $-1$；<br>(4) 将 $-3$ 入队，同理 $-3 &lt; -1$，所以将 $-1$ 出队，此时$q &#x3D; { -3 },p &#x3D; { 4 }$，队首元素为 $-3$；<br>(5) 将 $5$ 入队，此时$q &#x3D; { -3,5 },p &#x3D; { 4,5 }$，队首元素为 $-3$；<br>(6) 将 $3$ 入队，由于 $3 &lt; 5$，所以$q &#x3D; { -3,3 },p &#x3D; { 4,6 }$，队首元素为 $-3$；<br>(7) 将 $6$ 入队，由于 $4 \leqslant 7 - 3$，也就是 $-3$ 已经不在窗口中了，所以弹出 $-3$ ，此时$q &#x3D; { 3,6 },p &#x3D; { 6,7 }$，队首元素为 $3$；<br>(8) 将 $7$ 入队，此时$q &#x3D; { 3,6,7 },p &#x3D; { 6,7,8 }$，队首元素为 $3$；<br>可以观察到每一次操作的队首元素都是当前窗口中的最小值（除了(1)(2)，因为此时已经入队的元素个数少于窗口大小）。我们可以简单总结以下这些操作：设元素总数为 $n$，窗口大小为 $m$，对于一个即将入队的元素 $x_i$ ，如果队尾元素满足 $x_i &lt; q_{back}$，那么弹出队尾元素，如果队首元素对应的在原数列中的位置 $p_{front} \leqslant i - m$，那么弹出队首元素，然后将 $x_i$ 加入到 $q$ 的队尾，$i$ 加入到 $p$ 的队尾，如果 $x_i \geqslant m$，则队首元素就是当前窗口中的最小元素。<br>同理，我们也可以推出最大值的求法。下面上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">1000001</span>],q[<span class="number">1000001</span>],p[<span class="number">1000001</span>],T,R;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    T=<span class="number">0</span>,R=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;p[T]&lt;=i-m) ++T;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;q[R]&gt;a[i]) --R;</span><br><span class="line">        q[++R]=a[i];</span><br><span class="line">        p[R]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[T]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    T=<span class="number">0</span>,R=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;p[T]&lt;=i-m) ++T;</span><br><span class="line">        <span class="keyword">while</span>(T&lt;=R&amp;&amp;q[R]&lt;a[i]) --R;</span><br><span class="line">        q[++R]=a[i];</span><br><span class="line">        p[R]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[T]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列优化多重背包"><a href="#单调队列优化多重背包" class="headerlink" title="单调队列优化多重背包"></a>单调队列优化多重背包</h2><p>单调队列如何能和背包扯上关系的？设这件物品体积为 $v$，价值为 $w$，数量为$k$，我们来看一下多重背包的状态转移方程：<br>$f[m] &#x3D; \max(f[m], f[m-v]+w, f[m-2\times v]+2\times w, f[m-3\times v]+3\times w,\cdots)$<br>将 $m$ 换为其他数，我们就可以得到：<br>$f[j]&#x3D;f[j]$<br>$f[j+v]&#x3D;\max(f[j]+w,f[j+v])$<br>$f[j+2\times v]&#x3D;\max(f[j]+2\times w,f[j+v]+w,f[j+2\times v])$<br>$f[j+3\times v]&#x3D;\max(f[j]+3\times w,f[j+v]+2\times w,f[j+2\times v]+w,f[j+3\times v])$<br>稍加转换，可得：<br>$f[j+0\times v]&#x3D;\max(f[j])$<br>$f[j+1\times v]&#x3D;\max(f[j],f[j+v]-w)+w$<br>$f[j+2\times v]&#x3D;\max(f[j],f[j+v]-w,f[j+2\times v]-2\times w)+2\times w$<br>$f[j+3\times v]&#x3D;\max(f[j],f[j+v]-w,f[j+2\times v]-2\times w,f[j+3\times v]-3\times w)+3\times w$<br>是不是惊人的相似。<br>这样就可以得到：<br>$f[j+k\times v]&#x3D;\max(f[j],f[j+v]-w,f[j+2\times v]-2\times w,f[j+3\times v]-3\times w,\cdots,f[j+k\times v]-k\times w)+k\times w$<br>我们就可以看成有一个大小为 $k$的窗口在数列上扫过，每一个状态对应一个窗口。这样这个问题就成功地转换成了单调队列的问题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q[<span class="number">1000001</span>],p[<span class="number">1000001</span>],T=<span class="number">-1</span>,R=<span class="number">0</span>,f[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;b,&amp;a,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            T=<span class="number">0</span>;</span><br><span class="line">            R=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=m;k+=a)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(T&lt;=R&amp;&amp;k-p[T]&gt;a*c) ++T;</span><br><span class="line">                <span class="keyword">while</span>(T&lt;=R&amp;&amp;q[R]+(k-p[R])/a*b&lt;=f[k]) --R;</span><br><span class="line">                p[++R]=k;</span><br><span class="line">                q[R]=f[k];</span><br><span class="line">                f[k]=q[T]+(k-p[T])/a*b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>单调队列优化dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/post/Aho-Corasick-automaton/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KMP是一种很神奇的算法，它能够快速匹配模式串与文本串。但是如果遇到了多个模式串的情况，KMP 就需要 $O(k\times(n+m))$ 的时间，在 $k$ 很大的时候，KMP 是过不了这个题的，所以我们就需要一个新的算法：AC自动机。</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3808">P3808 【模板】AC 自动机（简单版）</a><br>我们已经知道了 Trie 和 KMP，一个是用于储存多个字符串，另一个是在一个文本串中查找一个模式串。而 AC 自动机需要实现在一个文本串中查找多个模式串，所以我们只需要将上面两者结合即可。<br>在 KMP 中，每一个节点都有一个失配指针，在文本串与模式串失配后跳转到模式串的对应位置。如果我们把 Trie 上的每一个节点都配上一个失配指针，只要文本串与字典树在此失配后跳转到字典树对应节点即可。失配指针指向的节点对应的字符串一定是适配节点对应的字符串的后缀，这样这个节点才能与文本串匹配。<br>但是字典树上不只有一个模式串，在一个位置可能有多个模式串可以匹配上文本串。但是在这个字符串已经与文本串匹配的时候，下一个可以匹配的字符串一定也可以和这个字符串匹配，所以下一个字符串一定是这一个字符串的后缀。刚好，失配指针也是要找到对应字符串的后缀，所以我们在找更多可以匹配的模式串时只需要跳转到失配指针对应的节点即可，<del>虽然并没有失配</del>。<br>AC 自动机的实现大概分为以下三步：建字典树、求失配指针指针、跑 AC 自动机。<br>字典树的建立和平常没有什么区别，只是要注意不仅要存每个节点是否有结束的模式串，还要记录有多少个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;    <span class="comment">//表示当前节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;x[i];++i)   <span class="comment">//依次匹配模式串的每个字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k][x[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) a[k][x[i]-<span class="string">&#x27;a&#x27;</span>]=++q;</span><br><span class="line">        <span class="comment">//如果没有当前字符对应的节点，就新建一个节点。</span></span><br><span class="line">        k=a[k][x[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//跳转到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++g[k]; <span class="comment">//记录当前节点的模式串个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求失配指针相当于是 AC 自动机的核心，也是最难理解的地方。<br>在建好字典树后，我们一般用 bfs 遍历整棵树。注意在遍历过程中数组f储存的是已配指针。同样，失配指针是储存在数组f中的。在求一个点的失配指针时，共有2种情况。<br>不过在求失配指针时，我们还会用到一些不存在的节点。这些点存在的意义就是让程序在匹配时知道如果文本串对应到这个点就会失配，并直接给出失配指针，这样可以更加的方便。<br>在开始前，我们还要将 $0$ 号节点的所有儿子设为根节点，因为如果有一个点对应的字符串无法在字典树中找到它的后缀，它的失配指针就会指向 $0$ 的儿子 $x$，但是实际上它应该跳转到根节点，所以把0号点所有儿子都指向根节点即可。<br>当我们搜索到点 $i$，它对应的字符为 $x$，父节点为 $k$。当点i存在时，它的失配指针就是点k的失配指针指向的节点的儿子 $x$。什么意思，见下图：<br>![1](<a href="https://cdn.luogu.com.cn/upload/image_hosting/udw2lc47.png?x-oss-process=image/resize,m_lfit,h_170,w_225">https://cdn.luogu.com.cn/upload/image_hosting/udw2lc47.png?x-oss-process=image/resize,m_lfit,h_170,w_225</a> &#x3D;300x200)<br>![2](<a href="https://cdn.luogu.com.cn/upload/image_hosting/jae281vb.png?x-oss-process=image/resize,m_lfit,h_170,w_225">https://cdn.luogu.com.cn/upload/image_hosting/jae281vb.png?x-oss-process=image/resize,m_lfit,h_170,w_225</a> &#x3D;300x200)<br>（图片来自网络）<br>第一幅图就是第一步建立出来的字典树，第二幅图表示每个节点的失配指针。举个例子，我们现在在访问最左侧的节点 $c$，它的父节点是上面的点 $b$，点 $b$ 的失配指针指向根节点的儿子 $b$。点 $c$ 对应的字符串是 $abc$。我们先找到 $b$ 的失配节点，也就是中间的 $b$，然后再找到 $b$ 位置对应的儿子 $c$，也就是中间的点 $c$，这样我们就找到了它对应的失配指针。<br>如果点 $k$ 的失配指针指向的节点没有儿子节点 $x$ 怎么办？其实是一样的，由于这个点不存在，所以这个位置就不存在原字符串的后缀，它的失配指针其实就直接指向了这个点的失配指针，所以它总会指向一个存在的点。在求完失配指针后，我们还要讲这个点入队来继续 bfs。<br>当我们搜索到点 $i$，它对应的字符为 $x$，父节点为 $k$。当点 $i$ 不存在时，点 $k$ 的儿子 $x$ 就是点 $k$ 的失配指针指向的节点的儿子 $x$。<br>因为点 $i$ 不存在，所以文本串如果匹配到此处必然失配，所以我们可以简单地将点 $k$ 的儿子 $x$ 指向点i的失配节点。点 $i$ 的失配指针的求法同上，就是点k的失配节点的儿子 $x$ 。由于这个点实际上不存在，所以不需要入队。如图：<br>![3](<a href="https://cdn.luogu.com.cn/upload/image_hosting/z4n1xw48.png?x-oss-process=image/resize,m_lfit,h_170,w_225">https://cdn.luogu.com.cn/upload/image_hosting/z4n1xw48.png?x-oss-process=image/resize,m_lfit,h_170,w_225</a> &#x3D;300x200)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;   <span class="comment">//搜索时用的队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;++i)  <span class="comment">//将节点0的所有儿子设为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>; <span class="comment">//根节点的失配指针只用于求其它点的失配指针</span></span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())   <span class="comment">//bfs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();    <span class="comment">//提取队首节点</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;++i)  <span class="comment">//访问所有儿子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k][i]!=<span class="number">0</span>)  <span class="comment">//这个点存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[k][i]);    <span class="comment">//入队</span></span><br><span class="line">                f[a[k][i]]=a[f[k]][i];  <span class="comment">//求失配指针</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">//这个点不存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[k][i]=a[f[k]][i]; <span class="comment">//求失配指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在求完失配指针后，我们就可以跑 AC 自动机了。<br>首先我们需要定义一个变量 $x$ 记录当前匹配到的字典树节点，初始值为 $1$，还有一个变量s储存出现过的模式串个数。<br>然后我们要依次访问整个文本串。每一次访问都将x更新为节点x对应文本串当前字符的儿子。如果节点 $x$ 有这个儿子，那么x就会指向这一个儿子节点；如果没有，它就会自动跳转到节点 $x$ 的失配指针指向的节点。然后我们要新定义一个变量 $k &#x3D; x$，循环访问节点 $k$ 的失配指针指向的节点，找到的这些都是可以与文本串匹配的字符串，所以我们要在这时记录个数，不过还要用一个数组来判断一个模式串是否已经被记录过。如果某一次节点 $k$ 已经被记录过，那么之前一定也记录过点 $k$ 之后所有可以与文本串匹配的模式串，所以可以直接退出循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">1000001</span>];</span><br><span class="line">cin&gt;&gt;c+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> m=<span class="built_in">strlen</span>(c+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>,x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)   <span class="comment">//依次访问文本串</span></span><br><span class="line">&#123;</span><br><span class="line">    x=a[x][c[i]-<span class="string">&#x27;a&#x27;</span>];   <span class="comment">//更新当前的点</span></span><br><span class="line">    <span class="type">int</span> k=x;</span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">0</span>&amp;&amp;h[k]==<span class="literal">false</span>)<span class="comment">//记录所有可以匹配的模式串</span></span><br><span class="line">    &#123;</span><br><span class="line">        s+=g[k];    <span class="comment">//计数</span></span><br><span class="line">        h[k]=<span class="literal">true</span>;  <span class="comment">//标记</span></span><br><span class="line">        k=f[k];     <span class="comment">//跳转至下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机加强版"><a href="#AC自动机加强版" class="headerlink" title="AC自动机加强版"></a>AC自动机加强版</h2><p>模板题：<a href="https://www.luogu.com.cn/problem/P3796">【模板】AC 自动机（加强版）</a><br>模板题：<a href="https://www.luogu.com.cn/problem/P5357">【模板】AC 自动机（二次加强版）</a><br>有的时候我们不仅要求出一个模式串是否在文本串中出现过，我们还需要知道它出现的次数。这时候我们就需要修改一下之前的方法，我们不能跳过已经有标记的点了，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(k!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    h[k]+=g[k];</span><br><span class="line">    k=f[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样下来一个点就可能不止被访问一遍，于是就会导致 $\color{purple}{TLE}$。如何解决这个问题呢？如果我们把一个点的失配指针指向的点和这个点连接起来，那么就会形成一个链，如果位于链首的点匹配成功一次，意味着后面所有点都会匹配成功一次。所以我们可以先统计第一个点匹配的次数，最后再更新后面所有点，复杂度就可以大大降低了。如何实现？我们再把失配指针当做一条有向边，所有的点必然会形成一个有向无环图，所以只需要在最后进行拓扑排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;       <span class="comment">//定义队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r[i]==<span class="number">0</span>) Q.<span class="built_in">push</span>(i);      <span class="comment">//入度为0的点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        h[f[k]]+=h[k];      <span class="comment">//统计</span></span><br><span class="line">        --r[f[k]];      <span class="comment">//入度减一</span></span><br><span class="line">        <span class="keyword">if</span>(r[f[k]]==<span class="number">0</span>) Q.<span class="built_in">push</span>(f[k]);    <span class="comment">//如果入度为0则入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q=<span class="number">1</span>,a[<span class="number">1000001</span>][<span class="number">26</span>],f[<span class="number">1000001</span>],g[<span class="number">1000001</span>],h[<span class="number">1000001</span>],r[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *x,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;x[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[k][x[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k][x[i]-<span class="string">&#x27;a&#x27;</span>]=++q;</span><br><span class="line">        &#125;</span><br><span class="line">        k=a[k][x[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    g[t]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k][i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(a[k][i]);</span><br><span class="line">                f[a[k][i]]=a[f[k]][i];</span><br><span class="line">                ++r[a[f[k]][i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[k][i]=a[f[k]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r[i]==<span class="number">0</span>) Q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        h[f[k]]+=h[k];</span><br><span class="line">        --r[f[k]];</span><br><span class="line">        <span class="keyword">if</span>(r[f[k]]==<span class="number">0</span>) Q.<span class="built_in">push</span>(f[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> x[<span class="number">200001</span>];</span><br><span class="line">        cin&gt;&gt;x+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(x,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="type">char</span> c[<span class="number">2000001</span>];</span><br><span class="line">    cin&gt;&gt;c+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">strlen</span>(c+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=a[x][c[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++h[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">abc</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[g[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串算法</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
</search>
